<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LjJiaJun&#39; Home</title>
  
  <subtitle>书青春 - 话人生 | Coding - Thinking - Acting</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="ctguljj.github.io/"/>
  <updated>2019-03-06T05:32:14.504Z</updated>
  <id>ctguljj.github.io/</id>
  
  <author>
    <name>LjJiaJun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>强制转换</title>
    <link href="ctguljj.github.io/2019/03/06/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>ctguljj.github.io/2019/03/06/强制转换/</id>
    <published>2019-03-06T05:32:14.000Z</published>
    <updated>2019-03-06T05:32:14.504Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码块高亮</title>
    <link href="ctguljj.github.io/2019/03/06/%E4%BB%A3%E7%A0%81%E5%9D%97%E9%AB%98%E4%BA%AE/"/>
    <id>ctguljj.github.io/2019/03/06/代码块高亮/</id>
    <published>2019-03-06T04:33:23.000Z</published>
    <updated>2019-03-06T04:36:01.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主题自带样式-代码块高亮"><a href="#主题自带样式-代码块高亮" class="headerlink" title="主题自带样式 代码块高亮"></a>主题自带样式 代码块高亮</h1><ul><li><p>这里指的是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```[language] [title] [url] [link-text]</span><br><span class="line"></span><br><span class="line">代码</span><br></pre></td></tr></table></figure></p></li><li><p>[language] 是代码语言的名称，用来设置代码块颜色高亮，非必须；</p></li><li>[title] 是顶部左边的说明，非必须；</li><li>[url] 是顶部右边的超链接地址，非必须；</li><li>[link text] 如它的字面意思，超链接的名称，非必须。</li><li>亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主题自带样式-代码块高亮&quot;&gt;&lt;a href=&quot;#主题自带样式-代码块高亮&quot; class=&quot;headerlink&quot; title=&quot;主题自带样式 代码块高亮&quot;&gt;&lt;/a&gt;主题自带样式 代码块高亮&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这里指的是&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="blog" scheme="ctguljj.github.io/categories/blog/"/>
    
      <category term="markdown" scheme="ctguljj.github.io/categories/blog/markdown/"/>
    
    
      <category term="blog" scheme="ctguljj.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>素数筛选法</title>
    <link href="ctguljj.github.io/2019/03/05/%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95/"/>
    <id>ctguljj.github.io/2019/03/05/素数筛选法/</id>
    <published>2019-03-05T14:44:50.000Z</published>
    <updated>2019-03-06T04:32:16.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h1><ul><li>一个数 n 如果是合数，那么它的所有的因子不超过sqrt(n)–n的开方</li><li></li></ul><h1 id="素数筛选法"><a href="#素数筛选法" class="headerlink" title="素数筛选法"></a>素数筛选法</h1><ul><li>素数是数学中一个很重要的数，很多算法中都需要用到素数相关的性质，因此传统的暴力循环求素数的效率显得十分低效，这里我们有两种高效求1~n以内的素数的方法。需要大家掌握，特别是欧拉筛法里面用到一点数学性质，大家可自行百度欧拉筛法掌握具体的原理，以后的出现的算法中还会出现。</li></ul><h1 id="欧拉筛法-时间复杂度（n"><a href="#欧拉筛法-时间复杂度（n" class="headerlink" title="欧拉筛法-时间复杂度（n)"></a>欧拉筛法-时间复杂度（n)</h1><ul><li><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/欧拉筛选法.png" alt=""></li><li>最简单的素数筛法是这样的：10000000内的素数，用这个筛选法可以大大的降低时间复杂度</li></ul><p>1.开一个大的bool型数组prime[]，大小就是n+1就可以了.先把所有的下标为奇数的标为true,下标为偶数的标为false.</p><p>2.然后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">for( i=3; i&lt;=sqrt(n); i+=2 )</span><br><span class="line">&#123;  </span><br><span class="line">if(prime)</span><br><span class="line">for( j=i+i; j&lt;=n; j+=i ) prime[j]=false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.最后输出bool数组中的值为true的单元的下标，就是所求的n以内的素数了。</p><pre><code>原理很简单，就是当i是质(素)数的时候，i的所有的倍数必然是合数。如果i已经被判断不是质数了，那么再找到i后面的质数来把这个质数的倍数筛掉。</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>No.1使用 合数=最大因数(除1和本身外)<em>最小质因数 的原理来筛，每个数只会被筛一次<br>对于每个数i，令它是某数的最大因数，然后从小到大地找&lt;=i的素数j，则i</em>j是合数<br>直到找到某个j使得i%j == 0,因为再往后的话，j’&gt; i的某个因子，我们能交换j’和i的这个因子，所以i不是i<em>j’的最大因数（或者说i</em>j’的最小质因数是刚才的那个j），再往后做没有意义</li></ul><ul><li><p>No.2回顾经典的Eratosthenes筛法，它可能对同一个质数筛去多次。那么如果用某种方法使得每个合数只被筛去一次就变成是线性的了。<br>不妨规定每个合数只用其最小的一个质因数去筛，这便是欧拉筛了。</p></li><li><p>No.3<br>线性筛有两个地方与一般筛不同:</p></li></ul><p>1.两层循环的顺序不同（一般筛是第一维prime[i] 第二维j，欧拉筛是第一维i 第二位prime[j]）</p><p>2.一行神奇的代码：<br>           <code>if(i%prime[j]==0)break;</code></p><p>prime[]数组中的素数是递增的,当i能整除prime[j]，那么i<em>prime[j+1]这个合数肯定被prime[j]乘以某个数筛掉。<br>   因为i中含有prime[j],prime[j]比prime[j+1]小，即    `i=k</em>prime[j]<code>，那么</code>i<em>prime[j+1]=(k</em>prime[j])<em>prime<code></code> [j+1]=k’</em>prime[j]<code>，接下去的素数同理。所以不用筛下去了。因此，在满足</code>i%prime[j]==0`这个条件之前以及第一次<br>   满足改条件时,prime[j]必定是prime[j]*i的最小因子。</p><p>No.4 证明分两部分。首先证每个合数都会被筛到（正确性），其次证每个合数只会被筛到一次（复杂度）。<br>每个合数都会被筛到<br>设有一合数 （为质数）<br>则一定会在  时被筛去（此时 ），因为对于小于 的质数，一定不会被  整除<br>每个合数都只会被筛到一次<br>与上面一样，还是设有一合数 （ 为质数）<br>倘若存在一个质因子  也筛去了，那么此时 。<br>o，此时在内层循环中已经早早地break掉了，因为 。<br>o，此时还没加进质数表QwQ（顺便一提：这种情况只有可能在  时发生）</p><p>代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler_sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">totPrimes = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag)); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123; </span><br><span class="line"><span class="keyword">if</span> (!flag[i]) </span><br><span class="line">primes[totPrimes++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i * primes[j] &lt;= n; j++) &#123; </span><br><span class="line">flag[i*primes[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>j &lt; totPrimes</code>为何不加？</li></ul><div class="note warning"><br>o当  为质数时，内层循环会在最后一个质数（也就是  自己）终止。<br><br><br>o当  为合数时，内层循环会在它的第一个质因数终止。<br>当然加了也没有问题<p></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学原理&quot;&gt;&lt;a href=&quot;#数学原理&quot; class=&quot;headerlink&quot; title=&quot;数学原理&quot;&gt;&lt;/a&gt;数学原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个数 n 如果是合数，那么它的所有的因子不超过sqrt(n)–n的开方&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法</title>
    <link href="ctguljj.github.io/2019/03/05/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    <id>ctguljj.github.io/2019/03/05/分治法/</id>
    <published>2019-03-05T13:33:34.000Z</published>
    <updated>2019-03-05T13:54:12.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="可使用分治法求解的一些经典问题"><a href="#可使用分治法求解的一些经典问题" class="headerlink" title="可使用分治法求解的一些经典问题"></a>可使用分治法求解的一些经典问题</h2><ul><li>（1）二分搜索<br>（2）大整数乘法<br>（3）Strassen矩阵乘法<br>（4）棋盘覆盖<br>（5）合并排序<br>（6）快速排序<br>（7）线性时间选择<br>（8）最接近点对问题<br>（9）循环赛日程表<br>（10）汉诺塔</li></ul><p>-</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分治法&quot;&gt;&lt;a href=&quot;#分治法&quot; class=&quot;headerlink&quot; title=&quot;分治法&quot;&gt;&lt;/a&gt;分治法&lt;/h1&gt;&lt;h2 id=&quot;可使用分治法求解的一些经典问题&quot;&gt;&lt;a href=&quot;#可使用分治法求解的一些经典问题&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="算法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分治法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>输入输出</title>
    <link href="ctguljj.github.io/2019/03/05/c-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>ctguljj.github.io/2019/03/05/c-输入输出/</id>
    <published>2019-03-05T10:17:49.000Z</published>
    <updated>2019-03-05T13:30:33.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><ul><li>gets()函数并不读取换行符’\n’,它会吧换行符替换成空字符’\0’,作为c语言字符串结束的标志.此时换行符已经没了！！</li><li>gets在C99标准中，已经不再建议使用gets()函数，而在C11中更是直接抛弃了这个函数,gets函数没有限制读入的个数，这很可能会导致程序向未知的内存空间写入数据，而导致程序出错。</li><li>fgets函数中第二个参数限制了读取的个数，这也解决了gets函数存在的问题，但要注意fgets函数只会读取n-1个字符（如果遇到换行符会更少），并在最后添加字符串结束标志，而且，fgets也会将换行符读入。<br><code>char *fgets(char *buf, int bufsize, FILE *stream)；</code>注意一下第二个参数bufsize，这个参数就限制了读取的字符的个数，这就可以解决gets()函数的缺陷。我们知道fgets() 函数主要用于读取文件，如果要读取键盘，则stream参数应该为stdin，需要注意的是，如果bufsize设置为n，那么fgets()函数最多读取n-1个字符，之所以用“最多”这个词是因为，如果在之前遇到了换行符，fgets函数也会返回。还有一点就是，fgets()函数会读取换行符（这一点和gets函数不同），当读取结束后，fgets函数会为buf在末尾添加一个空字符作为字符串的结束.</li><li>scanf函数要实现修改变量值的功能，传地址就相当于传指针（指向一个内存位置）！<br>printf只是对变量值执行输出功能，不涉及改变！</li></ul><h1 id="输入输出返回值"><a href="#输入输出返回值" class="headerlink" title="输入输出返回值"></a>输入输出返回值</h1><ul><li><p>scanf为函数，printf为函数(输入与输出函数)：返回值：scanf 函数的返回值反映的是按照指定的格式符正确读入的数据的个数。<br>如果输入数据与指定格式不符，则会产生输入错误。遇到输入错误，scanf函数会立即终止，返回已经成功读取的数据的个数。所以通过scanf函数的返回值和指定输入数据的个数（由格式符决定）的比较，可以判断数据输入是否成功。</p></li><li><p>scanf 函数是有返回值的，它的返回值可以分成三种情况</p></li></ul><ul><li><p>正整数，表示正确输入参数的个数。例如执行 scanf(“%d %d”, &amp;a, &amp;b); </p><pre><code>如果用户输入&quot;3 4&quot;，可以正确输入，返回2（正确输入了两个变量）；如果用户输入&quot;3,4&quot;，可以正确输入a，无法输入b，返回1（正确输入了一个变量）。 </code></pre></li><li><p><span id="inline-blue"> 0，表示用户的输入不匹配，无法正确输入任何值。如上例，用户如果输入”,3 4”，返回0。</span></p></li><li><p>EOF，这是在stdio.h里面定义的常量（通常值为-1），表示输入流已经结束(scanf遇到格式不对返回EOF或结束时)(EOF == end of file)</p></li></ul><ul><li>printf的返回值是输出的字符数，例如，<code>printf(&quot;1234&quot;)</code>的返回值是4，而<code>printf(&quot;1234\n&quot;)</code>的返回值是5。不知道有木有这样写的习惯<code>while (~scanf(&quot;....&quot;))</code>。这里出现了~这个符号，这个是位运算取反的意思。因为<code>~(n)=-(n+1)</code>。所以这里scanf的返回值为-1时~(-1)=0才退出循环。这就是这样写的意思。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;输入输出&quot;&gt;&lt;a href=&quot;#输入输出&quot; class=&quot;headerlink&quot; title=&quot;输入输出&quot;&gt;&lt;/a&gt;输入输出&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;gets()函数并不读取换行符’\n’,它会吧换行符替换成空字符’\0’,作为c语言字符串结束的标志.此时换行符
      
    
    </summary>
    
    
      <category term="输入输出" scheme="ctguljj.github.io/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>二分法</title>
    <link href="ctguljj.github.io/2019/03/04/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <id>ctguljj.github.io/2019/03/04/二分法/</id>
    <published>2019-03-04T15:28:49.000Z</published>
    <updated>2019-03-04T15:59:55.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分法-折半查找"><a href="#二分法-折半查找" class="headerlink" title="二分法(折半查找)"></a>二分法(折半查找)</h1><ul><li>将所给关键词和指定有序集合中间数进行比较,如果比较相等则返回结果,如果不相等,则按照所给出的结果,将集合减半后继续查找</li><li>二分法是减治法的思想</li><li>二分法：<code>(low+high)/2</code>,如果故意卡数据即low与high很大的话,会越界.所以可以为<code>(high - low)/2+low;</code></li></ul><h2 id="优化-先确定范围"><a href="#优化-先确定范围" class="headerlink" title="优化(先确定范围)"></a>优化(先确定范围)</h2><ul><li>插值查找</li><li>这里的插值查找法,是对二分法的一种改进.<strong>此法和二分法一样对数据要求有序且尽量分布均匀</strong></li><li>对于二分法有:    <code>mid = (low + high)/2;</code><br>不难得到  <code>mid = low + 1/2*(high-low);</code><br>试想,对于在字典中进行查找时,对于’you’或’and’<br>来说,我们通常的处理方法肯定不是从中间开始进行查找,而是根据所给出的值,大致确定范围后再来进行查找.<br>这里的大致范围是通过,所查找的value值在所查集合中所大概处于的位置,定位到后进行比较<br>故有如下公式:<br><code>key = low + ((value - a[low])/(a[high]-a[low]))*（high-low);</code></li></ul><p>伪代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int insertseek(int value,int map[])</span><br><span class="line"></span><br><span class="line">   int low,high,key;</span><br><span class="line"></span><br><span class="line"> low = 0; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">high = n -1 ;</span><br><span class="line"></span><br><span class="line">while(low&lt;=high)</span><br><span class="line"></span><br><span class="line">key = low + ((value - low)/(high-low))*（high -low);</span><br><span class="line"></span><br><span class="line">if(key = value) return key;</span><br><span class="line"></span><br><span class="line">else if(key &lt; value) low = key;</span><br><span class="line"></span><br><span class="line">else  high = key;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分法-折半查找&quot;&gt;&lt;a href=&quot;#二分法-折半查找&quot; class=&quot;headerlink&quot; title=&quot;二分法(折半查找)&quot;&gt;&lt;/a&gt;二分法(折半查找)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;将所给关键词和指定有序集合中间数进行比较,如果比较相等则返回结果,如果不相等
      
    
    </summary>
    
      <category term="算法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>c与c++常用函数</title>
    <link href="ctguljj.github.io/2019/03/04/c%E4%B8%8Ec-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>ctguljj.github.io/2019/03/04/c与c-常用函数/</id>
    <published>2019-03-04T04:51:49.000Z</published>
    <updated>2019-03-04T15:32:02.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><ul><li>max, min, fill, memset, sort, swap</li></ul><h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><ul><li>字符串比较函数strcmp因为原理是两个字符串一个个比较，所以可以比较字符是否相同！！！！！<div class="note success"><p>如果把序号按字符串存储，则会可以通过strcmp比较序号是否相同。</p></div>(有用)</li><li>Strlen函数如果没有遇到’\0’，会一直计算下去，字符串二维数组不可以用strlen，因为二维数组每一行相当于一个字符串一维数组，每一行都有’\0’！</li></ul><h2 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h2><ul><li>Memset函数:可以本身就是为字符数组设计的源代码：unsigned int 有一个特性就是如果将其赋值或者当作字节来使用的话，编译器将会截取低八位作为一个字节使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void *(memset)(void *s, int c, size_t n)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">const unsigned char uc = c;</span><br><span class="line">unsigned char *su;</span><br><span class="line">for (su = s; 0 &lt; n; ++su, --n)</span><br><span class="line">    *su = uc;</span><br><span class="line">return (s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码说明对于数组参数是按照字符数组的形式进行赋值的。<br>也就是c的值每次赋值给一个字节，而不是4个字节，c的类型是int类型，4个字节，<br>但只会赋值最低位的一个字节的内容。</p><ul><li><p>对于非单字节数据类型只能初始化为0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值0的结果都是0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果。</p></li><li><p>对于变量：当结构体类型中包含指针时，在使用memset初始化时需要小心。<br>struct sample_strcut stTest;用memset就非常方便：memset(&amp;stTest,0,sizeof(struct sample_struct));<br>原因是memset初始化的时候是按字节一个一个填充的，int有四个字节，于是填充成0000 0001 0000 0001 0000 00001 0000 0001，这样得出数组中的每个元素的值就是16843009了。<br>赋值时0与’\0’效果一样。</p></li><li>可以用于清空数组内元素与赋,memset函数一般用来填充char型数组,也经常用于填充int型的全0或全-1.不可用其它值，除非高低字节相同.</li></ul><p>-<br>    <code>`</code></p><pre><code>#define INF 0x3f3f3f3fint num[N];memset(num, INF, sizeof(num));</code></pre><p>这样得到的数组里面的每一个元素数值都是INF<br>看一下INF的二进制表示：<br>00111111001111110011111100111111<br>可以看出低8位是00111111，<strong><em>也就是实际赋值时是用<br>00111111来填充一个int类型</em></strong>，结果正好也是<br>00111111001111110011111100111111<br>于是就成功用memset进行了赋值。</p><h3 id="INF小知识"><a href="#INF小知识" class="headerlink" title="INF小知识"></a>INF小知识</h3><ul><li>0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。</li><li><p>另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。</p></li><li><p>最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！<strong><em>所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))</em></strong>。<br>所以在通常的场合下，const int INF = 0x3f3f3f3f;真的是一个非常棒的选择。</p></li><li><div class="note warning"><p>因为在某些编译器分配空间时,内存中默认值并不为0,所以先用memset函数赋初值0.</p></div></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用函数&quot;&gt;&lt;a href=&quot;#常用函数&quot; class=&quot;headerlink&quot; title=&quot;常用函数&quot;&gt;&lt;/a&gt;常用函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;max, min, fill, memset, sort, swap&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;字符
      
    
    </summary>
    
      <category term="c++" scheme="ctguljj.github.io/categories/c/"/>
    
      <category term="常用函数" scheme="ctguljj.github.io/categories/c/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="c++" scheme="ctguljj.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>算法核心思想：倍增</title>
    <link href="ctguljj.github.io/2019/03/03/%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E5%80%8D%E5%A2%9E/"/>
    <id>ctguljj.github.io/2019/03/03/算法核心思想：倍增/</id>
    <published>2019-03-03T09:23:16.000Z</published>
    <updated>2019-03-03T09:23:16.382Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据类型问题</title>
    <link href="ctguljj.github.io/2019/03/03/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98/"/>
    <id>ctguljj.github.io/2019/03/03/数据类型问题/</id>
    <published>2019-03-03T09:11:09.000Z</published>
    <updated>2019-03-05T09:08:48.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><ul><li>二进制不能表示所有的小数，他只是选一个离需表示值的最近的一个数进行储存而已。</li><li>输出有e时,可能是输出变量类型float,double的问题，可改为int其它类型试试</li><li>int类型不会出现浮点数,不要用int型存计算结果的浮点数</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;二进制不能表示所有的小数，他只是选一个离需表示值的最近的一个数进行储存而已。&lt;/li&gt;
&lt;li&gt;输出有e时,可能是输出变量类型f
      
    
    </summary>
    
      <category term="数据类型" scheme="ctguljj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="数据类型" scheme="ctguljj.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>blog写作4</title>
    <link href="ctguljj.github.io/2019/03/01/blog%E5%86%99%E4%BD%9C4/"/>
    <id>ctguljj.github.io/2019/03/01/blog写作4/</id>
    <published>2019-03-01T11:09:27.000Z</published>
    <updated>2019-03-06T10:31:25.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h1><ul><li>将markdown需要用的图片放到git仓库中，发布到github上</li><li><span id="inline-blue">  访问图片,点 download 按钮，页面打开后,在地址栏可以复制图片地址，或者在Download按钮上直接右键 “复制链接地址” </span></li></ul><h1 id="TOC数字块"><a href="#TOC数字块" class="headerlink" title="TOC数字块"></a>TOC数字块</h1><p><span id="inline-toc">1.</span> 左边为效果<br><span id="inline-toc">2.</span> 左边为效果</p><h1 id="引用边框变色"><a href="#引用边框变色" class="headerlink" title="引用边框变色"></a>引用边框变色</h1><p>👇</p><ul><li><blockquote><p id="div-border-left-red">blog写作。 </p></blockquote></li><li><blockquote><p id="div-border-left-yellow">blog写作。 </p></blockquote></li><li><blockquote><p id="div-border-left-blue">blog写作。 </p></blockquote></li><li><blockquote><p id="div-border-right-blue">blog写作。 </p></blockquote></li><li><blockquote><p id="div-border-right-green">blog写作。 </p></blockquote></li><li><blockquote><p id="div-border-bottom-blue">blog写作。 </p></blockquote></li><li><blockquote><p id="div-border-bottom-yellow">blog写作。 </p></blockquote></li><li><blockquote><p id="div-border-left-purple">且不问结果如何，尽自己之所能，积极的面对。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图片插入&quot;&gt;&lt;a href=&quot;#图片插入&quot; class=&quot;headerlink&quot; title=&quot;图片插入&quot;&gt;&lt;/a&gt;图片插入&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;将markdown需要用的图片放到git仓库中，发布到github上&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;in
      
    
    </summary>
    
      <category term="blog" scheme="ctguljj.github.io/categories/blog/"/>
    
      <category term="markdown" scheme="ctguljj.github.io/categories/blog/markdown/"/>
    
    
      <category term="blog" scheme="ctguljj.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>blog写作3</title>
    <link href="ctguljj.github.io/2019/03/01/blog%E5%86%99%E4%BD%9C3/"/>
    <id>ctguljj.github.io/2019/03/01/blog写作3/</id>
    <published>2019-03-01T10:23:46.000Z</published>
    <updated>2019-03-02T04:28:06.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h1><ul><li>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：<br>\   反斜线<br>`   反引号<br>*   星号<br>_   底线<br>{}  花括号<br>[]  方括号<br>()  括弧<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   惊叹号</li></ul><h1 id="文字增加背景色块"><a href="#文字增加背景色块" class="headerlink" title="文字增加背景色块"></a>文字增加背景色块</h1><ul><li>在你需要编辑的文章地方。放置如下代码：<br><span id="inline-blue"> 站点配置文件 </span><br><span id="inline-purple"> 主题配置文件 </span><br><span id="inline-yellow"> 站点配置文件 </span><br><span id="inline-green"> 主题配置文件 </span></li></ul><h1 id="主题自带样式"><a href="#主题自带样式" class="headerlink" title="主题自带样式"></a>主题自带样式</h1><h2 id="FontAwesome"><a href="#FontAwesome" class="headerlink" title="FontAwesome"></a>FontAwesome</h2><p><strong>(以下图标必须在网页上方点击全部显示才能显示即受保护的内容)</strong></p><ul><li><i class="fa fa-camera-retro fa-lg"></i> fa-lg<br> <i class="fa fa-camera-retro fa-2x"></i> fa-2x<br> <i class="fa fa-camera-retro fa-3x"></i> fa-3x<br><i class="fa fa-camera-retro fa-4x"></i> fa-4x<br><i class="fa fa-camera-retro fa-5x"></i> fa-5x</li><li><i class="fa fa-spinner fa-spin"></i><br><i class="fa fa-circle-o-notch faspin"><i><br><i class="fa fa-refresh fa-spin"></i><br><i class="fa fa-cog fa-spin"></i><br> <i class="fa fa-spinner fa-pulse"></i></i></i></li></ul><h2 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h2><ul><li>在主题配置文件_config.yml里有一个关于这个的配置,需要提前设置.</li><li><div class="note default"><p>default</p></div></li><li><div class="note primary"><p>primary</p></div></li><li><div class="note success"><p>success</p></div></li><li><div class="note info"><p>info</p></div></li><li><div class="note warning"><p>warning</p></div></li><li><div class="note danger"><p>danger</p></div></li><li><div class="note danger no-icon"><p>danger no-icon</p></div></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反斜杠&quot;&gt;&lt;a href=&quot;#反斜杠&quot; class=&quot;headerlink&quot; title=&quot;反斜杠&quot;&gt;&lt;/a&gt;反斜杠&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效
      
    
    </summary>
    
      <category term="blog" scheme="ctguljj.github.io/categories/blog/"/>
    
    
      <category term="blog" scheme="ctguljj.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>崴脚恢复</title>
    <link href="ctguljj.github.io/2019/03/01/%E5%B4%B4%E8%84%9A%E6%81%A2%E5%A4%8D/"/>
    <id>ctguljj.github.io/2019/03/01/崴脚恢复/</id>
    <published>2019-03-01T08:36:28.000Z</published>
    <updated>2019-03-02T04:33:47.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="崴脚恢复"><a href="#崴脚恢复" class="headerlink" title="崴脚恢复"></a>崴脚恢复</h1><ul><li>脚踝的灵活性、稳定性、力量都难以通过养伤养好，你还需要进行康复训练。被动休息治疗结合<strong>主动康复训练</strong>才能最大程度恢复受损的功能。</li><li>脚踝康复应当按照恢复活动度—恢复力量—恢复平衡能力—恢复爆发力的顺序进行</li><li><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/ctgu1.jpg" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;崴脚恢复&quot;&gt;&lt;a href=&quot;#崴脚恢复&quot; class=&quot;headerlink&quot; title=&quot;崴脚恢复&quot;&gt;&lt;/a&gt;崴脚恢复&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;脚踝的灵活性、稳定性、力量都难以通过养伤养好，你还需要进行康复训练。被动休息治疗结合&lt;strong&gt;主动康复训练
      
    
    </summary>
    
      <category term="身体健康" scheme="ctguljj.github.io/categories/%E8%BA%AB%E4%BD%93%E5%81%A5%E5%BA%B7/"/>
    
      <category term="崴脚" scheme="ctguljj.github.io/categories/%E8%BA%AB%E4%BD%93%E5%81%A5%E5%BA%B7/%E5%B4%B4%E8%84%9A/"/>
    
    
      <category term="身体健康" scheme="ctguljj.github.io/tags/%E8%BA%AB%E4%BD%93%E5%81%A5%E5%BA%B7/"/>
    
  </entry>
  
  <entry>
    <title>blog写作2</title>
    <link href="ctguljj.github.io/2019/03/01/blog%E5%86%99%E4%BD%9C2/"/>
    <id>ctguljj.github.io/2019/03/01/blog写作2/</id>
    <published>2019-03-01T04:17:39.000Z</published>
    <updated>2019-03-04T16:01:50.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h1><ul><li>description是文章的描述,在每篇文章标题下方显示</li><li>有date,tags,categories,comments,password(要配置),keywords,updated</li><li>layout页面布局，默认为post,有draft(草稿)和page</li><li>符号 : 为英文符号,格式很重要,不管是主题配置文件还是站点配置文件中空格,不空格都有要求</li><li>permalink若站点配置文件下的 permalink 配置了 title 则可以替换文章 URL 里面的 title（文章标题）</li><li>还有photos,link,image,sticky(后面2个要配置)</li><li>若创建文章时标题错误,可在编辑md文件时通过titile修改,文件重命名没用</li><li>格式一定要正确,有时可能没识别出来,要重新输入</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Front-matter&quot;&gt;&lt;a href=&quot;#Front-matter&quot; class=&quot;headerlink&quot; title=&quot;Front-matter&quot;&gt;&lt;/a&gt;Front-matter&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;description是文章的描述,在每篇文章标
      
    
    </summary>
    
      <category term="blog" scheme="ctguljj.github.io/categories/blog/"/>
    
      <category term="文章模板" scheme="ctguljj.github.io/categories/blog/%E6%96%87%E7%AB%A0%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="blog" scheme="ctguljj.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>blog写作</title>
    <link href="ctguljj.github.io/2019/02/28/blog%E5%86%99%E4%BD%9C/"/>
    <id>ctguljj.github.io/2019/02/28/blog写作/</id>
    <published>2019-02-28T06:58:00.000Z</published>
    <updated>2019-03-02T04:34:20.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo博客写作"><a href="#hexo博客写作" class="headerlink" title="hexo博客写作"></a>hexo博客写作</h1><ul><li>若layout为draft,那么静态页面不会渲染生成。</li><li>符号-、1.和文本之间要保留一个字符的空格.</li><li><h1 id="和「一级标题」之间建议保留一个字符的空格，这是最标准的-Markdown-写法。如果不空格-标题无法显示。"><a href="#和「一级标题」之间建议保留一个字符的空格，这是最标准的-Markdown-写法。如果不空格-标题无法显示。" class="headerlink" title="和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。如果不空格,标题无法显示。"></a>和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。如果不空格,标题无法显示。</h1></li><li>引用符号&gt; 和文本之间要保留一个字符的空格<blockquote><p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p></blockquote></li></ul><ul><li><p>Markdown 的粗体和斜体也非常简单，用两个 <em> 包含一段文本就是粗体的语法，用一个 </em> 包含一段文本就是斜体的语法。例如：<br><em>一盏灯</em>， 一片昏黄；<strong>一简书</strong>， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p></li><li><p>Markdwon 文档写完一段回车后务必<strong>再回车一次空一行！</strong></p></li><li>需要引用代码时，如果引用的语句只有一段，不分行，可以用符号` 将语句包起来。</li><li>如果引用的语句为多行，可以将<code>`</code>置于这段代码的首行和末行，</li></ul><h1 id="markdown快速键入"><a href="#markdown快速键入" class="headerlink" title="markdown快速键入"></a>markdown快速键入</h1><blockquote></blockquote><p>mdi + tab键：插入图片<br>mdl + tab键: 插入链接<br>mdc + tab键：插入代码<br>mdh1 + tab键：插入一级标题，2就是二级标题……</p>]]></content>
    
    <summary type="html">
    
      关于博客写作即markdown语法相关知识
    
    </summary>
    
      <category term="blog" scheme="ctguljj.github.io/categories/blog/"/>
    
      <category term="markdown" scheme="ctguljj.github.io/categories/blog/markdown/"/>
    
    
      <category term="blog" scheme="ctguljj.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>颈椎养护手册</title>
    <link href="ctguljj.github.io/2019/02/28/%E9%A2%88%E6%A4%8E%E5%85%BB%E6%8A%A4%E6%89%8B%E5%86%8C/"/>
    <id>ctguljj.github.io/2019/02/28/颈椎养护手册/</id>
    <published>2019-02-28T05:21:06.000Z</published>
    <updated>2019-03-02T04:34:44.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日常不良习惯"><a href="#日常不良习惯" class="headerlink" title="日常不良习惯"></a>日常不良习惯</h1><ul><li>当你的距离不能够清楚的看清屏幕是你就会头向前伸，此时颈椎压力变大；而当你的距离不能够把胳膊自然下垂放在桌上或者椅子上的时候，手肘就会悬空，此时肩膀压力变大去承担手臂的重量！</li><li>使用过高或者过低的枕头，而和高枕头一样不好的就是不睡枕头，让脖子悬空。这两种情况都会让颈部肌肉紧张，无法放松，还会导致颈椎排列结构的改变</li></ul><h1 id="养护"><a href="#养护" class="headerlink" title="养护"></a>养护</h1><p>1.习惯侧睡的可以选择高一点的枕头，喜欢平躺仰卧的可以选择低一点，睡觉建议选择记忆棉枕头。不要窝着睡觉！！！脖子底下一定要有枕头！！！侧睡的枕头大概1.5倍拳头的高，仰睡的枕头大概一个拳头那么高！！！</p><p>2.睡前如果身体僵硬难受，千万别直接入睡，一定要冲个热水澡或者扭动身体让身体放松，否则第二天早上起来容易落枕或者有其他疼痛。 </p><p>3.必须要严格制定运动计划，并且保持至少一个小时就起来溜达溜达，伸腰踢腿.</p><p>4.我们眼睛看的屏幕一定要跟眼睛在同一水平线上，同时远近合适，这样可以避免低头和往前探后。</p><p>5.拉伸组合：上、右转、右上、右下、右歪、左歪、左下、左上、左、回正，记住，速度要慢，每次停留至少10秒</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日常不良习惯&quot;&gt;&lt;a href=&quot;#日常不良习惯&quot; class=&quot;headerlink&quot; title=&quot;日常不良习惯&quot;&gt;&lt;/a&gt;日常不良习惯&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;当你的距离不能够清楚的看清屏幕是你就会头向前伸，此时颈椎压力变大；而当你的距离不能够把胳膊自然下
      
    
    </summary>
    
      <category term="身体健康" scheme="ctguljj.github.io/categories/%E8%BA%AB%E4%BD%93%E5%81%A5%E5%BA%B7/"/>
    
      <category term="颈椎" scheme="ctguljj.github.io/categories/%E8%BA%AB%E4%BD%93%E5%81%A5%E5%BA%B7/%E9%A2%88%E6%A4%8E/"/>
    
    
      <category term="身体健康" scheme="ctguljj.github.io/tags/%E8%BA%AB%E4%BD%93%E5%81%A5%E5%BA%B7/"/>
    
  </entry>
  
</feed>
