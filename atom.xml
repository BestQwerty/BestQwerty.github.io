<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LjJiaJun&#39; Home</title>
  
  <subtitle>书青春 - 话人生 | Coding - Thinking - Acting</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="ctguljj.github.io/"/>
  <updated>2019-03-30T12:12:31.069Z</updated>
  <id>ctguljj.github.io/</id>
  
  <author>
    <name>LjJiaJun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第五周周总结</title>
    <link href="ctguljj.github.io/2019/03/30/%E7%AC%AC%E4%BA%94%E5%91%A8%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <id>ctguljj.github.io/2019/03/30/第五周周总结/</id>
    <published>2019-03-30T11:58:26.000Z</published>
    <updated>2019-03-30T12:12:31.069Z</updated>
    
    <summary type="html">
    
      something about myself
    
    </summary>
    
      <category term="五日三省吾身" scheme="ctguljj.github.io/categories/%E4%BA%94%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
      <category term="周总结" scheme="ctguljj.github.io/categories/%E4%BA%94%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="吾日三省吾身" scheme="ctguljj.github.io/tags/%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>matlab代码练习</title>
    <link href="ctguljj.github.io/2019/03/30/matlab%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/"/>
    <id>ctguljj.github.io/2019/03/30/matlab代码练习/</id>
    <published>2019-03-30T07:22:54.000Z</published>
    <updated>2019-03-30T08:23:04.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="S"><a href="#S" class="headerlink" title="S"></a>S</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;S&quot;&gt;&lt;a href=&quot;#S&quot; class=&quot;headerlink&quot; title=&quot;S&quot;&gt;&lt;/a&gt;S&lt;/h1&gt;
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="代码练习" scheme="ctguljj.github.io/categories/matlab/%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>数据结构栈</title>
    <link href="ctguljj.github.io/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88/"/>
    <id>ctguljj.github.io/2019/03/30/数据结构栈/</id>
    <published>2019-03-30T06:29:43.000Z</published>
    <updated>2019-03-30T06:29:43.375Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c++stackk</title>
    <link href="ctguljj.github.io/2019/03/30/c-stackk/"/>
    <id>ctguljj.github.io/2019/03/30/c-stackk/</id>
    <published>2019-03-30T06:28:36.000Z</published>
    <updated>2019-03-30T06:34:27.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li>出栈，如例：<code>s.pop();</code>注意，出栈操作只是删除栈顶元素，并不返回该元素</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;出栈，如例：&lt;code&gt;s.pop();&lt;/code&gt;注意，出栈操作只是删除栈顶元素，并不返回该元素&lt;/li&gt;

      
    
    </summary>
    
      <category term="stl" scheme="ctguljj.github.io/categories/stl/"/>
    
      <category term="stack" scheme="ctguljj.github.io/categories/stl/stack/"/>
    
    
      <category term="stl" scheme="ctguljj.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>matlab绘图</title>
    <link href="ctguljj.github.io/2019/03/28/matlab%E7%BB%98%E5%9B%BE/"/>
    <id>ctguljj.github.io/2019/03/28/matlab绘图/</id>
    <published>2019-03-28T06:00:45.000Z</published>
    <updated>2019-03-30T08:10:50.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绘图基础"><a href="#绘图基础" class="headerlink" title="绘图基础"></a>绘图基础</h1><ul><li>可以直接在图形窗口上修改图形</li><li>如果当前不存在图形窗口，MATLAB 的绘图函数会自动 建立一个新的图形窗口；如果已存在一个图形窗口，MATLAB 的绘图函数就会在这个窗口 中进行绘图操作；如果已存在多个图形窗口，MATLAB 的绘图函数就会在当前窗口中进行 绘图操作(当前窗口通常是指后一个使用的图形窗口)。</li><li>matlab绘图是将<strong>图形每一个点标出后连接而成</strong>，因为横坐标间隔值不一定相同，所以2个图形相交y值不一定相等，<strong>找交点</strong><code>s=find(abs(y1-y2)&lt;0.01))</code>其中0.01设置具体看横坐标间隔值大小，否侧可能找不到<ul><li>plot函数维度必须相同，因为图形是将点连接起来，所以x与y个数维度必须相同</li><li>plot函数可以标点！画点(因为画图是画点再连接起来)</li></ul></li><li>注意：<ul><li>如果已经存在一个图形窗口，plot命令则清除当前图形，绘制新图形</li><li>可任意设定曲线颜色和线型</li><li>可给图形加坐标网线和图形加注功能</li></ul></li></ul><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><ul><li><p><span id="inline-toc">1.</span>hold on: hold on retains plots in the current axes so that new plots added to the axes do not delete existing plots. New plots use the next colors and line styles based on the ColorOrder and LineStyleOrder properties of the axes. MATLAB® adjusts axes limits, tick marks, and tick labels to display the full range of data.</p><ul><li>hold on保留当前坐标轴中的绘图，这样添加到坐标轴中的新绘图就不会删除现有的绘图。新绘图使用基于坐标轴的ColorOrder和LineStyleOrder属性的下一种颜色和线条样式。MATLAB®调整坐标轴限制、刻度标记和刻度标签，以显示全部数据范围。</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">x = linspace(-pi,pi);</span><br><span class="line">y1 = sin(x);</span><br><span class="line">y2 = cos(x);</span><br><span class="line"></span><br><span class="line">plot(x,y1)</span><br><span class="line">hold on</span><br><span class="line">plot(x,y2)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><span id="inline-toc">2.</span><code>close all;</code>关闭所有图形窗口</p></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>-将标题、坐标轴标记、网格线及文字注<br>释加注到图形上，这些函数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">title —— 给图形加标题</span><br><span class="line">xlable —— 给x轴加标注</span><br><span class="line">ylable —— 给y轴加标注</span><br><span class="line">text —— 在图形指定位置加标注</span><br><span class="line">gtext —— 将标注加到图形任意位置</span><br><span class="line">grid on(off) —— 打开、关闭坐标网格线</span><br><span class="line">legend —— 添加图例</span><br><span class="line">axis —— 控制坐标轴的刻度</span><br></pre></td></tr></table></figure></p><ul><li><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clc;clear;</span><br><span class="line">t=0:0.1:10;</span><br><span class="line">y1=sin(t);</span><br><span class="line">y2=cos(t);</span><br><span class="line">plot(t,y1,&apos;r&apos;,t,y2,&apos;b--&apos;);</span><br><span class="line">x=[1.7*pi;1.6*pi];</span><br><span class="line">y=[-0.3;0.8];</span><br><span class="line">s=[&apos;sin(t)&apos;;&apos;cos(t)&apos;];</span><br><span class="line">text(x,y,s);</span><br><span class="line">title(&apos;正弦和余弦曲线&apos;);</span><br><span class="line">legend(&apos;正弦&apos;,&apos;余弦&apos;)</span><br><span class="line">xlabel(&apos;时间t&apos;)</span><br><span class="line">ylabel(&apos;正弦、余弦&apos;)</span><br><span class="line">grid</span><br><span class="line">axis square</span><br></pre></td></tr></table></figure></code></pre></li><li><p><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/plot绘图.png" alt=""></p></li></ul><h1 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a>find函数</h1><h1 id="plot函数"><a href="#plot函数" class="headerlink" title="plot函数"></a>plot函数</h1><ul><li>若用一个plot函数画多个图时，横坐标维度必须一致</li><li><code>plot(x,y,’s’)</code> —— 开关格式，开关量字符串s设定曲线颜色和绘图方式，如:   <code>plot(x1,y1,’y*’,x2,y2,’rO’，…)</code><ul><li>S的标准设定值如下：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">字母        颜色          标点           线型</span><br><span class="line">    y            黄色             ·              点线</span><br><span class="line">    m           粉红            ○             圈线</span><br><span class="line">    c            亮蓝            ×             ×线</span><br><span class="line">    r             大红           ＋             ＋字线  </span><br><span class="line">    g            绿色           －              实线</span><br><span class="line">    b            蓝色           *               星形线</span><br><span class="line">    w           白色            ：             虚线</span><br><span class="line">    k            黑色         －·  (--)        点划线</span><br><span class="line"></span><br><span class="line">    v                 下三角</span><br><span class="line">        ^                  上三角</span><br><span class="line">        &lt;                  左三角</span><br><span class="line">      &gt;                  右三角</span><br><span class="line">       square           正方形</span><br><span class="line">       diamond        菱形</span><br><span class="line">       pentagram     五角星</span><br><span class="line">       hexagram      六角星</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">t=0:pi/100:2*pi;</span><br><span class="line">y=sin(t);</span><br><span class="line">y1=sin(t+0.25);</span><br><span class="line">y2=sin(t+0.5);</span><br><span class="line">y3=cos(t);</span><br><span class="line">y4=cos(t+0.25);</span><br><span class="line">y5=cos(t+0.5);</span><br><span class="line">plot(t,[y&apos;,y1&apos;,y2&apos;,y3&apos;,y4&apos;,y5&apos;])</span><br></pre></td></tr></table></figure><h1 id="多窗口绘图"><a href="#多窗口绘图" class="headerlink" title="多窗口绘图"></a>多窗口绘图</h1><ul><li>figure(n) —— 创建窗口函数，n为窗口顺序号。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">t=0:pi/100:2*pi;</span><br><span class="line">y=sin(t);y1=sin(t+0.25);y2=sin(t+0.5);</span><br><span class="line">plot(t,y) —— 自动出现第一个窗口</span><br><span class="line">figure(2)</span><br><span class="line">plot(t,y1) —— 在第二窗口绘图</span><br><span class="line">figure(3)</span><br><span class="line">plot(t,y2) ——在第三窗口绘图</span><br></pre></td></tr></table></figure><h1 id="符号函数-显函数、隐函数和参数方程-画图"><a href="#符号函数-显函数、隐函数和参数方程-画图" class="headerlink" title="符号函数(显函数、隐函数和参数方程)画图"></a>符号函数(显函数、隐函数和参数方程)画图</h1><ul><li><p>ezplot</p><ul><li>ezplot(‘f(x)’,[a,b]) </li><li>表示在a&lt;x&lt;b绘制显函数f=f(x)的函数图。</li><li><code>ezplot(&#39;f(x,y)&#39;,[xmin,xmax,ymin,ymax])</code></li><li>表示在区间xmin&lt;x&lt;xmax和 ymin&lt;y&lt;ymax绘制隐函数f(x,y)=0的函数图。</li><li><code>ezplot(&#39; x(t) &#39;, &#39; y(t) &#39;,[tmin,tmax])</code></li><li>表示在区间tmin&lt;t&lt;tmax 绘制参数方程x=x(t),y=y(t)的函数图。</li></ul></li><li><p>ezplot函数：ezplot函数可以绘制符号函数的简易二维图形，其使用格式如下：</p><ul><li>1）ezplot(f)命令，对于显式函数f=f(x)，在默认的范围[-pi,pi]上绘制该函数f=f(x)的图形；对于隐函数f(x,y)=0，在默认的平面区域<code>[-2*pi&lt;x&lt;2*pi, -2*pi&lt;y&lt;2*pi]</code>上绘制该函数f(x,y)=0的图形。</li><li>2） <code>ezplot(x,y)</code>命令，在默认的范围[0&lt;t&lt;2*pi]内绘制参数形式函数x=x(t)与y=y(t)的图形。</li><li>3）<code>ezplot(f,[a,b])</code>命令，在指定的范围<code>[a&lt;x&lt;b,a&lt;y&lt;b]</code>内绘制表达式为f=f(x)的显式函数图形。</li><li>4）<code>ezplot(f,[xmin,xmax,ymin,ymax])</code>命令，在平面矩形区域<code>[xmin&lt;x&lt;xmax,ymin&lt;y&lt;ymax]</code>上绘制隐函数f(x,y)=0的图形。</li><li>5）<code>ezplot(x,y,[tmin,tmax])</code>命令，在指定的范围[tmin&lt;t&lt;tmax]内绘制参数形式的函数x=x(t)与y=y(t)的图形。 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;绘图基础&quot;&gt;&lt;a href=&quot;#绘图基础&quot; class=&quot;headerlink&quot; title=&quot;绘图基础&quot;&gt;&lt;/a&gt;绘图基础&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;可以直接在图形窗口上修改图形&lt;/li&gt;
&lt;li&gt;如果当前不存在图形窗口，MATLAB 的绘图函数会自动 建立一个
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="绘图" scheme="ctguljj.github.io/categories/matlab/%E7%BB%98%E5%9B%BE/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab字符串</title>
    <link href="ctguljj.github.io/2019/03/27/matlab%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>ctguljj.github.io/2019/03/27/matlab字符串/</id>
    <published>2019-03-27T14:20:01.000Z</published>
    <updated>2019-03-27T14:27:38.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul><li>字符串是用单引号括起来的字符集合，可以像向量一样进行拼接和裁剪。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Eg：&gt;&gt;s1=&apos;Hello&apos;;s2=&apos;every&apos;;s3=&apos;body&apos;;</span><br><span class="line">                s=[s1,&apos; &apos;,s2,&apos; &apos;,s3]</span><br><span class="line">                ss=s(1:5)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;字符串是用单引号括起来的字符集合，可以像向量一样进行拼接和裁剪。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="字符串" scheme="ctguljj.github.io/categories/matlab/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab矩阵以及常用函数</title>
    <link href="ctguljj.github.io/2019/03/27/matlab%E7%9F%A9%E9%98%B5%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>ctguljj.github.io/2019/03/27/matlab矩阵以及常用函数/</id>
    <published>2019-03-27T14:13:00.000Z</published>
    <updated>2019-03-30T06:51:12.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><ul><li>矩阵里面元素可以是符号与字符（‘a’,’,’）,输入的元素维度要一样<ul><li>矩阵里面的元素也可以是矩阵，但是矩阵长度维度必须与其它元素相同</li></ul></li></ul><pre><code>- 生成10*10的矩阵可以如下：`a = [1:10;11:20;21:....];`- 对矩阵a第一行后面2个赋予其他值(灵活运用：)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = [1 2 3</span><br><span class="line">4 7 8</span><br><span class="line">1 2 5];</span><br><span class="line"> </span><br><span class="line">a(1,2:3) = x;</span><br></pre></td></tr></table></figure>- 对一个矩阵A赋值提取可以取出然后赋给一个小矩阵a</code></pre><ul><li>矩阵的下标也可以是向量。<ul><li>例如 <code>b=a(x,y)；</code>可以得到一个矩阵 b。a 的行标来自向量 x，而列标来自向量 y。 例如，矩阵 a 有 n 列，那末 <code>b=a(:,n:-1:1)</code> 将得到矩阵 b，它等于矩阵 a 按列的逆序排列。 </li></ul></li><li><p><code>a(end:-1:end-5, 3)</code>是最后一行到倒数第6行的所有第三个元素</p></li><li><p>删除矩阵某行某列<code>a(i,j)=[];</code></p></li></ul><ul><li>如果要将一个矩阵存储在计算机中，MATLAB 规定矩阵元素在存储器中的存放次序是 按列的先后顺序存放，即存完第 1 列后，再存第 2 列，依次类推<ul><li>作为矩阵的特例，一维数组或者说向量元素是依其元素本身的先后次序进行存储的。 </li><li>必须指出，不是所有高级语言都这样规定矩阵(或数组)元素的存储次序，例如 C 语言 就是按行的先后顺序来存放数组元素，即存完第 1 行后，再存第 2 行，依次类推。记住这 一点对正确使用高级语言的接口技术是十分有益的。 </li></ul></li></ul><ul><li>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">a=[2 5 6 9 8 86 4 5 6 65 3 54];</span><br><span class="line">m=a(1);</span><br><span class="line">for i=1:12</span><br><span class="line">    if a(i)&gt;m</span><br><span class="line">        m=a(i);</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=[1,2,3,4,5,6,7];</span><br><span class="line">for i=1:7</span><br><span class="line">a(i)=a(i)+1;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clc,clear</span><br><span class="line">A=[0.5,1.732,0.618,3.1415,1.6,0.9];</span><br><span class="line">for i=1:6</span><br><span class="line">       for j=i:6</span><br><span class="line">             if a(j)&lt;a(i)</span><br><span class="line">                 a(i)=a(i)+a(j);</span><br><span class="line">                 a(j)=a(i)-a(j);</span><br><span class="line">                 a(i)=a(i)-a(j);</span><br><span class="line">              end</span><br><span class="line">        end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clc,clear</span><br><span class="line">for i=1:15</span><br><span class="line">       for j=1:15</span><br><span class="line">             if i+j==15&amp;&amp;4*i+2*j==40</span><br><span class="line">fprintf(‘兔%d只,鸡%d只\n’,i,j);</span><br><span class="line">             end</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><h1 id="矩阵除法"><a href="#矩阵除法" class="headerlink" title="矩阵除法"></a>矩阵除法</h1><p><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/matlab矩阵除法.png" alt=""></p><h1 id="矩阵旋转"><a href="#矩阵旋转" class="headerlink" title="矩阵旋转"></a>矩阵旋转</h1><p><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/matlab矩阵旋转.png" alt=""></p><h1 id="reshape函数"><a href="#reshape函数" class="headerlink" title="reshape函数"></a>reshape函数</h1><p><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/reshape.png" alt="">    </p><h1 id="size函数"><a href="#size函数" class="headerlink" title="size函数"></a>size函数</h1><p><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/size.png" alt=""></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="diag"><a href="#diag" class="headerlink" title="diag"></a>diag</h2><ul><li><span id="inline-toc">1.</span> diag函数：<code>sum(diag(a)+diag(a&#39;))</code>可以求矩阵a对角线上的元素之和，不过中间的一个元素会提取2次，diag(a’)可以提取副对角线的元素(先将矩阵转置）<ul><li>当Random是向量时，才构成对角矩阵，当Random是m×n矩阵时，得到的是个向量。比如diag([1 3;2 4])得到向量，diag([1 3])得到2×2矩阵。</li><li>可以用来访问对角元素<h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2></li></ul></li><li><p>MAX 函数的几种形式</p><ul><li>(1)max(a)</li><li>(2)max(a,b)</li><li>(3)max(a,[],dim)</li><li>(4)[C,I]=max(a)</li><li>(5)[C,I]=max(a,[],dim)</li></ul></li><li><p>(1)max(a)<br>如果 a 是一个矩阵，比如 <code>a=[1,2,3;4,5,6]</code> ，max(a)的意思就是找出矩阵每列的最大值， 本例中：<code>max(a)=[4,5,6]</code> </p></li><li>(2)max(a,b)<br>如果 a 和 b 都是大于 1 维的矩阵，那么要求 a 和 b 的行列的维数都要相等，函数的结 果是比较 a 和 b 中每个元素的大小，比如：<br><code>a=[1,2,3;4,5,6] b=[4,5,6;7,8,3]</code><br><code>max(a,b)=[4,5,6;7,8,6]</code><br>另外，如果 a 和 b 中至少有一个是常数，也是可以的。比如：<br><code>a=[1,2,3;4,5,6] b=3 c=5</code>max(a,b)=[3,3,3;4,5,6]<code>相信大家看了例子都明白了函数的意思了吧</code>max(b,c)=5 `</li><li>(3)<code>max(a,[],dim)</code><br>这个函数的意思是针对于 2 维矩阵的，dim 是英文字母 dimension 的缩写，意思是维数。<br>当 dim=1 时，比较的 a 矩阵的列，也就是和 max（a）的效果是一样的；当 dim2 时，比较的 是 a 矩阵的行。下面举个例子：<br><code>a=[1,2,3;4,5,6] max(a)=max(a,[],1)=[4,5,6]</code> 比较的第一行和第二行的值<br>max(a,[],2)=[3,6] </li><li>(4)[C,I]=max(a)<br>C表示的是矩阵 a 每列的最大值， I 表示的是每个最大值对应的下标：<br>下面举例说明：<br>还是刚才那个例子：<code>a=[1,2,3;4,5,6] [C,I]=max(a)</code><br>结果显示的是 <code>C=[4,5,6] I=[2,2,2]</code> 返回的是最大值对应的行号。</li><li>(5)<code>[C,I]=max(a,[],dim)</code><br>同理：如果 dim=1 时，其结果和<code>[c,i]=max(a)</code> 是一样的。<br>当 dim=2 时，同样上面的矩阵 a，我们运行一下：<br><code>[c,i]=max(a,[],2)</code> 结果是：<code>c=[3,6] i=[3,3]</code> i 返回的是矩阵 a 的列号。</li></ul><h2 id="matlab中的sort函数"><a href="#matlab中的sort函数" class="headerlink" title="matlab中的sort函数"></a>matlab中的sort函数</h2><ul><li><code>sort(c)</code>从小到大</li><li><code>sort(c, &#39;descend&#39;)</code>逆序排列(从大到小).</li></ul><h2 id="MATLAB判断一个数是否整数"><a href="#MATLAB判断一个数是否整数" class="headerlink" title="MATLAB判断一个数是否整数"></a>MATLAB判断一个数是否整数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if x==fix(x)</span><br><span class="line">% x为整数</span><br><span class="line">%fix（x)为取整</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><h2 id="mod函数"><a href="#mod函数" class="headerlink" title="mod函数"></a>mod函数</h2><ul><li><code>b = mod(a,m)</code>返回a除以m后的余数，其中a是被除数，m是除数。这个函数通常称为模运算，使用<code>b = a - m.*floor(a /m)</code>计算。mod函数遵循<code>mod(a,0)</code>返回a</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;矩阵&quot;&gt;&lt;a href=&quot;#矩阵&quot; class=&quot;headerlink&quot; title=&quot;矩阵&quot;&gt;&lt;/a&gt;矩阵&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;矩阵里面元素可以是符号与字符（‘a’,’,’）,输入的元素维度要一样&lt;ul&gt;
&lt;li&gt;矩阵里面的元素也可以是矩阵，但是矩阵长度维
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="矩阵以及常用函数" scheme="ctguljj.github.io/categories/matlab/%E7%9F%A9%E9%98%B5%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab代码练习17</title>
    <link href="ctguljj.github.io/2019/03/27/matlab%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A017/"/>
    <id>ctguljj.github.io/2019/03/27/matlab代码练习17/</id>
    <published>2019-03-27T13:41:22.000Z</published>
    <updated>2019-03-27T13:41:22.508Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>matlab代码练习2018</title>
    <link href="ctguljj.github.io/2019/03/27/matlab%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A02018/"/>
    <id>ctguljj.github.io/2019/03/27/matlab代码练习2018/</id>
    <published>2019-03-27T13:41:01.000Z</published>
    <updated>2019-03-27T14:00:39.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h1><ul><li><p>编程将输入的一个n位整数按由小到大的顺序输出。如输入78945，则输出45789。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clc,clear;</span><br><span class="line">a = input(&apos;please input a number：&apos;);</span><br><span class="line">aa = num2str(a);</span><br><span class="line">b = length(aa);</span><br><span class="line">c = zeros(1,b);</span><br><span class="line">result = 0;</span><br><span class="line">for i=1:b</span><br><span class="line">    d = mod(a,10);</span><br><span class="line">    c(i) = d;</span><br><span class="line">    a = (a-mod(a,10))/10;</span><br><span class="line">end</span><br><span class="line">c = sort(c);</span><br><span class="line">for j=1:b</span><br><span class="line">    result = c(j) + result*10;</span><br><span class="line">end</span><br><span class="line">fprintf(&apos;The answer is :%d\n&apos;,result)</span><br></pre></td></tr></table></figure></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;A题&quot;&gt;&lt;a href=&quot;#A题&quot; class=&quot;headerlink&quot; title=&quot;A题&quot;&gt;&lt;/a&gt;A题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编程将输入的一个n位整数按由小到大的顺序输出。如输入78945，则输出45789。&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="代码练习" scheme="ctguljj.github.io/categories/matlab/%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>栈代码练习</title>
    <link href="ctguljj.github.io/2019/03/25/%E6%A0%88%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/"/>
    <id>ctguljj.github.io/2019/03/25/栈代码练习/</id>
    <published>2019-03-25T14:25:01.000Z</published>
    <updated>2019-03-25T14:25:01.161Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表c练习</title>
    <link href="ctguljj.github.io/2019/03/25/%E9%93%BE%E8%A1%A8c%E7%BB%83%E4%B9%A0/"/>
    <id>ctguljj.github.io/2019/03/25/链表c练习/</id>
    <published>2019-03-25T14:24:43.000Z</published>
    <updated>2019-03-25T14:24:43.234Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo特殊字符</title>
    <link href="ctguljj.github.io/2019/03/22/hexo%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
    <id>ctguljj.github.io/2019/03/22/hexo特殊字符/</id>
    <published>2019-03-22T13:20:37.000Z</published>
    <updated>2019-03-22T13:28:19.827Z</updated>
    
    <content type="html"><![CDATA[<ul><li>因为特殊字符，报了一下错误<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Template render error: (unknown path) [Line 5, Column 29]</span><br></pre></td></tr></table></figure></li></ul><p>从宇宙大爆发开始找错误，不过还好没浪费多少时间.记忆深刻，写个blog冷静一下</p><h1 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h1><ul><li>hexo特殊字符尽量减少使用，可能在转义时发生错误！如： 2个大括号连在一起！！！！！！！！！！！！！或者中括号！！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;因为特殊字符，报了一下错误&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="blog" scheme="ctguljj.github.io/categories/blog/"/>
    
      <category term="特殊字符" scheme="ctguljj.github.io/categories/blog/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
    
    
      <category term="blog" scheme="ctguljj.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="ctguljj.github.io/2019/03/22/%E6%95%B0%E7%BB%84/"/>
    <id>ctguljj.github.io/2019/03/22/数组/</id>
    <published>2019-03-22T12:10:44.000Z</published>
    <updated>2019-03-22T13:36:36.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><ul><li>二维数组的初始化分为两种，一种是顺序初始化，一种是按行初始化<ul><li>所谓按顺序初始化就是先从左向右再由上而下地初始化，即第一行所有元素都初始化好以后再对第二行初始化。而按行初始化则是用一对大括号来表示每一行，跳过前一行没有初始化的元素，在行内从左向右地进行初始化。</li><li><code>int array1[3][2]={4,2,5,6}; 顺序初始化</code></li><li><code>int array2[3][2]={ {4,2},{5},{6} }; 按行初始化</code></li><li>对于没有初始化的元素，则都是一个不确定的值。</li></ul></li><li>内存是依靠地址来确定内存中的唯一一个存储单元的，即只有一个参数。所以在内存中，所有的数据都是像一维数组那样顺序存储的。<ul><li>在内存中，先将二维数组的第一行按顺序存储，接着就是第二行的数据，然后是第三行的数据……右图（图7.4）所示的就是一个二维数组在内存中的存储情况。 <img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/数组.jpg" alt=""></li></ul></li><li>在某些情况下，不能使用二维数组，或者难以制造一个二维数组。二维数组在内存中的存储情况和一维数组是相同的，所以我们只好用一个一维数组来代替它了。一个二维数组元素<code>a[x][y]</code>在一维数组b中，是：<br> <code>a[x][y]=b[x*列数+y]</code><br><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/数组2.jpg" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二维数组&quot;&gt;&lt;a href=&quot;#二维数组&quot; class=&quot;headerlink&quot; title=&quot;二维数组&quot;&gt;&lt;/a&gt;二维数组&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;二维数组的初始化分为两种，一种是顺序初始化，一种是按行初始化&lt;ul&gt;
&lt;li&gt;所谓按顺序初始化就是先从左向右再由
      
    
    </summary>
    
      <category term="c++" scheme="ctguljj.github.io/categories/c/"/>
    
      <category term="基础知识" scheme="ctguljj.github.io/categories/c/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="数组" scheme="ctguljj.github.io/categories/c/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="c++" scheme="ctguljj.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>bfs的神奇</title>
    <link href="ctguljj.github.io/2019/03/20/bfs%E7%9A%84%E7%A5%9E%E5%A5%87/"/>
    <id>ctguljj.github.io/2019/03/20/bfs的神奇/</id>
    <published>2019-03-20T13:13:52.000Z</published>
    <updated>2019-03-20T13:13:52.710Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dfs的奥妙</title>
    <link href="ctguljj.github.io/2019/03/20/dfss%E7%9A%84%E5%A5%A5%E5%A6%99/"/>
    <id>ctguljj.github.io/2019/03/20/dfss的奥妙/</id>
    <published>2019-03-20T13:13:12.000Z</published>
    <updated>2019-03-22T13:05:07.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dfs模板"><a href="#dfs模板" class="headerlink" title="dfs模板"></a>dfs模板</h1><ul><li>DFS的重要点在于状态回溯</li><li><code>判出口（终点、越界）-&gt; 剪枝-&gt;扩展-&gt;标记-&gt;递归-&gt;还原</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span><span class="comment">//参数用来表示状态  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(到达终点状态)  </span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        ...<span class="comment">//根据题意添加  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(越界或者是不合法状态)  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(特殊状态)<span class="comment">//剪枝</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(扩展方式)  </span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(扩展方式所达到状态合法)  </span><br><span class="line"></span><br><span class="line">        &#123;  </span><br><span class="line"></span><br><span class="line">            修改操作;<span class="comment">//根据题意来添加  </span></span><br><span class="line"></span><br><span class="line">            标记； <span class="comment">//标记可以再开一个另外的数组进行标记 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            dfs（）；  </span><br><span class="line"></span><br><span class="line">            (还原标记)；  </span><br><span class="line"></span><br><span class="line">            <span class="comment">//是否还原标记根据题意  </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果加上（还原标记）就是 回溯法  </span></span><br><span class="line"></span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ul><li>如何获得下一个方向的坐标（此处定义一个方向数组）。</li></ul><pre><code>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next[<span class="number">4</span>][<span class="number">2</span>]=&#123;</span><br><span class="line"></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;<span class="comment">//向右走</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;<span class="comment">//向下走</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;<span class="comment">//向左走</span></span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;<span class="comment">//向上走 </span></span><br><span class="line"></span><br><span class="line">   &#125;;</span><br><span class="line">next[i][<span class="number">0</span>]; <span class="comment">//x方向</span></span><br><span class="line">next[i][<span class="number">1</span>]; <span class="comment">//y方向</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">dir[i][<span class="number">0</span>]; <span class="comment">//x方向</span></span><br><span class="line">dir[i][<span class="number">1</span>]; <span class="comment">//y方向</span></span><br></pre></td></tr></table></figure>- 通过这个方向数组，使用循环就可以方便地得到下一步的坐标。     <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">6</span>];<span class="comment">//地图；</span></span><br><span class="line"><span class="keyword">bool</span> temp[<span class="number">6</span>][<span class="number">6</span>];<span class="comment">//走过的标记；</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;<span class="comment">//打表；</span></span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//打表；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//定义walk；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fx&amp;&amp;y==fy)<span class="comment">//fx表示结束x坐标，fy表示结束y坐标；</span></span><br><span class="line">    &#123;</span><br><span class="line">        total++;<span class="comment">//总数增加；</span></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//返回，继续搜索；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)<span class="comment">//0——3是左，右，下，上四个方向；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[x+dx[i]][y+dy[i]]==<span class="number">0</span>&amp;&amp;<span class="built_in">map</span>[x+dx[i]][y+dy[i]]==<span class="number">1</span>)<span class="comment">//判断没有走过和没有障碍；</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp[x][y]=<span class="number">1</span>;<span class="comment">//走过的地方打上标记；</span></span><br><span class="line">                walk(x+dx[i],y+dy[i]);<span class="comment">//同i!!!!</span></span><br><span class="line">                temp[x][y]=<span class="number">0</span>;<span class="comment">//还原状态；</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 就在地图map数组上打标记（自己走过的路）比较简单，走过的路和障碍可能引起混淆</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dfs模板&quot;&gt;&lt;a href=&quot;#dfs模板&quot; class=&quot;headerlink&quot; title=&quot;dfs模板&quot;&gt;&lt;/a&gt;dfs模板&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;DFS的重要点在于状态回溯&lt;/li&gt;
&lt;li&gt;&lt;code&gt;判出口（终点、越界）-&amp;gt; 剪枝-&amp;gt;
      
    
    </summary>
    
      <category term="算法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dfs" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/dfs/"/>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>matlab基本操作</title>
    <link href="ctguljj.github.io/2019/03/17/matlab%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>ctguljj.github.io/2019/03/17/matlab基本操作/</id>
    <published>2019-03-17T11:26:31.000Z</published>
    <updated>2019-03-28T00:47:33.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="matlab语句"><a href="#matlab语句" class="headerlink" title="matlab语句"></a>matlab语句</h1><ul><li>MATLAB语句的一般形式为：变量 = 表达式<br>说明：<ul><li>1.若变量和“=”省略，则名为ans的变量自动建立；</li><li>2.如果你输入了一个语句并以回车结束，则在工作区中显示计算的结果；</li><li>3.如果语句以分号“；”结束，MATLAB只进行计算，不显示计算的结果；</li><li>4.如果一个变大时太长，可以用续行号 … 将其延续到下一行。此外，一行中可以写几个语句，他们之间要用逗号或分号分开。</li></ul></li></ul><h1 id="matlabz中变量"><a href="#matlabz中变量" class="headerlink" title="matlabz中变量"></a>matlabz中变量</h1><ul><li><div class="note primary"><p>对于变量，MATLAB不需要任何类型的说明或维数语句。当输入一个新变量名时MATLAB自动建立面变量并为其分配内存空间。</p></div></li><li><p>MATLAB有几个特殊的量</p><ul><li>1.Pi圆周率π</li><li>2.Eps最小浮点数</li><li>3.Inf正无穷大，特指1/0</li><li>4.NaN不定值，特指0/0</li><li>5.i，j虚数单位</li><li>6.自然对数</li></ul></li><li><p>MATLAB中变量的命名规则是：</p><ul><li>变量名必须是不含空格的单个词；</li><li>变量名区分大小写；</li><li>变量名最多不超过19个字符；</li><li>变量名必须以字母打头，之后可以是 任意字母、数字或下划线，变量名中，不允许使用标点符号. </li></ul></li><li>matalab中Π默认为3.1416（应该）</li><li>数据显示默认为四位，但只是matlab对数据的显示方式，其实不管显示的有效位数是多少，都不影响实际的计算结果，也不会有多大的累计误差。有效位数是4或8位，其计算结果的误差是一样的。<h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1></li><li><strong>分号 ; 表示分隔不想显示计算结果的各语句；矩阵行与行的分隔符</strong> </li><li>续行号 … 长命令行需分行时连接下行用 </li><li>逗号 ， 表示分隔欲显示计算结果的各语句；变量分隔符；矩阵一行中各元素间的分隔符 <h1 id="matlab输入"><a href="#matlab输入" class="headerlink" title="matlab输入"></a>matlab输入</h1></li><li>函数：<ul><li><code>a=input(‘please input a number：’);</code></li><li><code>b=input(‘请输入一个字符串:’,’s’);</code></li><li><code>c=input(‘请输入一个矩阵:’);</code></li></ul></li><li>赋值：<code>a=3;A=4;(变量赋予数值)</code><pre><code> `  a=A;(变量赋予变量)`  ` a=‘a’;(变量赋予字符串)``   a=zeros(m,n);a=ones(m,n);(变量赋予矩阵)`</code></pre></li></ul><h1 id="matlab输出"><a href="#matlab输出" class="headerlink" title="matlab输出"></a>matlab输出</h1><ul><li>不加分号：a=3 a=b a=‘a’ a=zeros(m,n)</li><li><p>函数1：<code>fprintf()</code></p><pre><code>` fprintf(fid,format,A)`</code></pre><ul><li>fid：输出的位置，如果缺省，则输出在命令窗口</li><li>format：输出内容的类型<br>（类型包括：%d:整数  %e:实数  %s:字符串  %f:浮点数）</li><li>A：输入内容的变量名 </li></ul></li><li><p>屏幕输出简单的方法是直接写出欲输出的变量或数组名，后面不加分号。此外，可 以采用 disp 语句，其调用格式为 disp(x)。 </p><ul><li>函数二：disp()<ul><li><code>disp(‘A’);</code></li><li><code>disp(‘numstr(12)’) ;</code>%%numstr()是将其他类型的变量转化成字符串的形式</li><li><code>disp(zeros(m,n));</code></li></ul></li></ul></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">clc,clear;</span><br><span class="line">result = 0;</span><br><span class="line">for i=3:2:101</span><br><span class="line">    result = result + i;</span><br><span class="line">end</span><br><span class="line">disp(result)</span><br></pre></td></tr></table></figure></code></pre><ul><li>MATLAB的每条命令后，若为逗号或无标点符号， 则显示命令的结果；若命令后为分号，则禁止显示结果. </li><li>“%”  后面所有文字为注释. </li><li>“…”表示续行.</li></ul><h1 id="mat文件"><a href="#mat文件" class="headerlink" title="mat文件"></a>mat文件</h1><ul><li>mat文件是matlab的数据存储的标准格式。mat文件是标准的二进制文件,还可以ASCII码形式保存和加载，在MATLAB中打开显示类似于单行EXCEL表格。</li><li>MATLAB是解释型语言，就是说MATLAB命令行中敲入的命令在当前MATLAB进程中被解释运行。但是，每次执行一个任务时敲入长长的命令序列是很烦人的。有两种方法可以使MATLAB的力量得到扩展——脚本和函数。这两种方法都用像emacs一样的文本编辑器中编写的m文件（因为扩展名是.m所以这样命名，m文件还称点m文件）。m文件的好处在于它可以保存命令，还可以轻易地修改命令而无需重新敲入整个命令行。</li><li>所谓mat文件，就是由matlab语言编写的可在matlab语言环境下运行的程序源代码文件。Matlab语言的m文件可分为命令式和函数式两种形式。M文件可在matlab程序编辑器里编写，也可在其他文本编辑器中编写，并以”.m”为拓展名保存。</li></ul><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul><li>for 循环允许一组命令以固定的和预定的次数重复。for 循环的一般形式是 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for 循环控制变量=表达式 1:表达式 2:表达式 3 </span><br><span class="line"> 语句             </span><br><span class="line"> end</span><br></pre></td></tr></table></figure><pre><code>- 表达式 1 的值为循环控制变量的初值；表达式 2 的值为步长，每执行循环体一次，循 环控制变量的值将增加步长大小。步长可以为负值，当步长为 1 时，表达式 2 可省略；表 达式 3 为循环控制变量的终值，当循环控制变量的值大于终值时循环结束。在 for 循环中， 循环体内不能出现对循环控制变量的重新设置，否则将会出错；for 循环允许嵌套使用。 </code></pre><ul><li><p>使用 for 循环语句值得注意的是 </p><ul><li><p>for循环不能用循环内重新给循环变量赋值来终止</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x=0;</span><br><span class="line">for n=1:4   </span><br><span class="line"> x =x+1</span><br><span class="line">n=5;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code> - for 循环的循环变量= [表达式 1:表达式 2:表达式 3]，其实为一行向量，例如： `[1:2:10]=[ 0  2  4  6  8  10]`，它还可以是数组，其更一般的形式为 `for 循环控制变量 = 数组表达式 语句 end `     - 【例 6.5】 用 for 循环求行向量[-2,5,3,6,-2]各元素之和。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">   a=[-2,5,3,6,-2]; </span><br><span class="line">s=0;</span><br><span class="line">k=0;</span><br><span class="line">for n=a </span><br><span class="line"> n   %显示每一次循环变量的值 </span><br><span class="line"> k=k+1;  %记录循环次数   </span><br><span class="line">  s=s+n;  %计算行向量 a 各元素之和 </span><br><span class="line">end </span><br><span class="line">k,s   %显示总的循环次数和计算结果</span><br><span class="line">运行结果为 </span><br><span class="line">n =     -2 </span><br><span class="line">n =      5</span><br><span class="line"> n =      3</span><br><span class="line"> n =      6 </span><br><span class="line">n =     -2</span><br><span class="line"> k =      5 </span><br><span class="line">s =     10 </span><br><span class="line">可以看出，总循环次数为 5，第 i 次循环时循环变量的值为 a(i)，计算结果为行向量 a 各元素之和。</span><br></pre></td></tr></table></figure>- 当有一个等效的数组方法来解给定的问题时，应避免用 for 循环。     - 【例 6.9】 比较下面两段程序的执行情况。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(a) for n=1:10</span><br><span class="line">  x(n)=sin(n*pi/10); </span><br><span class="line">  end   </span><br><span class="line">x </span><br><span class="line">(b) n=1:10; </span><br><span class="line">  x=sin(n*pi/10) </span><br><span class="line">两段程序的运行结果相同，均为 </span><br><span class="line">x = 0.3090  0.5878  0.8090  0.9511  1.0000  0.9511  0.8090  0.5878  0.3090  0.0000 </span><br><span class="line">但后者执行更快，更直观、简便。</span><br></pre></td></tr></table></figure><ul><li>为了得到更快的速度，在 for 循环(while 循环)被执行之前，应预先分配数组。如例 6.9(a)，在 for 循环内每执行一次命令，变量 x 的大小增加 1，迫使 MATLAB 每进行一次循 环都要花费时间对 x 分配更多的内存。为了省去这个步骤，可以在例 6.9(a)程序的首行加入：<code>x=zeros(1,10);    %为 x 分配内存单元</code></li></ul><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><ul><li>其一般形式为 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">                 while 关系表达式</span><br><span class="line">                       语句      </span><br><span class="line">              end </span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 注意：for 循环的循环变量为 m1× m 2×…× m n 维数组，循环次数在一开始就由数组确定为 m2×…× m n，所以在循环体内并不能通过改变循环控制变量的值终止循环；而 while 循环是先执行循环体内的语句，再判断循环的条件是否成立，在循环体内可以通过 改变循环控制变量的值终止循环。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 判断</span><br><span class="line">- try 语句 </span><br><span class="line">- try 语句是 MATLAB 特有的语句，其一般结构是</span><br></pre></td></tr></table></figure><pre><code>        try         语句 1          catch         语句 2          end<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- elseif与else if不同，前者嵌套if语句时不用end，后者要与else if</span><br><span class="line">对应的end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- if, elseif, else</span><br></pre></td></tr></table></figure>    if expression        statements    elseif expression        statements    else        statements    end</code></pre><p><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;matlab语句&quot;&gt;&lt;a href=&quot;#matlab语句&quot; class=&quot;headerlink&quot; title=&quot;matlab语句&quot;&gt;&lt;/a&gt;matlab语句&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MATLAB语句的一般形式为：变量 = 表达式&lt;br&gt;说明：&lt;ul&gt;
&lt;li&gt;1
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="基本操作" scheme="ctguljj.github.io/categories/matlab/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>快排及其优化</title>
    <link href="ctguljj.github.io/2019/03/15/%E5%BF%AB%E6%8E%92%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    <id>ctguljj.github.io/2019/03/15/快排及其优化/</id>
    <published>2019-03-15T15:15:01.000Z</published>
    <updated>2019-03-16T12:02:16.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><ul><li>写快排以 a[1] 为基准点太易被卡，可以用 a[(L+r)/2].</li><li>STL 的快排算法的实现其实加入了小数组时冒泡，可能慢的时候用堆排等等优化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快排&quot;&gt;&lt;a href=&quot;#快排&quot; class=&quot;headerlink&quot; title=&quot;快排&quot;&gt;&lt;/a&gt;快排&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;写快排以 a[1] 为基准点太易被卡，可以用 a[(L+r)/2].&lt;/li&gt;
&lt;li&gt;STL 的快排算法的实现其实加入了小数组
      
    
    </summary>
    
      <category term="算法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="快排及其优化" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/%E5%BF%AB%E6%8E%92%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>生成随机数</title>
    <link href="ctguljj.github.io/2019/03/15/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>ctguljj.github.io/2019/03/15/生成随机数/</id>
    <published>2019-03-15T14:37:50.000Z</published>
    <updated>2019-03-15T14:37:50.112Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数学秘密</title>
    <link href="ctguljj.github.io/2019/03/15/%E6%95%B0%E5%AD%A6%E7%A7%98%E5%AF%86/"/>
    <id>ctguljj.github.io/2019/03/15/数学秘密/</id>
    <published>2019-03-15T05:27:44.000Z</published>
    <updated>2019-03-15T08:57:20.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><ul><li>在解有关最大公约数、最小公倍数的问题时，常用到以下结论</li></ul><p>　　- （1）如果两个自然数是互质数，那么它们的最大公约数是1，最小公倍数是这两个数的乘积。<br>　　例如8和9，它们是互质数，所以（8，9）=1，[8，9]=72。<br>　　- （2）如果两个自然数中，较大数是较小数的倍数，那么较小数就是这两个数的最大公约数，较大数就是这两个数的最小公倍数。<br>　　例如18与3，18÷3=6，所以（18，3）=3，[18，3]=18。<br>　　- （3）两个整数分别除以它们的最大公约数，所得的商是互质数。<br>　　例如8和14分别除以它们的最大公约数2，所得的商分别为4和7，那么4和7是互质数。<br>　　- （4）两个自然数的最大公约数与它们的最小公倍数的乘积等于这两个数的乘积。<br>　　例如12和16，（12，16）=4，[12，16]=48，有4×48=12×16，即（12，16）× [12，16]=12×16。</p><pre><code>- （5）GCD(a,b) is the smallest positive linear combination of a and b. a与b的最大公约数是最小的a与b的正线性组合,即对于方程xa+yb=c来说,若x,a,y,b都为整数,那么c的最小正根为gcd(a,b).</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最大公约数&quot;&gt;&lt;a href=&quot;#最大公约数&quot; class=&quot;headerlink&quot; title=&quot;最大公约数&quot;&gt;&lt;/a&gt;最大公约数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在解有关最大公约数、最小公倍数的问题时，常用到以下结论&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　- （1）如果两
      
    
    </summary>
    
      <category term="数学基础知识" scheme="ctguljj.github.io/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="数学" scheme="ctguljj.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>最大公约数与最小公倍数</title>
    <link href="ctguljj.github.io/2019/03/14/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    <id>ctguljj.github.io/2019/03/14/最大公约数与最小公倍数/</id>
    <published>2019-03-14T10:01:44.000Z</published>
    <updated>2019-03-14T10:01:44.822Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
