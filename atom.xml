<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LjJiaJun&#39; Home</title>
  
  <subtitle>书青春 - 话人生 | Coding - Thinking - Acting</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="BestQwerty.github.io/"/>
  <updated>2019-06-12T13:38:45.793Z</updated>
  <id>BestQwerty.github.io/</id>
  
  <author>
    <name>LjJiaJun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构之图</title>
    <link href="BestQwerty.github.io/2019/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE/"/>
    <id>BestQwerty.github.io/2019/06/09/数据结构之图/</id>
    <published>2019-06-09T13:20:46.000Z</published>
    <updated>2019-06-12T13:38:45.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ul><li>图（Graph）通常表示为： G(V,E)。其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。<ul><li>在图中，不允许没有顶点。若 V 是图的顶点的集合，那么，V 是非空<br>有穷集合。</li><li>图的任意两个顶点之间都可能有关系，它们的关系用边来表示。边集可<br>以是空的。</li></ul></li><li>无向边用小括号 “（）”表示，有向边用尖括号“&lt;&gt;”表示。<br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%9C%89%E5%90%91%E5%9B%BE1.png" alt=""><br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/%E7%BD%91%E5%9B%BE1.png" alt=""><br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/%E7%BD%91%E5%9B%BE2.png" alt=""></li></ul><h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h1><ul><li><p>邻接矩阵存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 100;     <span class="comment">// 最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535;  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType vexs[MAXVEX];    <span class="comment">// 顶点表</span></span><br><span class="line">    EdgeType arc[MAXVEX][MAXVEX];   <span class="comment">// 邻接矩阵，可看作边表</span></span><br><span class="line">    <span class="keyword">int</span> numVertexes, numEdges;  <span class="comment">// 图中当前顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="string">"输入顶点数和边数:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d, %d"</span>, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);     <span class="comment">// 输入顶点数和边数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;G-&gt;vexs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G-&gt;numVertexes; j++)&#123;</span><br><span class="line">            G-&gt;arc[i][j] = INFINITY;    <span class="comment">// 邻接矩阵初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G-&gt;numEdges; k++)&#123;   <span class="comment">// 读入numEdges条边，建立邻接矩阵</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入边(vi,vj)上的下标i、下标j和权w:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d, %d, %d"</span>, &amp;i, &amp;j, &amp;w);    <span class="comment">// 输入边（vi,vj）上的权w</span></span><br><span class="line">        G-&gt;arc[i][j] = w;</span><br><span class="line">        G-&gt;arc[j][i] = G-&gt;arc[i][j];    <span class="comment">// 因为是无向图，矩阵对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>邻接表结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>     // 边表结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;     <span class="comment">// 邻接点域，存储该顶点对应的下标</span></span><br><span class="line">    EdgeType weight;    <span class="comment">// 权值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 链域，指向下一个连接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>   // 顶点表结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType data;    <span class="comment">// 顶点域，存储顶点信息</span></span><br><span class="line">    EdgeNode *firstEdge;    <span class="comment">// 边表头指针</span></span><br><span class="line">&#125;VertexNode, AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList adjList;</span><br><span class="line">    <span class="keyword">int</span> numVertexes, numEdges;      <span class="comment">// 图中当前顶点数和边数</span></span><br><span class="line">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure></li><li><p>无向图的邻接表创建代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateALGraph</span><span class="params">(GraphAdjList *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入顶点数和边数：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d, %d"</span>, &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges);     <span class="comment">// 输入顶点数和边数 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;G-&gt;adjList[i].data);     <span class="comment">// 输入顶点信息。</span></span><br><span class="line">        G-&gt;adjList[i].firstEdge = <span class="literal">NULL</span>;     <span class="comment">// 将边表置为空表。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G-&gt;numVertexes; i++)&#123;    <span class="comment">// 建立边表</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入边(Vi,Vj)上的顶点序号：\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d, %d"</span>, &amp;i, &amp;j);    <span class="comment">// 输入边(Vi,Vj)上的顶点序号</span></span><br><span class="line">        e = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));       <span class="comment">// 申请内存空间，创建边表结点</span></span><br><span class="line">        e-&gt;adjvex = j;      <span class="comment">// 邻接序号为j</span></span><br><span class="line">        e-&gt;next = G-&gt;adjList[i].firstEdge;  <span class="comment">// 将e指针指向当前顶点指向的结点</span></span><br><span class="line">        G-&gt;adjList[i].firstEdge = e;    <span class="comment">// 将当前顶点的指针指向e</span></span><br><span class="line">        e = (EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));   <span class="comment">// 申请内存空间，创建边表结点</span></span><br><span class="line">        e-&gt;adjvex = i;  <span class="comment">// 邻接序号为i</span></span><br><span class="line">        e-&gt;next = G-&gt;adjList[j].firstEdge;  <span class="comment">// 将e指针指向当前顶点指向的结点</span></span><br><span class="line">        G-&gt;adjList[j].firstEdge = e;    <span class="comment">// 将当前顶点的指针指向e</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h1><ul><li>邻接表结构<br><img src="/09/数据结构之图/" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      🎈
    
    </summary>
    
      <category term="数据结构" scheme="BestQwerty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="BestQwerty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    
    
      <category term="数据结构" scheme="BestQwerty.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>迪杰斯特拉算法</title>
    <link href="BestQwerty.github.io/2019/06/09/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    <id>BestQwerty.github.io/2019/06/09/迪杰斯特拉算法/</id>
    <published>2019-06-09T12:18:35.000Z</published>
    <updated>2019-06-09T13:20:51.720Z</updated>
    
    <summary type="html">
    
      🦄Nobody can go back and start a new beginning,but anyone can start today and make a new ending.
    
    </summary>
    
      <category term="算法" scheme="BestQwerty.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="迪杰斯特拉算法" scheme="BestQwerty.github.io/categories/%E7%AE%97%E6%B3%95/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="BestQwerty.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>matlab主成分分析以及相关函数</title>
    <link href="BestQwerty.github.io/2019/05/25/matlab%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    <id>BestQwerty.github.io/2019/05/25/matlab主成分分析以及相关函数/</id>
    <published>2019-05-25T08:48:52.000Z</published>
    <updated>2019-05-25T09:26:07.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><h2 id="princomp"><a href="#princomp" class="headerlink" title="princomp"></a>princomp</h2><p>- </p>]]></content>
    
    <summary type="html">
    
      👓
    
    </summary>
    
      <category term="matlab" scheme="BestQwerty.github.io/categories/matlab/"/>
    
      <category term="主成分分析以及相关函数" scheme="BestQwerty.github.io/categories/matlab/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="matlab" scheme="BestQwerty.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab解方程</title>
    <link href="BestQwerty.github.io/2019/05/23/matlab%E8%A7%A3%E6%96%B9%E7%A8%8B/"/>
    <id>BestQwerty.github.io/2019/05/23/matlab解方程/</id>
    <published>2019-05-23T08:57:57.000Z</published>
    <updated>2019-05-23T09:40:53.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="syms"><a href="#syms" class="headerlink" title="syms"></a>syms</h1><ul><li>创建符号变量(或数组)和方程</li></ul><h1 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h1><ul><li>diff函数式用于求导数和差分的.<h1 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h1></li></ul><h2 id="dsolve"><a href="#dsolve" class="headerlink" title="dsolve"></a>dsolve</h2><ul><li>与solve函数类似可以使用向量式输入</li><li><p>一阶微分方程$dÿ/dt=ty$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms y（t）</span><br><span class="line">ode = diff（y，t）== t * y</span><br><span class="line">ode（t）= diff（y（t），t）== t * y（t）</span><br><span class="line">ySol（t）= dsolve（ode）</span><br></pre></td></tr></table></figure></li><li><p>如果增加一个条件y(0) = 2</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cond = y(<span class="number">0</span>) == <span class="number">2</span>;</span><br><span class="line">ySol(t) = dsolve(ode,cond)</span><br></pre></td></tr></table></figure></li><li><p>$(dy/dt+y)^2=1,y(0)=0.$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms y(t)</span><br><span class="line">ode = (diff(y,t)+y)^<span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">cond = y(<span class="number">0</span>) == <span class="number">0</span>;</span><br><span class="line">ySol(t) = dsolve(ode,cond)</span><br></pre></td></tr></table></figure></li><li><p>$du/dt=3u+4v,dv/Sdt=−4u+3v.$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syms u(t) v(t)</span><br><span class="line"><span class="comment">%Define the equations using == and represent differentiation using the diff function.</span></span><br><span class="line"></span><br><span class="line">ode1 = diff(u) == <span class="number">3</span>*u + <span class="number">4</span>*v;</span><br><span class="line">ode2 = diff(v) == <span class="number">-4</span>*u + <span class="number">3</span>*v;</span><br><span class="line">odes = [ode1; ode2]</span><br><span class="line"><span class="comment">%odes(t) =</span></span><br><span class="line"> diff(u(t), t) == <span class="number">3</span>*u(t) + <span class="number">4</span>*v(t)</span><br><span class="line"> diff(v(t), t) == <span class="number">3</span>*v(t) - <span class="number">4</span>*u(t)</span><br><span class="line"><span class="comment">%Solve the system using the dsolve function which returns the solutions as elements of a structure.</span></span><br><span class="line"></span><br><span class="line">S = dsolve(odes)</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/lynn15600693998/article/details/86597068" target="_blank" rel="noopener">dsolve csdn</a></li></ul>]]></content>
    
    <summary type="html">
    
      🤣
    
    </summary>
    
      <category term="matlab" scheme="BestQwerty.github.io/categories/matlab/"/>
    
      <category term="解方程" scheme="BestQwerty.github.io/categories/matlab/%E8%A7%A3%E6%96%B9%E7%A8%8B/"/>
    
    
      <category term="matlab" scheme="BestQwerty.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab文件的读取</title>
    <link href="BestQwerty.github.io/2019/05/19/matlab%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96/"/>
    <id>BestQwerty.github.io/2019/05/19/matlab文件的读取/</id>
    <published>2019-05-19T06:11:52.000Z</published>
    <updated>2019-05-19T12:02:30.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据的导入与导出"><a href="#数据的导入与导出" class="headerlink" title="数据的导入与导出"></a>数据的导入与导出</h1><ul><li>注意设置当前路径为文件所在路径</li></ul><h2 id="save"><a href="#save" class="headerlink" title="save"></a>save</h2><ul><li><a href="https://ww2.mathworks.cn/help/matlab/ref/save.html#btox10b-1-version" target="_blank" rel="noopener">save</a></li><li><code>save  XXX;</code>是将当前文件中的全部变量存起来，得到一个名为XXX.mat的文件。</li><li><p><code>save filename</code> 是命令形式的语法。命令形式需要的特殊字符较少。您无需键入括号或者将输入括在单引号或双引号内。使用空格（而不是逗号）分隔各个输入项。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如，要保存名为 test.mat 的文件，这些语句是等效的：</span><br><span class="line">save test.mat      <span class="comment">% command form</span></span><br><span class="line">save(<span class="string">'test.mat'</span>)   <span class="comment">% function form</span></span><br><span class="line"></span><br><span class="line">您可以包括先前语法中介绍的任何输入。例如，要保存名为 X 的变量：</span><br><span class="line">save test.mat X       <span class="comment">% command form</span></span><br><span class="line">save(<span class="string">'test.mat'</span>,<span class="string">'X'</span>)  <span class="comment">% function form</span></span><br><span class="line"></span><br><span class="line">当有任何输入（例如 filename）为变量或字符串时，请不要使用命令格式。</span><br></pre></td></tr></table></figure></li><li></li></ul><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><ul><li><a href="https://ww2.mathworks.cn/help/matlab/ref/load.html" target="_blank" rel="noopener">load</a></li><li><code>load filename</code> 是该语法的命令形式。命令形式需要的特殊字符较少。您无需键入括号或者将输入括在单引号或双引号内。使用空格（而不是逗号）分隔各个输入项。 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如，要加载名为 durer.mat 的文件，以下语句是等效的：</span><br><span class="line"></span><br><span class="line">load durer.mat      <span class="comment">% command form</span></span><br><span class="line">load(<span class="string">'durer.mat'</span>)   <span class="comment">% function form</span></span><br><span class="line"></span><br><span class="line">您可以包括先前语法中介绍的任何输入。例如，要加载名为 X 的变量：</span><br><span class="line">load durer.mat X       <span class="comment">% command form</span></span><br><span class="line">load(<span class="string">'durer.mat'</span>,<span class="string">'X'</span>)  <span class="comment">% function form</span></span><br><span class="line"></span><br><span class="line">当有任何输入（例如 filename）为变量或字符串时，请不要使用命令格式。</span><br></pre></td></tr></table></figure></li></ul><h1 id="text文件的读取与写入"><a href="#text文件的读取与写入" class="headerlink" title="text文件的读取与写入"></a>text文件的读取与写入</h1><h2 id="textread"><a href="#textread" class="headerlink" title="textread"></a>textread</h2><ul><li><a href="https://ww2.mathworks.cn/help/matlab/ref/textread.html" target="_blank" rel="noopener">textread</a></li><li>读取文本文件中的数据；写入多个输出 </li><li>语法:<ul><li><code>[A,B,C,...] = textread(filename,format)</code></li><li><code>[A,B,C,...] = textread(filename,format,N)</code></li><li><code>[...] = textread(...,param,value,...)</code></li></ul></li><li>必须严格遵守用法不可出现<code>data=textread(filename,format,N)</code>的形式</li><li>其中括号里面变量的个数必须和format中定义的个数相同。 </li><li>textread不用先fopen那个文件，适用于格式统一的txt文件的一次性大批量读取。textread读取某个文件后，下次再用textread读取这个文件时，还是会从文件头开始读取。</li><li><code>[A,B,C,…]=textread（filename，format，N）</code><ul><li>[A,B,C,…]：读取的数据</li><li>Filename：文件名</li><li>Format：读取格式</li><li>N：读取次数 其中 N 是大于零的整数。如果 N 小于零，textread 将读取整个文件。</li></ul></li><li>如果每N行相同格式的数据，可采用<code>[A,B,C,…] = textread （filename,format,N）</code>的语法，读取N次。</li><li>读取大型文本文件、从文件中的特定点读取或将文件数据读取到元胞数组而非多个输出时，您可以首选使用 textscan 函数。</li></ul><h2 id="textscan"><a href="#textscan" class="headerlink" title="textscan"></a>textscan</h2><ul><li>导入混合格式文本</li><li><p><code>textscan(fid, &#39;format&#39;, N, &#39;param&#39;, value);</code></p><ul><li>其中，fid为文件句柄；format为读取格式；N表示用该格式读取N次数据；’param’, value（可选项）指定分隔符和值对。</li><li>注意：使用textscan之前，必须先用fopen打开要读入的文件；函数textread用法类似。<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fid = fopen(<span class="string">'myfile.txt'</span>);</span><br><span class="line"></span><br><span class="line">C = textscan(fid, <span class="string">'%s%s%f%d%s'</span>);</span><br><span class="line"></span><br><span class="line">fclose(fid)；使用textscan函数读取文件，输出C为<span class="number">1</span>*<span class="number">5</span>的细胞数组，每个数组中存放每列的数据</span><br></pre></td></tr></table></figure></li></ul></li><li><p>优势：</p><ul><li>textscan更适合读入大文件；</li><li>textscan可以从文件的任何位置开始读入，而textread 只能从文件开头开始读入；<ul><li>textscan也可以从上一次textscan结束的位置开始读入，而textread不能；</li><li>textscan只返回一个数组（其实应该说是一个细胞矩阵），而textread要返回多个数组（嗯嗯）；</li></ul></li><li>textscan提供更多转换读入数据的选择；<ul><li>textscan提供给用户更多的配置参数。</li></ul></li></ul></li><li>textread不用先fopen那个文件，适用于格式统一的txt文件的一次性大批量读取。而使用textscan函数之前需要先用fopen函数打开要读取的文件并返回句柄fid</li><li>textscan函数每次读完数据后，其对应的句柄fid都是指向接下来要读数据的地方，类似于C函数中的文件读取指针，这样更方便于读取文本时的精确控制。</li><li>extscan函数可以将多组数据读到一个元胞矩阵中，而textread函数只能将数据分别读取到不同的向量中。比如一个含有10行3列浮点数的文件，textscan函数可以将之读取到一个变量名A下 <code>A=textscan(fid, &#39;%f%f%f&#39;)</code>, 而使用textread函数必须将之读入到三个变量名中  <code>[A,B,C] = textread（filename,&#39;%f%f%f&#39;）</code>。</li></ul><h1 id="xls文件的读取与写入"><a href="#xls文件的读取与写入" class="headerlink" title="xls文件的读取与写入"></a>xls文件的读取与写入</h1><h2 id="xlsread"><a href="#xlsread" class="headerlink" title="xlsread"></a>xlsread</h2><ul><li><a href="https://ww2.mathworks.cn/help/matlab/ref/xlsread.html" target="_blank" rel="noopener">xlsread</a></li><li>读取 Microsoft Excel 电子表格文件</li><li><p>语法：</p><ul><li><code>num = xlsread(filename)</code> 读取名为 filename 的 Microsoft® Excel® 电子表格工作表中的第一张工作表，并在一个矩阵中返回数值数据。</li><li><code>num = xlsread(filename,sheet)</code> 读取指定的工作表。</li><li><code>num = xlsread(filename,xlRange)</code> 从工作簿的第一个工作表的指定范围内读取数据。使用 Excel 范围语法，例如 ‘A1:C3’。  </li></ul></li><li><p><code>[num,txt,raw]=xlsread(&#39;data1.xlsx&#39;,&#39;Sheet1&#39;,&#39;A1:H4&#39;)</code></p><ul><li>数据返回num；文本返回txt；不处理直接作为元胞返回raw </li></ul></li><li><code>A=xlsread(filename,sheet,’range’)</code><ul><li>A：读取的数据</li><li>Filename：文件名</li><li>Sheet：读取的工作表</li><li>Range：读取范围</li></ul></li><li>filename - 文件名 字符向量 | 字符串<ul><li>文件名，指定为字符向量或字符串。</li><li>示例： ‘myFile.xlsx’ 或 “myFile.xlsx”</li></ul></li></ul><h2 id="xlswrite"><a href="#xlswrite" class="headerlink" title="xlswrite"></a>xlswrite</h2><ul><li>写入 Microsoft Excel 电子表格文件</li><li><p>语法:</p><ul><li><code>xlswrite(filename,A)</code> 将矩阵 A 写入 Microsoft® Excel® 电子表格工作簿 filename 中的第一张工作表，从单元格 A1 开始写入。</li><li><code>xlswrite(filename,A,sheet)</code> 将数据写入指定的工作表。</li><li><code>xlswrite(filename,A,xlRange)</code> 将数据写入工作簿的第一个工作表中由 `xlRange 指定的矩形区域内。使用 Excel 范围语法，例如 ‘A1:C3’。</li><li><p><code>xlswrite(filename,A,sheet,xlRange)</code> 将数据写入指定的工作表和范围。</p></li><li><p><code>status = xlswrite(___)</code> 使用先前语法中的任何输入参数返回写入操作的状态。当操作成功时，status 为 1。否则，status 为 0。</p></li></ul></li><li>xlRange - 矩形范围 字符向量 | 字符串<ul><li>矩形范围，指定为字符向量或字符串。</li><li>使用两个对角指定 xlRange，这两个对角用来定义要写入的区域。例如，’D2:H4’ 表示工作表上两个角落 D2 和 H4 之间的 3×5 矩形区域。xlRange 输入不区分大小写，并使用 Excel A1 引用样式（请参阅 Excel 帮助）。xlswrite 不能识别命名范围。</li></ul></li><li><code>s=xlswrite(filename,data,sheet,range)</code><ul><li>s:是否写入成功</li><li>Filename：文件名<br>-Data：被写入的数据</li><li>Sheet：写入的工作表</li><li>Range：写入的范围</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      😝
    
    </summary>
    
      <category term="matlab" scheme="BestQwerty.github.io/categories/matlab/"/>
    
      <category term="文件" scheme="BestQwerty.github.io/categories/matlab/%E6%96%87%E4%BB%B6/"/>
    
    
      <category term="matlab" scheme="BestQwerty.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>lingo</title>
    <link href="BestQwerty.github.io/2019/05/19/lingo/"/>
    <id>BestQwerty.github.io/2019/05/19/lingo/</id>
    <published>2019-05-19T05:58:44.000Z</published>
    <updated>2019-05-21T09:15:08.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lingo"><a href="#lingo" class="headerlink" title="lingo"></a>lingo</h1><ul><li>Lingo文件类型： 文件后缀名为“.lg4”</li><li>变量默认大于0，若取负数，要另外说明</li><li>每个语句必须以分号“;”结束，每行可以有多个语句，语句可以跨行；</li><li>可以给语句加上标号，例如<code>[OBJ]  MAX= …   ;</code></li><li>以“!”开头，以“;”结束的语句是注释语句；</li><li>变量名称必须以字母(A-Z)开头，由字母、数字(0-9)和下划线“_”组成，长度不超过32个字符，<strong>不区分大小写</strong>；</li><li>求目标函数的最大值和最小值分别用MAX= …或MIN= …来表示；</li><li>直译法<ul><li>对于简单的模型，可以直接照搬到lingo上，lingo是可以识别的<br><img src="https://pic2.zhimg.com/v2-af4f24f8f8922c6e8214ead6e68b253d_b.jpg" alt=""><br><img src="https://pic4.zhimg.com/v2-f88bb50040359fcb5c1b731252799dc3.jpg" alt=""></li></ul></li><li><p>lingo模型以<code>model:</code>开头，<code>end:</code>结尾,对于简单的模型，可以省略</p><ul><li>Lingo一般是把全部代码放在 model: ……. end 中间（就解决一个问题，省略也行），整个叫做模型段。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">model:</span><br><span class="line">    sets:  !定义集合(数据)类型;</span><br><span class="line">        .....</span><br><span class="line">    endsets</span><br><span class="line"></span><br><span class="line">    data:  !数据的初始化;</span><br><span class="line">        ....</span><br><span class="line">    enddata</span><br><span class="line"></span><br><span class="line">    min/max...</span><br><span class="line"></span><br><span class="line">    约束条件</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul></li><li><p>集合段：sets: …… endsets ——用来声明和定义数组变量；</p></li><li>数据段：data: …… enddata ——用数据对变量赋值；</li><li>初始化段: 在数据段给变量赋值以后,该变量在整个程序运行阶段都是 常量,而不是决策变量. 如果想对决策变量赋一定初始值,希望该初始值作为寻找最 优解的起始值(变量本身不是常量),可以在程序中增加初始 段<ul><li>初始化段以语句INIT:开头,以语句ENDINIT结束 如下程序 INIT: X=0.99; Y=0.01; ENDINIT Y&lt;=@LOG(X); X^2+Y^2&lt;=1;</li><li>注: 初始化段只对非线性模型起作用,在线性模型中不起任何 作用.</li></ul></li><li>LINGO中建立的优化模型可以由六个部分组成，或称为六“段”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">集合段：用于定义数组型性变量SETS: ……ENDSETS</span><br><span class="line">数据段：用于变量赋值与数据传递DATA: ……ENDDATA</span><br><span class="line">目标与约束段：用于列出目标与约束唯一一个没有段的开始和结束标记</span><br><span class="line">计算段：用于数据初始整理计算CALC: ……ENDCALC</span><br><span class="line">初始段：用于变量赋初值迭代寻优INIT: ……ENDINIT</span><br><span class="line">子模型段：用于表达子模型进行调用@SUBMODEL mymodel:可执行语句（约束+目标）ENDSUBMODEL</span><br></pre></td></tr></table></figure></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li>集合的属性就是由元素构成的矩阵</li><li><ul><li>集合定义部分<ul><li>集合是一组相关对象构成的组合</li><li>集合分为初始(基本\原始)集合和衍生(派生)集合</li><li>集合在使用之前需要预先给出定义,</li><li>初始集合的定义三要素:<ul><li>集合的名称, 集合的元素, 集合的属性(可视为与该集合有关的变量或常量).</li></ul></li></ul></li></ul></li><li>初始集合的定义格式: 集合的名称/集合的元素/:集合的属性;</li><li>衍生集合的定义四要素: <ul><li>集合的名称,  对应的初始集合, 集合的元素(可以省略), 集合的属性(可以没有).</li><li>如果集合的元素省略不写, 则默认衍生集合的元素取它所对应初始集合的所有可能组合.</li></ul></li><li><p>衍生集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">links(wh, wa):c;  <span class="comment">//此时的衍生集合c相当于二维矩阵(数组)</span></span><br></pre></td></tr></table></figure></li><li><p>数据初始化部分以“DATA:” 开始, 以ENDDATA结束，</p><ul><li>这两个语句必须单独成一行；</li><li>数据之间的逗号和空格可以替换</li></ul></li><li><code>supplys /1 .. 3/: S;</code><ul><li>声明一个长度为 3 的一维数组 supplys, 并用它定义一个这样的一维数组变量 S.</li><li>先是数组名（随便起），再是用两个 / 夹在中间的是数组的下标范围，中间 .. 是省略表示法，接着用 : 定义数组变量 S。</li></ul></li><li><code>demands/1..4/: D;</code> 声明一个长度为 4 的一维数组 demands，并定义一个这样的一维数组变量 D。</li><li><code>links(supplys, demands): c, x;</code> 声明一个  的二维数组 links，并用它定义两个这样的<strong>二维数组变量 c, x.</strong><ul><li>把两个一维数组放一起，起个名字叫 links，得到二维数组 links，第1个一维数组的维数就是二维数组的行数维度，第2个一维数组的维数就是二维数组的列数维度。</li><li>注意：这里 links 不是Lingo关键字，<strong>可以随便起名</strong>。</li></ul></li></ul><h2 id="数据段补充"><a href="#数据段补充" class="headerlink" title="数据段补充"></a>数据段补充</h2><p><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E6%95%B0%E6%8D%AE%E6%AE%B51.png" alt=""><br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E6%95%B0%E6%8D%AE%E6%AE%B52.png" alt=""><br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E6%95%B0%E6%8D%AE%E6%AE%B53.png" alt=""></p><h2 id="目标函数与目标条件"><a href="#目标函数与目标条件" class="headerlink" title="目标函数与目标条件"></a>目标函数与目标条件</h2><ul><li><code>@sum</code>@SUM是LINGO提供的内部函数，其作用是对某个集合的所有成员，求指定表达式的和.<ul><li><code>@SUM</code>有两个参数：集合名称和表达式,如<code>MIN = @SUM(LINKS(I, J): C(I, J)*X(I, J));</code><br><img src="https://www.zhihu.com/equation?tex=%EF%BC%881%EF%BC%89%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%EF%BC%9A%5Cmin+~~+f%3D%5Csum_%7Bi%3D1%7D%5E3+%5Csum_%7Bj%3D1%7D%5E4+c_%7Bi+j%7D+x_%7Bi+j%7D" alt=""></li><li>如果表达式中参与运算的属性属于同一个集合，则<code>@SUM</code>的索引可以省略. 即<code>MIN = @SUM(LINKS: C*X);</code></li><li>目标函数是求最小，所以用 “min=”</li><li>有 $\sum$，所以需要用到 <code>@sum()</code> 函数， 这是Lingo里的求和函数，首先得告诉它求和的范围， i 从1到3， j 从1到4，这不正好是前面声明的（对应的）二维数组 links 的大小吗，所以就用 <code>links(i, j)</code>来告诉（也只能用声明的数组来告诉），并用 i 表示行索引， j 表数列索引。</li><li>然后，冒号，求和里面的表达式。</li></ul></li><li><code>@for</code>是LINGO提供的内部函数，其作用是对某个集合的所有成员分别生成一个约束表达式.有两个参数：集合名和约束表达式<ul><li><code>@FOR(WH(I): @SUM(VD(J): X(I, J)) &lt;= AI(I) );</code>wh(i)是对集合wh的下标i进行循环，然后@sum内部的vd(j)是对集合vd的下标j进行循环，内外循环就是相当于二重for循环，外循环为i，内循环为j</li></ul></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>0-1规划中<code>@bin</code>限制为整数0或1</li><li>如果整数规划问题中的所有变量仅限于取0或1两个值，则称此问题为0-1整数规划，简称0-1规划，其变量为0-1变量.</li></ul><p><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B01.png" alt=""><br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E6%A6%82%E7%8E%87%E5%87%BD%E6%95%B0.png" alt=""><br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0.png" alt=""><br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E5%8F%98%E9%87%8F%E5%AE%9A%E7%95%8C%E5%87%BD%E6%95%B0.png" alt=""><br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B01.png" alt=""></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>LINGO中关系运算符有3种：<ul><li>&lt; (即&lt;=，小于等于)</li><li>= (等于)</li><li><code>&gt;</code>(即&gt;=，大于等于)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt=""><br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E8%BF%90%E7%AE%97%E7%AC%A62.png" alt=""></p><h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><p><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E7%AA%97%E5%8F%A31.png" alt=""><br><img src="https://pic2.zhimg.com/v2-33548066055be68506686830be26f431.jpg" alt=""></p><h2 id="状态窗口"><a href="#状态窗口" class="headerlink" title="状态窗口"></a>状态窗口</h2><ul><li>状态窗口(Solver Status)的详细的介绍如下：</li><li>Model Class:模型类别显示的模型类别为LP, QP ILP, QP, ILP, IQP, LP, NLP等</li><li><p>Model Class 当前模型的类型</p><ul><li>可能显示：LP(线性规划)，QP(二次规划)，ILP(整数线性规划)，IQP(整数二次规划)，PILP(纯整数线性规划)，PIQP(纯整数二次规划)，NLP(非线性规划)，MIP(混合整数规划)，INLP(整数非线性规划)，PINLP(纯整数非线性规划)．</li><li>注 以 I 开头表示 IP(整数规划)，以 PI 开头表示 PIP(纯整数规划)．</li></ul></li><li><p>State:  Possible states are “Global Optimum”表示求出了全局最优解;, “Local Optimum”, “Feasible”可行解, “Infeasible”不可行, “Unbounded”无界, “Interrupted”, and “Undetermined”未确定.</p></li><li>Objective: 目标函数的当前值.</li><li>Infeasibility: 当前约束不满足的总量(不是不满足的约束的个数):实数（即使该值=0，当前解也可能不可行，因为这个量中没有考虑用上下界命令形式给出的约束）</li><li>Iterations: 迭代次数</li></ul><h2 id="报告（Solve-Report）窗口"><a href="#报告（Solve-Report）窗口" class="headerlink" title="报告（Solve Report）窗口"></a>报告（Solve Report）窗口</h2><ul><li>Slack or Surplus（小于：松弛，大于：过剩）：如果满足约束条件,则该值是左右差的绝对值.<ul><li>如果不满足约束条件,则该值为负数.</li><li>如果该值为0,说明两边相等.<br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E6%B1%82%E8%A7%A3%E6%8A%A5%E5%91%8A1.png" alt=""></li></ul></li></ul><h1 id="lingo灵敏度分析"><a href="#lingo灵敏度分析" class="headerlink" title="lingo灵敏度分析"></a>lingo灵敏度分析</h1><ul><li>灵敏度分析报告（Range Report）</li><li>lingo只能对线性的模型做灵敏度分析</li><li>灵敏性分析是在求解模型时作出的，因此在求解模型时灵敏性分析是激活状态，但是默认是不激活的。为了激活灵敏性分析，运行LINGO|Options…，选择General Solver Tab， 在Dual Computations列表框中，选择Prices and Ranges选项。然后点击Apply按钮。<ul><li>设置好了之后，你把需要进行灵敏度分析的程序写好了按 Ctrl+r 就行了<br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E7%81%B5%E6%95%8F%E5%BA%A6%E5%88%86%E6%9E%90.png" alt=""><br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/lingo%E7%81%B5%E6%95%8F%E5%BA%A6%E5%88%86%E6%9E%902.png" alt=""></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      😋
    
    </summary>
    
      <category term="lingo" scheme="BestQwerty.github.io/categories/lingo/"/>
    
    
      <category term="lingo" scheme="BestQwerty.github.io/tags/lingo/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="BestQwerty.github.io/2019/05/18/%E6%A0%91/"/>
    <id>BestQwerty.github.io/2019/05/18/树/</id>
    <published>2019-05-18T13:22:18.000Z</published>
    <updated>2019-05-23T08:59:51.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><ul><li><p>任一棵树中，结点总数=度数*该度数对应的结点数+1</p><ul><li>子节点个数为n0即各个度对应的个数乘以度减一然后累加后加1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">已知一棵度为m的树中：n1个度为<span class="number">1</span>的结点，n2个度为<span class="number">2</span>的结点，…，nm个度m的结点，问该树中共有多少个叶子结点？</span><br><span class="line"></span><br><span class="line">设该树的总结点数为n，则</span><br><span class="line">n=n0+n1+n2+…+nm</span><br><span class="line">又：</span><br><span class="line">n=分枝数+<span class="number">1</span>=<span class="number">0</span>xn0+<span class="number">1</span>xn1+<span class="number">2</span>xn2+…+mxnm</span><br><span class="line">由上述两式可得：</span><br><span class="line">n0=n2+<span class="number">2</span>n3+…+(m<span class="number">-1</span>)nm+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">即</span><br><span class="line"></span><br><span class="line">     d</span><br><span class="line">n0 =( Σ n(i) * (i - <span class="number">1</span>)) + <span class="number">1</span>           </span><br><span class="line">​     i=<span class="number">1</span></span><br><span class="line"> (其中，i ∈ Integer，d为树的度)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>树中边和结点的关系为：结点数=边数+1 -&gt; 边数 = 结点数-1</p></li></ul><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><ul><li>创建哈夫曼树并输出所有度为2的结点权值的和(huffman tree没有度为1的结点，度为0为叶子结点)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">huffman</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> parent;</span><br><span class="line"><span class="keyword">int</span> lchild;</span><br><span class="line"><span class="keyword">int</span> rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, i, a, b, sum;</span><br><span class="line"><span class="comment">//a,b是构造过程中的用于构造哈夫曼树的两个结点的下标，sum是计算所有度为2的结点的权值之和，n是叶子结点个数</span></span><br><span class="line">huffman huff[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//选出huff[1]到huff[i-1]中权值最小的且无父母结点的两个结点用以构造哈夫曼树</span></span><br><span class="line"><span class="keyword">int</span> huffdata1 = INF, huffdata2 = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i<span class="number">-1</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(huff[j].parent == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(huff[j].data &lt; huffdata1)&#123;</span><br><span class="line"><span class="keyword">if</span>(huff[j].data &lt; huffdata2)&#123;</span><br><span class="line"><span class="keyword">switch</span>(huffdata2 &gt; huffdata1)&#123;</span><br><span class="line"> <span class="comment">//注意因为huff[j].data可能小于huffdata2，而huffdata1如果小于huffdata2，那么应该将huffdata2权值更新为huffdata1，因为每次要选出结点权值最小的两个结点</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">huffdata2 = huffdata1;</span><br><span class="line">b = a;</span><br><span class="line">huffdata1 = huff[j].data;</span><br><span class="line">a = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">huffdata1 = huff[j].data;</span><br><span class="line">a = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(huff[j].data &lt; huffdata2)&#123;</span><br><span class="line">huffdata2 = huff[j].data;</span><br><span class="line">b = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; huff[i].data;</span><br><span class="line">huff[i].lchild = huff[i].rchild = huff[i].parent = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = n+<span class="number">1</span>; i &lt;= <span class="number">2</span>*n<span class="number">-1</span>; i++) huff[i] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i = n+<span class="number">1</span>; i &lt;= <span class="number">2</span>*n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">select(); </span><br><span class="line">sum += huff[a].data + huff[b].data;</span><br><span class="line">huff[i].data = huff[a].data + huff[b].data;</span><br><span class="line">huff[a].parent = huff[b].parent = i;</span><br><span class="line">huff[i].lchild = a, huff[i].rchild = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">模拟哈夫曼树构造过程:</span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">10</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/huffman%20tree.png" alt=""><br>office真好用</p>]]></content>
    
    <summary type="html">
    
      😋
    
    </summary>
    
      <category term="数据结构" scheme="BestQwerty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="BestQwerty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="BestQwerty.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>素数</title>
    <link href="BestQwerty.github.io/2019/05/18/%E7%B4%A0%E6%95%B0/"/>
    <id>BestQwerty.github.io/2019/05/18/素数/</id>
    <published>2019-05-18T07:38:50.000Z</published>
    <updated>2019-05-18T07:44:36.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美素数"><a href="#美素数" class="headerlink" title="美素数"></a>美素数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">五：美素数</span><br><span class="line">Time Limit: <span class="number">3000</span>/<span class="number">1000</span> MS (Java/Others)    Memory Limit: <span class="number">65535</span>/<span class="number">32768</span> K (Java/Others)</span><br><span class="line">Total Submission(s): 10835    Accepted Submission(s): 3669</span><br><span class="line"></span><br><span class="line">Problem Description</span><br><span class="line">　　小明对数的研究比较热爱，一谈到数，脑子里就涌现出好多数的问题，今天，小明想考考你对素数的认识。</span><br><span class="line">　　问题是这样的：一个十进制数，如果是素数，而且它的各位数字和也是素数，则称之为“美素数”，如<span class="number">29</span>，本身是素数，而且<span class="number">2</span>+<span class="number">9</span> = <span class="number">11</span>也是素数，所以它是美素数。</span><br><span class="line">　　给定一个区间，你能计算出这个区间内有多少个美素数吗？</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">第一行输入一个正整数T，表示总共有T组数据(T &lt;= <span class="number">10000</span>)。</span><br><span class="line">接下来共T行，每行输入两个整数L，R(<span class="number">1</span>&lt;= L &lt;= R &lt;= <span class="number">1000000</span>)，表示区间的左值和右值。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">对于每组数据，先输出Case数，然后输出区间内美素数的个数（包括端点值L,R）。</span><br><span class="line">每组数据占一行，具体输出格式参见样例。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Sample Input</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">100</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">19</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line">Case #<span class="number">1</span>: <span class="number">14</span></span><br><span class="line">Case #<span class="number">2</span>: <span class="number">1</span></span><br><span class="line">Case #<span class="number">3</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/%E7%BE%8E%E7%B4%A0%E6%95%B0.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;美素数&quot;&gt;&lt;a href=&quot;#美素数&quot; class=&quot;headerlink&quot; title=&quot;美素数&quot;&gt;&lt;/a&gt;美素数&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="BestQwerty.github.io/2019/05/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>BestQwerty.github.io/2019/05/18/动态规划/</id>
    <published>2019-05-18T07:03:22.000Z</published>
    <updated>2019-05-27T13:39:54.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="红鲤鱼与绿鲤鱼"><a href="#红鲤鱼与绿鲤鱼" class="headerlink" title="红鲤鱼与绿鲤鱼"></a>红鲤鱼与绿鲤鱼</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">15</span>周任务-红鲤鱼和绿鲤鱼</span><br><span class="line">时间限制：<span class="number">1</span>秒 内存限制：<span class="number">128</span>兆</span><br><span class="line"><span class="number">7</span> 次提交 <span class="number">2</span> 次通过</span><br><span class="line">题目描述</span><br><span class="line">Polarbear（P.B.）有很多红鲤鱼和绿鲤鱼，它们在鱼缸排成一列，非常好看。P.B.可以任选一条鲤鱼把它染成红色或</span><br><span class="line">绿色，它的目标是在完成染色之后，让每条红色的鲤鱼R都比绿色的鲤鱼G离左侧更近（当然当所有鲤鱼颜色都相同</span><br><span class="line">时，很显然也满足这个条件）。P.B.想知道它最少需要涂染几条鲤鱼。</span><br><span class="line"></span><br><span class="line">如样例所示: s = RGRGRR</span><br><span class="line">我们涂染之后变成RRRRRR就满足要求了,涂染的个数为<span class="number">2</span>,没有比这个更好的涂染方案。</span><br><span class="line">输入</span><br><span class="line">输入包括一个字符串s,字符串s长度length(<span class="number">1</span>&lt;=length&lt;=<span class="number">50</span>),其中只包括<span class="string">'R'</span>或者<span class="string">'G'</span>,分别表示红鲤鱼和绿鲤鱼。</span><br><span class="line">输出</span><br><span class="line">输出一个整数,表示P.B.最少需要涂染的鲤鱼的数量。</span><br><span class="line">样例输入</span><br><span class="line">RGRGRR</span><br><span class="line">样例输出</span><br><span class="line"><span class="number">2</span></span><br><span class="line">题目分析：</span><br><span class="line">本题也是一道动态规划思想的题目，每次有两种选择，在所有选择中找最优选择方案。由于这题数据范围比较小。所有大部分人暴力的方法用双重循环遍历所有选择方案，最后也能解决问题。这是方法的时间复杂度是O（n^<span class="number">2</span>），但是如果我给的字符串长度超过了<span class="number">10000</span>，这种方法基本就无法解决问题了。这里我用动态规划的思想给出一种O（n）的解决方法。可以参照你们的解法和我的解法的区别，体会动态规划的思想和暴力解法的不同之处。</span><br></pre></td></tr></table></figure><ul><li>如何推导出状态转移方程式动态规划的难点，例如本题的状态转移方程就是:<br>dp[1][i] = min(dp[0][i-1]), dp[1][i-1]) + (str[i] == ‘G’ ? 0 : 1);<br>即第i次染色的最少染色次数为：[0,i-1]区间最少染色次数加上当前是否染色。则完成了[0,i-1]到[0,i]区间最优解的转移。</li></ul><p><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/%E7%BA%A2%E9%B2%A4%E9%B1%BC%E4%B8%8E%E7%BB%BF%E9%B2%A4%E9%B1%BC.png" alt=""></p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">15</span>周任务<span class="number">-01</span>背包</span><br><span class="line">时间限制：<span class="number">1</span>秒 内存限制：<span class="number">128</span>兆</span><br><span class="line"><span class="number">26</span> 次提交 <span class="number">5</span> 次通过</span><br><span class="line">题目描述</span><br><span class="line">背包最大允许装载为C, 有n个物品要放进背包，每个物品的重量为w[<span class="number">1</span>],w[<span class="number">2</span>],...w[n],每个物品的价值为v[<span class="number">1</span>],v[<span class="number">2</span>],...v</span><br><span class="line">[n], 请选择物品装进背包，使得价值最大。C为整数。</span><br><span class="line">输入</span><br><span class="line">第一行为物体个数n,以及背包容量C；</span><br><span class="line">第二行为n个重量（实数），空格隔开</span><br><span class="line">第三行为n个价值（实数），空格隔开</span><br><span class="line">输出</span><br><span class="line">第一行为最大装载的总价值</span><br><span class="line">第二行为每个物品是否装载，<span class="number">1</span>表示装，<span class="number">0</span>表示不装，中间用空格隔开</span><br><span class="line">(测试数据能保证最优解唯一)</span><br><span class="line">样例输入</span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line">样例输出</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span><span class="number">-1</span>背包是动态规划问题非常经典的一个入门题，可以从多个方面来理解<span class="number">0</span><span class="number">-1</span>背包推导过程。这里我用递归到递推两种形式来给出<span class="number">0</span><span class="number">-1</span>背包问题解决方法。</span><br></pre></td></tr></table></figure><ul><li>1、递归解法：<br>递归的方法较为直观，可以很直观的看出状态转移的思路。但是可能递归的中间过程比较难以想象。但是递归的思维方式比较简单，只需要抓住两点：递归终点和递归方程。终点就是在递归的边界情况的返回值，递归方程即从当前节点继续搜索子问题的最优解。注意结合这里递归方程理解dp中的状态转移方程。<br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/01-%E8%83%8C%E5%8C%85%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95.png" alt=""><ul><li>很明显这种方式无法记录我们最后选择了那些物品，而且在递归的过程中存在很多不必要的搜索，所以我们需要用到记忆化搜索来剪枝并且记录节点的选择。<br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/01-%E8%83%8C%E5%8C%85%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%952.png" alt=""></li></ul></li></ul><ul><li>2、递推解法<br>递推的方法其实也就是我们用到的双重循环，实际上我们可以把循环递推看成递归的一个逆过程。递归是当前不知道当前最优解，一直往子问题搜索，直到递归到子问题的边界然后开始回退，依次求出路径中的最优解。而递推则是通过已知的最优解通过状态转移方程逐步递推下一步的最优解，和贪心思想相似，只不过这里的最优解是动态的可修改的。我看见大家都是写的二维数组，这里我提供一个一维数组的方法。</li></ul><p><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/01-%E8%83%8C%E5%8C%85%E9%80%92%E6%8E%A8%E8%A7%A3%E6%B3%95.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;红鲤鱼与绿鲤鱼&quot;&gt;&lt;a href=&quot;#红鲤鱼与绿鲤鱼&quot; class=&quot;headerlink&quot; title=&quot;红鲤鱼
      
    
    </summary>
    
      <category term="算法" scheme="BestQwerty.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="BestQwerty.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="BestQwerty.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>n皇后</title>
    <link href="BestQwerty.github.io/2019/05/17/n%E7%9A%87%E5%90%8E/"/>
    <id>BestQwerty.github.io/2019/05/17/n皇后/</id>
    <published>2019-05-17T15:33:29.000Z</published>
    <updated>2019-05-17T15:35:15.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="n皇后位运算版"><a href="#n皇后位运算版" class="headerlink" title="n皇后位运算版"></a>n皇后位运算版</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> sum=<span class="number">0</span>, upperlim=<span class="number">1</span>;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> row, <span class="keyword">long</span> ld, <span class="keyword">long</span> rd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row!=upperlim) <span class="comment">//row表示为表示对应行的列是放置，放置了放1，没放置放0； </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> pos = upperlim &amp; ~(row | ld | rd); <span class="comment">//可以放置的列的位置,对应位为0，</span></span><br><span class="line"><span class="keyword">while</span> (pos)    <span class="comment">//pos为0 皇后没有地方可放，回溯； </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> p=pos&amp;-pos;        <span class="comment">//取得可以放皇后的最右边的列，其余bit置0</span></span><br><span class="line">pos-=p; <span class="comment">//将最后边的列置为0，为下一次选可放置的列做准备，后面并没有用</span></span><br><span class="line"><span class="comment">//其用途用于循环判断以及求出下一个p  ----我的注释    </span></span><br><span class="line">test(row+p, (ld+p)&lt;&lt;<span class="number">1</span>,(rd+p)&gt;&gt;<span class="number">1</span>);  <span class="comment">//row ,ld,rd的新的值记录用于排除下一行禁忌列；                            </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>   </span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line">upperlim = (upperlim &lt;&lt; n) - <span class="number">1</span>;   <span class="comment">//移位减一，让可以放皇后的所有的行的存储列的位置置为1；      </span></span><br><span class="line">test(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      😋
    
    </summary>
    
      <category term="算法" scheme="BestQwerty.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="BestQwerty.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈的运用</title>
    <link href="BestQwerty.github.io/2019/05/08/%E6%A0%88%E7%9A%84%E8%BF%90%E7%94%A8/"/>
    <id>BestQwerty.github.io/2019/05/08/栈的运用/</id>
    <published>2019-05-08T03:00:35.000Z</published>
    <updated>2019-05-12T15:23:18.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h1><ul><li>后缀表达式又称逆波兰表达式，后缀记法</li><li>后缀表达式计算机求值<ul><li>与前缀表达式类似，只是顺序是从左至右：<ul><li>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</li></ul></li></ul></li><li>步骤:</li></ul><p><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/中缀表达式转换为后缀表达式.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/中缀表达式转换为后缀表达式2.jpg" alt=""></p><ul><li>题目：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">ctguoj</span><br><span class="line"><span class="number">191.2016</span>栈与队_表达式转换 (<span class="number">20</span>分) </span><br><span class="line">C时间限制：<span class="number">3000</span> 毫秒 |  C内存限制：<span class="number">3000</span> Kb</span><br><span class="line">题目内容：</span><br><span class="line"> 算术表达式有前缀表示法、中缀表示法、后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，</span><br><span class="line">即二元运算符位于两个运算数之间。请设计程序将中缀表达式转换为后缀表达式。</span><br><span class="line">中缀表示：<span class="number">2</span>+<span class="number">3</span><span class="number">-4</span></span><br><span class="line">后缀表示：<span class="number">2</span> <span class="number">3</span> + <span class="number">4</span> -， 符号在两个运算数据的后面。后缀表达有很多好处，例如可以不要括号，见下面</span><br><span class="line">的样例。</span><br><span class="line"> </span><br><span class="line">输入描述</span><br><span class="line">输入在一行中给出不含空格的中缀表达式，可包含+、-、*、/、（、）运算符，以#结束表达式</span><br><span class="line"></span><br><span class="line">输出描述</span><br><span class="line">在一行中给出转换后的表达式，要求不同对象（运算数、运算符号）之间以空格分隔</span><br><span class="line"></span><br><span class="line">输入样例</span><br><span class="line"><span class="number">2</span>+<span class="number">3</span>*(<span class="number">7</span><span class="number">-4</span>)#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st2; </span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compre</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(a)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line"><span class="keyword">char</span> b = st.top();</span><br><span class="line"><span class="keyword">if</span>(b == <span class="string">'*'</span>||b == <span class="string">'/'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; str.size(); i++)&#123;</span><br><span class="line"><span class="keyword">switch</span>(str[i])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">')'</span>: <span class="comment">//((2+3)*4-(8+2))/5#</span></span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'('</span>) st.push(str[i]);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line"><span class="keyword">char</span> a = st.top();</span><br><span class="line"><span class="keyword">int</span> c = st.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++)&#123;</span><br><span class="line">a = st.top();</span><br><span class="line"><span class="keyword">if</span>(a != <span class="string">'('</span>) st2.push(a);</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line"><span class="keyword">if</span>(st.empty() || (st.top() == <span class="string">'('</span>) )&#123;</span><br><span class="line">st.push(str[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(compre(str[i])) st.push(str[i]);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = st.top();</span><br><span class="line">st2.push(a);</span><br><span class="line">st.pop();</span><br><span class="line"><span class="keyword">if</span>(compre(str[i])) st.push(str[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">st2.push(str[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size1 = st.size();</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size1; i++)&#123;</span><br><span class="line">st2.push( st.top() );</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> str2;</span><br><span class="line"><span class="keyword">int</span> size2 = st2.size();</span><br><span class="line"><span class="keyword">for</span>(i = size2<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(!st2.empty())&#123;</span><br><span class="line">str2 += st2.top();</span><br><span class="line">st2.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = str2.length()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;          </span><br><span class="line"><span class="keyword">if</span>(str2[i] != <span class="string">'('</span>) <span class="built_in">cout</span> &lt;&lt; str2[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//((2+3)*4-(8+2))/5#</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h1><ul><li>检验表达式中左右括号(多种&amp;&amp;嵌套)是否可以对应匹配<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">march</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(a)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line"><span class="keyword">if</span>(b == <span class="string">')'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line"><span class="keyword">if</span>(b == <span class="string">']'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line"><span class="keyword">if</span>(b == <span class="string">'&#125;'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">switch</span>(str[i])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">switch</span>(str[i])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">st.push(str[i]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line"><span class="keyword">if</span>(st.empty())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>( march(str[i], st.top()) )&#123;</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(st.empty())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul><li><a href="https://www.cnblogs.com/chensongxian/p/7059802.html" target="_blank" rel="noopener">博客园</a></li></ul>]]></content>
    
    <summary type="html">
    
      😋
    
    </summary>
    
      <category term="数据结构" scheme="BestQwerty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="BestQwerty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"/>
    
    
      <category term="数据结构" scheme="BestQwerty.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的创建与遍历</title>
    <link href="BestQwerty.github.io/2019/05/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <id>BestQwerty.github.io/2019/05/08/二叉树的创建与遍历/</id>
    <published>2019-05-08T01:52:02.000Z</published>
    <updated>2019-05-20T12:48:54.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树创建与遍历"><a href="#二叉树创建与遍历" class="headerlink" title="二叉树创建与遍历"></a>二叉树创建与遍历</h1><ul><li>对于每个节点来说,每个节点自身又是根结点，所以任然遍历到自身，会访问到自身值 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Dtype char  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>  </span><br><span class="line">    Dtype data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LChild</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">RChild</span>;</span>  </span><br><span class="line">&#125;Bnode,* Btree;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Bnode *root)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">" "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBtree</span><span class="params">(Btree &amp;t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Dtype e;  </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; e;  </span><br><span class="line">    <span class="keyword">if</span>(e == <span class="string">'#'</span>)  </span><br><span class="line">        t = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        t = (Btree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Bnode));  </span><br><span class="line">        t-&gt;data = e;  </span><br><span class="line">        CreateBtree(t-&gt;LChild);  </span><br><span class="line">        CreateBtree(t-&gt;RChild);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pre_visit</span><span class="params">(Btree t)</span> <span class="comment">//前序遍历   </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(t)  </span><br><span class="line">    &#123;  </span><br><span class="line">        visit(t);  </span><br><span class="line">        Pre_visit(t-&gt;LChild);  </span><br><span class="line">        Pre_visit(t-&gt;RChild);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">In_visit</span><span class="params">(Btree t)</span>  <span class="comment">//中序遍历   </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(t)  </span><br><span class="line">    &#123;  </span><br><span class="line">        In_visit(t-&gt;LChild);  </span><br><span class="line">        visit(t);  </span><br><span class="line">       In_visit(t-&gt;RChild);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Post_visit</span><span class="params">(Btree t)</span>  <span class="comment">//后序遍历   </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(t)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Post_visit(t-&gt;LChild);  </span><br><span class="line">        Post_visit(t-&gt;RChild);  </span><br><span class="line">        visit(t);   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_leaf</span><span class="params">(Btree t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(t)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(!t-&gt;LChild &amp;&amp; !t-&gt;RChild)  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;  </span><br><span class="line">        print_leaf(t-&gt;LChild);  </span><br><span class="line">        print_leaf(t-&gt;RChild);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostTreeDepth</span><span class="params">(Btree t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> h1,h2,max;  </span><br><span class="line">    <span class="keyword">if</span>(t)  </span><br><span class="line">    &#123;  </span><br><span class="line">       h1 = PostTreeDepth(t-&gt;LChild);  </span><br><span class="line">        h2 = PostTreeDepth(t-&gt;RChild);  </span><br><span class="line">        max = h1 &gt; h2 ? h1 : h2;  </span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="keyword">else</span>  </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Btree t;  </span><br><span class="line">    CreateBtree(t);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"前序遍历二叉树"</span> &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    Pre_visit(t);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"中序序遍历二叉树"</span> &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    In_visit(t);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"后序遍历二叉树："</span> &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    Post_visit(t);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"输出叶子节点："</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    print_leaf(t);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"输出树的深度："</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; PostTreeDepth(t) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">a b # d f # # g # # c # e # h # # </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="二叉树练习"><a href="#二叉树练习" class="headerlink" title="二叉树练习"></a>二叉树练习</h1><ul><li><p>先序遍历用顺序存储的二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">preorder</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(a &gt;= n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tree[a] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2</span>*a &lt;= n) preorder(<span class="number">2</span>*a);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2</span>*a+<span class="number">1</span> &lt;= n) preorder(<span class="number">2</span>*a+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++) <span class="built_in">cin</span> &gt;&gt; tree[i];</span><br><span class="line">tree[i] = <span class="number">-1</span>;</span><br><span class="line">preorder(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一维数组输树输出中序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">580.</span>数据结构第六章-二叉树顺序存储变链式存储 (<span class="number">20</span>分) </span><br><span class="line">C时间限制：<span class="number">3000</span> 毫秒 |  C内存限制：<span class="number">3000</span> Kb</span><br><span class="line">题目内容：</span><br><span class="line"> 一个二叉树不是完全的，也可以类似于完全二叉树存储在一维数组中，只是那些树中的空孩子</span><br><span class="line">结点的所应在的数组元素也空起来。因此这种表示方法有空间的浪费。写一个算法将顺序存储的</span><br><span class="line">普通二叉树转变为链式存储结构。然后输出中序遍历的结果</span><br><span class="line">输入描述</span><br><span class="line">先输入n，再输入n个整数到一维数组，数组中正整数表示结点值，而<span class="number">-1</span>表示该处没有结点</span><br><span class="line"></span><br><span class="line">输出描述</span><br><span class="line">最后中序遍历的结果</span><br><span class="line"></span><br><span class="line">输入样例</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">-1</span> <span class="number">3</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出样例</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000</span>], k[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2</span>*i &lt;= n)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">2</span>*i] != <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree</span><span class="params">(<span class="keyword">int</span> ii)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = ii; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2</span>*i &lt;= n)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">2</span>*i] != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(judge(<span class="number">2</span>*i)&amp;&amp;k[<span class="number">2</span>*i] != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">2</span>*i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">k[<span class="number">2</span>*i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">tree(<span class="number">2</span>*i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k[i] != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">k[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span> &lt;= n)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">2</span>*i+<span class="number">1</span>] != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(judge(<span class="number">2</span>*i+<span class="number">1</span>)&amp;&amp;k[<span class="number">2</span>*i+<span class="number">1</span>] != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">2</span>*i+<span class="number">1</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">k[<span class="number">2</span>*i+<span class="number">1</span>] = <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line">tree(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">memset</span>(k, <span class="number">0</span>, <span class="keyword">sizeof</span>(k));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">tree(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      😋
    
    </summary>
    
      <category term="数据结构" scheme="BestQwerty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉树" scheme="BestQwerty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="BestQwerty.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>GitHub扩展</title>
    <link href="BestQwerty.github.io/2019/04/29/GitHub%E6%89%A9%E5%B1%95/"/>
    <id>BestQwerty.github.io/2019/04/29/GitHub扩展/</id>
    <published>2019-04-29T15:29:37.000Z</published>
    <updated>2019-04-29T15:37:01.135Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://zhuanlan.zhihu.com/p/55722104" target="_blank" rel="noopener">汇总</a></li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><ul><li>October<ul><li>它在 GitHub 页面的左侧上方添加了一个按钮，点击后会展开一个菜单，显示当前项目的整个文件夹结构。你可以浏览或下载单个源文件</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      ❤
    
    </summary>
    
      <category term="GitHub" scheme="BestQwerty.github.io/categories/GitHub/"/>
    
    
      <category term="Github" scheme="BestQwerty.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>浏览器以及扩展</title>
    <link href="BestQwerty.github.io/2019/04/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%B1%95/"/>
    <id>BestQwerty.github.io/2019/04/29/浏览器以及扩展/</id>
    <published>2019-04-29T15:22:12.000Z</published>
    <updated>2019-04-30T09:29:52.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="edge扩展"><a href="#edge扩展" class="headerlink" title="edge扩展"></a>edge扩展</h1><ul><li>油猴子tamperMonkey<ul><li><a href="https://tampermonkey.net/index.php?version=4.8.5847&amp;ext=gz80&amp;updated=true" target="_blank" rel="noopener">链接</a></li></ul></li><li>uBlock Origin 广告过滤“新牌”扩展</li><li>Video Downloader Professional:下载网页上的视频</li><li>欢迎来到 Greasy Fork，这里是一个提供用户脚本的网站。<ul><li><a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a></li></ul></li><li><a href="https://openuserjs.org/" target="_blank" rel="noopener">OpenUserJs</a></li><li>鼠标手势</li><li>grammarly for microsoft edge</li><li><a href="https://en.softonic.com/windows" target="_blank" rel="noopener">softonic</a></li></ul><h1 id="百分浏览器"><a href="#百分浏览器" class="headerlink" title="百分浏览器"></a>百分浏览器</h1><ul><li>emmm一堆</li></ul>]]></content>
    
    <summary type="html">
    
      🎨
    
    </summary>
    
      <category term="浏览器" scheme="BestQwerty.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="BestQwerty.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客与GitHub进阶操作</title>
    <link href="BestQwerty.github.io/2019/04/29/hexo%E5%8D%9A%E5%AE%A2%E4%B8%8EGitHub%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/"/>
    <id>BestQwerty.github.io/2019/04/29/hexo博客与GitHub进阶操作/</id>
    <published>2019-04-29T13:41:49.000Z</published>
    <updated>2019-04-29T14:11:19.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GitHub与hexo"><a href="#GitHub与hexo" class="headerlink" title="GitHub与hexo"></a>GitHub与hexo</h1><ul><li>GitHub改名后使用<code>hexo clean</code>命令清除之前的网页信息(改名后一些设置与图片丢失),再重新上传</li><li>GitHub上commit可以查看历史提交记录，修改记录与相应时间的仓库原状，可以clone/download历史版本</li><li><code>$ hexo clean</code><ul><li>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</li></ul></li><li>主题文件中avatar更改头像，favicon更改网页头像</li></ul>]]></content>
    
    <summary type="html">
    
      😏
    
    </summary>
    
      <category term="blog" scheme="BestQwerty.github.io/categories/blog/"/>
    
      <category term="捣鼓记" scheme="BestQwerty.github.io/categories/blog/%E6%8D%A3%E9%BC%93%E8%AE%B0/"/>
    
    
      <category term="blog" scheme="BestQwerty.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>matlab常用函数汇总</title>
    <link href="BestQwerty.github.io/2019/04/27/matlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/"/>
    <id>BestQwerty.github.io/2019/04/27/matlab常用函数汇总/</id>
    <published>2019-04-27T13:17:18.000Z</published>
    <updated>2019-05-27T13:38:07.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kron"><a href="#kron" class="headerlink" title="kron"></a>kron</h1><ul><li><a href="https://ww2.mathworks.cn/help/matlab/ref/kron.html" target="_blank" rel="noopener">Kronecker 张量积</a></li><li>语法:<ul><li><code>K = kron(A,B)</code> 返回矩阵 A 和 B 的 Kronecker 张量积。如果 A 是 m×n 矩阵，而 B 是 p×q 矩阵，则 <code>kron(A,B)</code>是通过获取 A 元素与矩阵 B 元素之间的所有可能积而形成的一个 m<em>p×n</em>q 矩阵。</li></ul></li><li>如果 A 是 m×n 矩阵，而 B 是 p×q 矩阵，则 A 和 B 的 Kronecker 张量积是通过将 B 乘以 A 的各元素形成的一个大型矩阵。</li></ul><h1 id="ismember"><a href="#ismember" class="headerlink" title="ismember"></a>ismember</h1><ul><li><a href="https://ww2.mathworks.cn/help/matlab/ref/ismember.html" target="_blank" rel="noopener">ismember</a></li></ul><h1 id="intersect"><a href="#intersect" class="headerlink" title="intersect"></a>intersect</h1><ul><li><a href="https://ww2.mathworks.cn/help/matlab/ref/intersect.html" target="_blank" rel="noopener">设置两个数组的交集</a></li></ul><h1 id="mat2str"><a href="#mat2str" class="headerlink" title="mat2str"></a>mat2str</h1><ul><li><a href="https://ww2.mathworks.cn/help/matlab/ref/mat2str.html" target="_blank" rel="noopener">将矩阵转换为字符</a></li></ul>]]></content>
    
    <summary type="html">
    
      😍
    
    </summary>
    
      <category term="matlab" scheme="BestQwerty.github.io/categories/matlab/"/>
    
      <category term="函数" scheme="BestQwerty.github.io/categories/matlab/%E5%87%BD%E6%95%B0/"/>
    
      <category term="汇总" scheme="BestQwerty.github.io/categories/matlab/%E5%87%BD%E6%95%B0/%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="matlab" scheme="BestQwerty.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab实现dfs/bfs</title>
    <link href="BestQwerty.github.io/2019/04/27/matlab%E5%AE%9E%E7%8E%B0dfs-bfs/"/>
    <id>BestQwerty.github.io/2019/04/27/matlab实现dfs-bfs/</id>
    <published>2019-04-27T13:16:03.000Z</published>
    <updated>2019-05-27T13:40:46.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dfs与bfs"><a href="#dfs与bfs" class="headerlink" title="dfs与bfs"></a>dfs与bfs</h1><ul><li><a href="https://blog.csdn.net/newcloudtech/article/details/8679439" target="_blank" rel="noopener">Matlab 深度优先搜索求解迷宫问题</a></li><li><a href="https://blog.csdn.net/newcloudtech/article/details/8679461" target="_blank" rel="noopener">Matlab 广度优先搜索求解迷宫问题</a></li><li><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">clc,clear;</span><br><span class="line"><span class="comment">%a = kron(eye (2),[-1 1] )</span></span><br><span class="line"><span class="comment">%a(:,1)</span></span><br><span class="line"><span class="comment">%maze = [0 2 5 5 1</span></span><br><span class="line">       <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line">        <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line">        <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%ismember(maze(1,1),[1,2,5] )</span></span><br><span class="line"><span class="comment">%maze = [1 2 3 4 5</span></span><br><span class="line">       <span class="number">2</span> <span class="number">23</span> <span class="number">3</span> <span class="number">1</span> <span class="number">5</span>];</span><br><span class="line"><span class="comment">%ismember(maze,[1:3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义四个方向</span></span><br><span class="line"><span class="comment">%directions = kron(eye(2),[-1,1]);</span></span><br><span class="line"><span class="comment">% 路径个数</span></span><br><span class="line"><span class="comment">%sol = 0;</span></span><br><span class="line"><span class="comment">% [I,J] = find(maze == 2);</span></span><br><span class="line"><span class="comment">% 找到起点</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      😋
    
    </summary>
    
      <category term="matlab" scheme="BestQwerty.github.io/categories/matlab/"/>
    
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="BestQwerty.github.io/2019/04/20/git/"/>
    <id>BestQwerty.github.io/2019/04/20/git/</id>
    <published>2019-04-20T13:14:02.000Z</published>
    <updated>2019-04-28T09:34:06.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><ul><li>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<ul><li>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li></ul></li><li><p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存(staged),git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库</p><ul><li>如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。<br><img src="https://raw.githubusercontent.com/BestQwerty/BestQwerty.github.io/master/images/git工作区域.png" alt=""></li></ul></li><li><p>每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果 git clone –bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</p></li><li><p>windows下编辑文本文件时最好用Notepad++而不要用自带记事本，因为后者在文件头部添加的十六进制字符0xefbbbf容易导致编译报错。Notepad++最好设置默认编码为UTF-8 (without BOM)</p></li></ul><ul><li>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。<ul><li>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2></li></ul></li></ul><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul><li>pwd命令用于显示当前目录。</li><li><p>如果使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名(包括父目录)不包含中文。 </p></li><li><p>通过<code>git init</code>命令把目录变成Git可以管理的仓库：</p></li><li><p>添加文件到Git仓库，分两步：</p><ul><li>使用命令<code>git add &lt; file &gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt; message &gt;</code>，完成。</li></ul></li><li><code>git status</code>查看工作区状态</li><li><code>git diff</code>查看difference(修改的内容)</li><li><code>cat &lt; file &gt;</code>查看文件内容</li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul><li>HEAD指向的版本是当前版本，<code>HEAD^</code>表示上一个版本，<code>HEAD^^</code>前一个的上个版本,<code>HEAD~n</code>前第n个版本</li><li><code>git log</code>可以查看提交历史</li><li><code>git reflog</code>可以查看命令历史，查看commit_id(版本号)</li><li><code>git reset --hard &lt; commid id&gt;</code>回到该版本号的版本<ul><li><code>git reset --hard HEAD^</code>回到上一版本</li><li>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</li></ul></li><li>克隆仓库的命令格式为 <code>git clone [url]</code>。</li></ul><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><ul><li><code>git diff</code>比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 命令。<ul><li>请注意，<code>git diff</code> 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</li><li><code>git add</code> 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area</li></ul></li><li>Git跟踪并管理的是修改，而非文件<ul><li>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</li></ul></li><li><code>git diff HEAD -- &lt; file &gt;</code>命令可以查看工作区和版本库里面最新版本的区别</li></ul><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul><li>命令<code>git checkout -- &lt; file &gt;</code>意思就是，把file在<strong>工作区</strong>的修改全部撤销，这里有两种情况:<ul><li>一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li><li>总之，就是让这个文件回到最近一次git commit或git add时的状态。 </li></ul></li><li><code>git reset HEAD &lt; file &gt;</code>可以把<strong>暂存区</strong>的修改撤销掉，HEAD表示当前版本(最新).</li><li>若已经提交到版本库，修改就要用版本回退</li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul><li><span id="inline-toc">1.</span>先手动删除文件后，若想继续删除版本库里的文件，则<code>git rm &lt; file &gt;</code>,然后更新版本库<code>git commit -m &quot;remove &lt; file &gt;&quot;</code>，若想恢复文件，则<code>git checkout -- &lt; file &gt;</code><ul><li>注意<code>git rm &lt;file&gt;</code>和<code>git add&lt;file&gt;</code>在这里都可以</li><li><code>git checkout</code>是用版本库里的版本替代工作区里的版本</li></ul></li><li><span id="inline-toc">2.</span>使用命令<code>rm &lt; file &gt;</code></li></ul><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><ul><li>远程仓库是指托管在网络上的项目仓库</li><li><p>如果在GitHub上创建仓库时默认了创建<strong>readme.md</strong>，那么刚刚建立的仓库中因为没有该md文件，所以要么删除md文件，要么<code>git pull origin master --allow-unrelated-histories</code>,然后进入编辑器后，若填写好原因，那么按ESC，：，wq的顺序先后按出.</p><ul><li>貌似可以先clone一下也可以，那样md文件也同步了</li></ul></li><li><p>新建仓库，然后在文件夹<code>git remote add origin git@github.com:Github账号名/仓库名.git</code></p><ul><li>远程仓库默认名字为origin</li><li><code>git remote add [shortname] [url]</code></li></ul></li><li>要查看当前配置有哪些远程仓库，可以用 <code>git remote</code> 命令，它会列出每个远程库的简短名字<ul><li>也可以加上 -v 选项（译注：此为 –verbose 的简写，取首字母），显示对应的克隆地址：</li></ul></li><li><code>git push [remote-name] [branch-name]</code>推送数据到远程仓库。<ul><li>克隆操作会自动使用默认的 master 和 origin 名字</li><li>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。</li><li>如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。(类似于第二条readme.md,因为必须同步)</li></ul></li><li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容</li><li><code>git remote show [remote-name]</code> 查看某个远程仓库的详细信息</li><li><p>远程仓库的删除和重命名，在新版 Git 中可以用 <code>git remote rename</code> 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure></li><li><p>注意，<strong>对远程仓库的重命名，也会使对应的分支名称发生变化</strong>，原来的 pb/master 分支现在成了 paul/master。<br>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 <code>git remote rm</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></li><li><p><code>git clone [url]</code>从远程仓库clone下来</p></li></ul><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul><li>Git 保存的不是文件差异或者变化量，而只是一系列文件快照<ul><li>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先</li></ul></li><li><a href="http://iissnan.com/progit/html/zh/ch3_1.html" target="_blank" rel="noopener">不想看了，先放着哈哈哈哈哈</a></li><li><a href="http://iissnan.com/progit/html/zh/ch3_1.html" target="_blank" rel="noopener">唧唧复唧唧</a></li></ul><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><ul><li><p>列出现有标签的命令非常简单，直接运行 <code>git tag</code> 即可</p><ul><li>显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。</li><li>以用特定的搜索模式列出符合条件的标签,若只对1.4.2系列的版本感兴趣<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -l &apos;v1.4.2.*&apos;</span><br><span class="line">v1.4.2.1</span><br><span class="line">v1.4.2.2</span><br><span class="line">v1.4.2.3</span><br><span class="line">v1.4.2.4</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）</p><ul><li>。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而<strong>含附注标签，实际上是存储在仓库中的一个独立对象</strong>，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般建议使用含附注型的标签，以便保留相关信息</li></ul></li></ul><h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><ul><li><p>创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可</p><ul><li>而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &apos;my hero 1.4&apos;</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以使用 <code>git show 版本号</code> 命令查看相应标签的版本信息，并连同显示打标签时的提交对象</p></li></ul><h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><ul><li>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可<code>git tag 名字</code></li><li>运行 <code>git show</code> 查看此标签信息，就只有相应的提交对象摘要</li></ul><h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><ul><li>可以使用 <code>git tag -v [tag-name]</code> （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证</li></ul><h3 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h3><ul><li>只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）</li></ul><h3 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h3><ul><li>默认情况下，<code>git push</code> 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 <code>git push origin [tagname]</code> 即可</li><li>如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项</li><li>现在，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。</li></ul><h2 id="技巧与窍门"><a href="#技巧与窍门" class="headerlink" title="技巧与窍门"></a>技巧与窍门</h2><ul><li><p>在输入 Git 命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议</p><ul><li>然后输入s，再敲一下tab会自动补全，然后可以继续tab，看看有没有相关命令，tab多敲几下就知道了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git pu&lt;tab&gt;&lt;tab&gt;</span><br><span class="line">pull   push</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可以用 <code>git config</code> 为命令设置别名</p><ul><li>若要输入<code>git commit</code>只要输入<code>git ci</code>即可</li><li>使用这种技术还可以创造出新的命令，比方说取消暂存文件时的输入比较繁琐<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line">$ git config --global alias.unstage 'reset HEAD --'</span><br><span class="line"><span class="comment">//与下面相同</span></span><br><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD fileA</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="GitHub实用指南"><a href="#GitHub实用指南" class="headerlink" title="GitHub实用指南"></a>GitHub实用指南</h1><ul><li>在GitHub上，可以任意Fork开源仓库；</li><li>自己拥有Fork后的仓库的读写权限；</li><li>可以推送pull request给官方仓库来贡献代码。</li><li>Github账户注册和新建项目，项目必须要遵守格式：<code>账户名.github.io</code>，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README（<strong>仅限博客</strong>）</li><li>GitHub创建仓库最好不要用中文,路径也是</li></ul><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><ul><li>GitHub Pages is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository.</li></ul><h1 id="查询资料"><a href="#查询资料" class="headerlink" title="查询资料"></a>查询资料</h1><ul><li><a href="http://iissnan.com/progit/" target="_blank" rel="noopener">Pro git</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git 教程-廖雪峰</a></li></ul>]]></content>
    
    <summary type="html">
    
      🎈
    
    </summary>
    
      <category term="git" scheme="BestQwerty.github.io/categories/git/"/>
    
    
      <category term="git" scheme="BestQwerty.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客网页访问量与访客计数问题</title>
    <link href="BestQwerty.github.io/2019/04/20/hexo%E5%8D%9A%E5%AE%A2%E7%BD%91%E9%A1%B5%E8%AE%BF%E9%97%AE%E9%87%8F%E4%B8%8E%E8%AE%BF%E5%AE%A2%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>BestQwerty.github.io/2019/04/20/hexo博客网页访问量与访客计数问题/</id>
    <published>2019-04-20T12:25:30.000Z</published>
    <updated>2019-04-20T12:34:34.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问量解决"><a href="#访问量解决" class="headerlink" title="访问量解决"></a>访问量解决</h1><ul><li>busuanzi域名改了⛷🏂<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      ⛹
    
    </summary>
    
      <category term="blog" scheme="BestQwerty.github.io/categories/blog/"/>
    
      <category term="博客优化" scheme="BestQwerty.github.io/categories/blog/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="blog" scheme="BestQwerty.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>非算法题题解</title>
    <link href="BestQwerty.github.io/2019/04/20/%E9%9D%9E%E7%AE%97%E6%B3%95%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <id>BestQwerty.github.io/2019/04/20/非算法题题解/</id>
    <published>2019-04-20T11:09:02.000Z</published>
    <updated>2019-05-18T13:07:40.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学题"><a href="#数学题" class="headerlink" title="数学题"></a>数学题</h1><ul><li><p>小明用字母A 对应数字1，B 对应2，以此类推，用Z 对应26。对于27以上的数字，小明用两位或更长位的字符串来对应，例如AA 对应27，AB 对应28，AZ 对应52，LQ 对应329。请问2019 对应的字符串是什么？</p><ul><li>用ABCD替换掉了1234, 注意26个字母应该是逢27进1, 也就是27进制, 而不是26进制<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">%法一</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = n%r;</span><br><span class="line">        n = (n<span class="number">-1</span>)/r;    <span class="comment">//不是26进制</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">0</span>) t = <span class="number">26</span>;</span><br><span class="line">        ret += <span class="string">'A'</span>+t<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">string</span> ans = solve(n, <span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ans.length()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%法二</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//702 --&gt; ZZ</span></span><br><span class="line"><span class="comment">//703 --&gt; AAA</span></span><br><span class="line"><span class="comment">//18278 --&gt; ZZZ</span></span><br><span class="line"><span class="comment">//18279 --&gt; AAAA</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">26</span>) dfs((N - <span class="number">1</span>) / <span class="number">26</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'A'</span> + (N - <span class="number">1</span>) % <span class="number">26</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N) &#123;</span><br><span class="line">        dfs(N); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>n转r进制的模板<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ans[maxn], index = <span class="number">0</span>;</span><br><span class="line">    ms(ans, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = n%r;</span><br><span class="line">        n /= r;</span><br><span class="line">        <span class="keyword">if</span>(t &gt; <span class="number">9</span>)</span><br><span class="line">            ans[index++] = (t<span class="number">-10</span>+<span class="string">'A'</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans[index++] = (t+<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从后往前输出</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>给定数列1, 1, 1, 3, 5, 9, 17, …，从第4 项开始，每项都是前3 项的和。求第20190324 项的最后4 位数字。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%一</span></span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = <span class="number">30000000</span>;</span><br><span class="line">int a[MAXN];</span><br><span class="line">int main() &#123;</span><br><span class="line">    int N = <span class="number">20190324</span>;</span><br><span class="line">    a[<span class="number">1</span>] = a[<span class="number">2</span>] = a[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">4</span>; <span class="built_in">i</span> &lt;= N; ++<span class="built_in">i</span>)</span><br><span class="line">        a[<span class="built_in">i</span>] = (a[<span class="built_in">i</span> - <span class="number">1</span>] + a[<span class="built_in">i</span> - <span class="number">2</span>] + a[<span class="built_in">i</span> - <span class="number">3</span>]) <span class="comment">% 10000;</span></span><br><span class="line">    printf(<span class="string">"%d\n"</span>, a[N]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%二</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    int N = 20190324;   //scanf("%d", &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">4</span>; <span class="built_in">i</span> &lt;= N; ++<span class="built_in">i</span>) &#123;</span><br><span class="line">        int t = (a + b + c) <span class="comment">% 10000;</span></span><br><span class="line">        c = b; </span><br><span class="line">        b = a;</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>把2019 分解成3 个各不相同的正整数之和，并且要求每个正整数都不包含数字 2 和 4，一共有多少种不同的分解方法？注意交换3个整数的顺序被视为同一种方法，例如1000+1001+18 和 1001+1000+18 被视为同一种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOK</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="comment">/* */</span>; x &gt; <span class="number">0</span>; x /= <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">10</span> == <span class="number">2</span> || x % <span class="number">10</span> == <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">2019</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N / <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (isOK(i))</span><br><span class="line">            <span class="comment">//k = N - i - j &gt; j</span></span><br><span class="line">            <span class="comment">//判断重复可以i &lt; j &lt; k, 然后判断i, j, k是否含2和4就行了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; N - i - j &gt; j; ++j)</span><br><span class="line">                <span class="keyword">if</span> (isOK(j) &amp;&amp; isOK(N - i - j)) ++cnt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导0），在1 到 40 中这样的数包括1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。请问，在 1 到n 中，所有这样的数的和是多少？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOK</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="comment">/* */</span>; x &gt; <span class="number">0</span>; x /= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (t % <span class="number">10</span> == <span class="number">2</span> || t % <span class="number">10</span> == <span class="number">0</span> || t % <span class="number">10</span> == <span class="number">1</span> || t % <span class="number">10</span> == <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">if</span> (isOK(i)) ret += i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>奕奕的几何很差，然而奕奕并不承认，所以华华扔给奕奕一道题目。如图：      已知大半圆的半径等于两个小半圆半径之和。若给出红色部分的面积，那么大圆的半径最小是多少呢？反正奕奕是不会的，所以现在请你回答。</p><ul><li>链接：<a href="https://ac.nowcoder.com/acm/contest/894/A" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/894/A</a><br>来源：牛客网</li><li>精度问题，因为刚开始使用pi = 3.1415，通过很少样例，然后改用3.14159265，通过的多一些，之后改用acos(-1)通过更多，然后因为s刚开始为int型，所以后改用为double类型，才通过所有样例</li><li>注意.3lf输出时，用四舍五入，该题精度有四舍五入<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.14259265</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;s);</span><br><span class="line">    r =<span class="built_in">sqrt</span>( <span class="number">4</span>*s/<span class="built_in">acos</span>(<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf"</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      🙄
    
    </summary>
    
    
      <category term="题解" scheme="BestQwerty.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
