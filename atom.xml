<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LjJiaJun&#39; Home</title>
  
  <subtitle>书青春 - 话人生 | Coding - Thinking - Acting</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="ctguljj.github.io/"/>
  <updated>2019-04-09T15:14:01.262Z</updated>
  <id>ctguljj.github.io/</id>
  
  <author>
    <name>LjJiaJun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数学期望</title>
    <link href="ctguljj.github.io/2019/04/09/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/"/>
    <id>ctguljj.github.io/2019/04/09/数学期望/</id>
    <published>2019-04-09T15:05:42.000Z</published>
    <updated>2019-04-09T15:14:01.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h1><ul><li><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/数学期望.jpg" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学期望&quot;&gt;&lt;a href=&quot;#数学期望&quot; class=&quot;headerlink&quot; title=&quot;数学期望&quot;&gt;&lt;/a&gt;数学期望&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ctguljj/ctgu
      
    
    </summary>
    
      <category term="数学" scheme="ctguljj.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数学期望" scheme="ctguljj.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/"/>
    
    
      <category term="数学" scheme="ctguljj.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>砝码组合</title>
    <link href="ctguljj.github.io/2019/04/08/%E7%A0%9D%E7%A0%81%E7%BB%84%E5%90%88/"/>
    <id>ctguljj.github.io/2019/04/08/砝码组合/</id>
    <published>2019-04-08T15:30:58.000Z</published>
    <updated>2019-04-08T15:30:58.619Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>递归与迭代</title>
    <link href="ctguljj.github.io/2019/04/06/%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3/"/>
    <id>ctguljj.github.io/2019/04/06/递归与迭代/</id>
    <published>2019-04-06T11:20:16.000Z</published>
    <updated>2019-04-06T12:06:41.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h1><ul><li>递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。</li><li>能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出./<em>相对</em>/</li><li>迭代是从远到近，不断逼近answer<ul><li>利用变量的原值推算出变量的一个新值，迭代就是A不停的调用B.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递归与迭代&quot;&gt;&lt;a href=&quot;#递归与迭代&quot; class=&quot;headerlink&quot; title=&quot;递归与迭代&quot;&gt;&lt;/a&gt;递归与迭代&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。&lt;/li&gt;
&lt;li&gt;能用迭代的不用递归,递
      
    
    </summary>
    
      <category term="c++" scheme="ctguljj.github.io/categories/c/"/>
    
      <category term="递归与迭代" scheme="ctguljj.github.io/categories/c/%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3/"/>
    
    
      <category term="c++" scheme="ctguljj.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>二进制与位运算</title>
    <link href="ctguljj.github.io/2019/04/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>ctguljj.github.io/2019/04/06/二进制与位运算/</id>
    <published>2019-04-06T08:04:52.000Z</published>
    <updated>2019-04-06T13:20:12.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算与乘除法的换算"><a href="#位运算与乘除法的换算" class="headerlink" title="位运算与乘除法的换算"></a>位运算与乘除法的换算</h1><ul><li>说明：<br>（1）位运算符中除 ~ 外，均为二目运算符，即要求出侧各有一个运算量。<br>（2）运算早只能是整型或字符型的数据，不能为实型数据。</li><li>使用位移运算可以提高因乘除运算带来的效率的问题，它的缺点是存在精度损失且不直观。</li><li>使用移位运算来避免乘法运算是一种常用技巧，不过乘数必须都是正整数，而且必须至少有一个是 2 的 n 次方，例如：2，4，8，16，32……移位运算的特点是速度快，而乘法运算速度较慢，把乘法运算转化为移位运算可以稍微提高程序运行效率。</li><li>例题1：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="number">12</span> * <span class="number">2</span> = <span class="number">12</span> &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="number">12</span> * <span class="number">4</span> = <span class="number">12</span> &lt;&lt; <span class="number">2</span></span><br><span class="line"><span class="number">12</span> * <span class="number">8</span> = <span class="number">12</span> &lt;&lt; <span class="number">3</span></span><br><span class="line"><span class="number">12</span> * <span class="number">16</span> = <span class="number">12</span> &lt;&lt; <span class="number">4</span></span><br><span class="line"><span class="number">12</span> * <span class="number">32</span> = <span class="number">12</span> &lt;&lt; <span class="number">5</span></span><br><span class="line"><span class="number">12</span> * <span class="number">64</span> = <span class="number">12</span> &lt;&lt; <span class="number">6</span></span><br><span class="line"><span class="number">12</span> * <span class="number">128</span> = <span class="number">12</span> &lt;&lt; <span class="number">7</span></span><br><span class="line"><span class="number">12</span> * <span class="number">256</span> = <span class="number">12</span> &lt;&lt; <span class="number">8</span></span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="number">12</span> / <span class="number">2</span> = <span class="number">12</span> &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="number">12</span> / <span class="number">4</span> = <span class="number">12</span> &gt;&gt; <span class="number">2</span></span><br><span class="line"><span class="number">12</span> / <span class="number">8</span> = <span class="number">12</span> &gt;&gt; <span class="number">3</span></span><br><span class="line"><span class="number">12</span> / <span class="number">16</span> = <span class="number">12</span> &gt;&gt; <span class="number">4</span></span><br><span class="line"><span class="number">12</span> / <span class="number">32</span> = <span class="number">12</span> &gt;&gt; <span class="number">5</span></span><br><span class="line"><span class="number">12</span> / <span class="number">64</span> = <span class="number">12</span> &gt;&gt; <span class="number">6</span></span><br><span class="line"><span class="number">12</span> / <span class="number">128</span> = <span class="number">12</span> &gt;&gt; <span class="number">7</span></span><br><span class="line"><span class="number">12</span> / <span class="number">256</span> = <span class="number">12</span> &gt;&gt; <span class="number">8</span></span><br><span class="line"><span class="comment">//其它</span></span><br><span class="line">num *= <span class="number">32</span>;  </span><br><span class="line"><span class="comment">//等同于 </span></span><br><span class="line">num &lt;&lt;= <span class="number">5</span>; </span><br><span class="line"><span class="comment">/* 2 的 5 次方等于 32 */</span> </span><br><span class="line"><span class="comment">//如果乘数不是 2 的 n 次方，我们可以把乘数分解成几个 2 的 n 次方的和：</span></span><br><span class="line"> num *= <span class="number">20</span>;</span><br><span class="line"><span class="comment">//等于</span></span><br><span class="line"> num *= (<span class="number">16</span> + <span class="number">4</span>);</span><br><span class="line"><span class="comment">//等于</span></span><br><span class="line"> num = num * <span class="number">16</span> + num * <span class="number">4</span>;</span><br><span class="line"><span class="comment">//等于</span></span><br><span class="line">num = (num &lt;&lt; <span class="number">4</span>) + (num &lt;&lt; <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><ul><li>原码:指一个二进制数左边加上符号位后所得到的码，且当二进制数大于0时，符号位为0；二进制数小于0时，符号位为1；二进制数等于0时，符号位可以为0或1</li><li>反码：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</li><li>补码：正数的补码与原码相同，负数的补码是其对应正数二进制所有位取反后加1。</li><li><strong>在计算机中通常使用补码进行储存</strong>。</li><li>二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数</li></ul><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="“-”运算"><a href="#“-”运算" class="headerlink" title="“~”运算"></a>“~”运算</h2><p>又称取反运算，就是对一个二进制数按位取反。<br>对于 int 来说，<code>~x = −x−1</code></p><h2 id="“-amp-”运算"><a href="#“-amp-”运算" class="headerlink" title="“&amp;”运算"></a>“&amp;”运算</h2><ul><li>“&amp;”运算，即“and” 运算，也是一种逻辑运算符，对于二进制运算来说，“&amp;”运算的意义是对于两个二进制数的每一位，除了11得1，其他均为0</li><li>可以用 &amp; 运算判断一个数是奇数还是偶数，当 x 为奇数时， x 二进制下的第 0 位一定是 1 ，否则为 0 。我们让<code>x &amp; 1</code>，就可以知道 x 的奇偶性了。<ul><li>&amp;<strong>运算通常用于二进制取位操作</strong>，例如一个数 &amp;1的结果就是<strong>取</strong>二进制的<strong>最末位</strong>。所以可以用来判断奇偶性</li><li>举个栗子：<code>10101(21) &amp; 11100(28) = 10100{20}</code></li></ul></li><li>如果参加 &amp; 是负数（<code>-3 &amp; -5</code>），则以补码形式表示为二进制数。然后按位进行 与 运算。<h2 id="“-”-运算"><a href="#“-”-运算" class="headerlink" title="“|” 运算"></a>“|” 运算</h2></li><li>即 “or” 运算，也是一种逻辑运算符，对于二进制运算来说，“|” 运算的意义是对于两个二进制数的每一位，除了00得0，其它都是1<ul><li>举个栗子：<code>10101(21) | 11100(28) = 11101(29)</code></li></ul></li><li>通过与运算和或运算的栗子可以观察到一下规律：<code>x &amp; y&lt;=x</code>和<code>x | y&gt;=x</code></li></ul><h1 id="“-”运算-1"><a href="#“-”运算-1" class="headerlink" title="“^”运算"></a>“^”运算</h1><ul><li>“^”运算，又称“xor”运算，异或运算。定义是对于两个二进制数的每一位，相同为0，不同为1<ul><li>举个栗子：<code>10101(21) ^ 11100(28) = 1001(9)</code></li></ul></li><li>对于一个形如2∗n 的数 x， <code>x ^ 1=x+1</code>,而对于一个形如 2∗n+1的数x，<code>x ^ 1=x−1</code></li><li>异或运算的妙用：<ul><li>0^0=0,0^1=1 可理解为：0异或任何数，其结果=任何数</li><li>1^0=1,1^1=0 可理解为： 1异或任何数，其结果=任何数取反</li><li>任何数异或自己，等于把自己置0</li><li>异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a.</li><li>如果 x ^ y=z 那么 y ^ z=x， x ^ z=y </li><li>a xor c == b xor c 则 a == b</li><li>a ^ b = b ^ a</li><li>a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c; </li><li>d = a ^ b ^ c 可以推出 a = d ^ b ^ c. </li><li>a ^ b ^ a = b.</li><li>(a xor b） xor b = a;</li><li>由于xor满足交换律，所以上述特性这样表述也是对的：<ul><li>(b xor a) xor b = a;</li><li>b xor (a xor b) = a;<h2 id="交换2个数"><a href="#交换2个数" class="headerlink" title="交换2个数"></a>交换2个数</h2></li></ul></li></ul></li><li>不借助中间变量，交换两个数有以下方法👇</li><li><p><span id="inline-toc">1.</span> 相互加减</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = a + b;         <span class="comment">//但是加法可能导致溢出</span></span><br><span class="line">b = a - b;       <span class="comment">//x和y同号的情况下容易溢出</span></span><br><span class="line">a = a - b;</span><br><span class="line"></span><br><span class="line">x=x-y;    <span class="comment">//x和y异号的情况下容易溢出</span></span><br><span class="line">y=x+y;</span><br><span class="line">x=y-x;</span><br></pre></td></tr></table></figure></li><li><p><span id="inline-toc">2.</span>异或运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br><span class="line"><span class="comment">//可简写为如下</span></span><br><span class="line">b ^= a ^= b ^= a;</span><br></pre></td></tr></table></figure></li><li><p>这东西理论上能比正常的交换优一点，当然还是用 swap 吧，毕竟人家什么都能换，这个只能换整数。</p><h2 id="找出2n-1个数中不成对的数"><a href="#找出2n-1个数中不成对的数" class="headerlink" title="找出2n+1个数中不成对的数"></a>找出2n+1个数中不成对的数</h2></li><li>给出n个数，其中有且仅有一个出现了奇数次，其余的都出现了偶数次。用线性时间常数空间找出这个出现奇数次的数<a href="http://www.cnblogs.com/kaituorensheng/archive/2013/04/04/3000033.html" target="_blank" rel="noopener">原</a><br>-<br><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/异或运算.png" alt=""><h2 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h2><h2 id="快速判断奇偶性"><a href="#快速判断奇偶性" class="headerlink" title="快速判断奇偶性"></a>快速判断奇偶性</h2></li><li>上面有<h2 id="在状压情况下的操作"><a href="#在状压情况下的操作" class="headerlink" title="在状压情况下的操作"></a>在状压情况下的操作</h2><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h1 id="位运算的优先级"><a href="#位运算的优先级" class="headerlink" title="位运算的优先级"></a>位运算的优先级</h1></li><li>位运算的优先级，大致按下面排序<ul><li>加减运算 &gt; 移位运算 &gt; 比较大小运算 &gt; 与运算 &gt; 异或运算 &gt; 或运算</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;位运算与乘除法的换算&quot;&gt;&lt;a href=&quot;#位运算与乘除法的换算&quot; class=&quot;headerlink&quot; title=&quot;位运算与乘除法的换算&quot;&gt;&lt;/a&gt;位运算与乘除法的换算&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;说明：&lt;br&gt;（1）位运算符中除 ~ 外，均为二目运算符，即要求
      
    
    </summary>
    
      <category term="c++" scheme="ctguljj.github.io/categories/c/"/>
    
      <category term="二进制与位运算" scheme="ctguljj.github.io/categories/c/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
      <category term="c++" scheme="ctguljj.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="ctguljj.github.io/2019/04/06/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>ctguljj.github.io/2019/04/06/快速幂/</id>
    <published>2019-04-06T08:04:09.000Z</published>
    <updated>2019-04-09T15:10:21.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><ul><li><a href="http://www.cnblogs.com/CXCXCXC/p/4641812.html" target="_blank" rel="noopener">直接看吧</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速幂&quot;&gt;&lt;a href=&quot;#快速幂&quot; class=&quot;headerlink&quot; title=&quot;快速幂&quot;&gt;&lt;/a&gt;快速幂&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/CXCXCXC/p/4641812.html&quot; targ
      
    
    </summary>
    
      <category term="算法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="快速幂" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速幂题解</title>
    <link href="ctguljj.github.io/2019/04/06/%E5%BF%AB%E9%80%9F%E5%B9%82%E9%A2%98%E8%A7%A3/"/>
    <id>ctguljj.github.io/2019/04/06/快速幂题解/</id>
    <published>2019-04-06T07:54:32.000Z</published>
    <updated>2019-04-06T13:44:45.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ac-nowcoder"><a href="#ac-nowcoder" class="headerlink" title="ac.nowcoder"></a>ac.nowcoder</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li>题目描述:立华奏在学习初中数学的时候遇到了这样一道大水题： “设箱子内有 n 个球，其中给 m 个球打上标记，设一次摸球摸到每一个球的概率均等，求一次摸球摸到打标记的球的概率” “emmm…语言入门题” 但是她改了一下询问方式：设最终的答案为 p ,请输出 p 小数点后 K1 到 K2 位的所有数字（若不足则用 0 补齐）</li><li>输入描述:第一行一个整数 T,表示有 T 组数据。接下来每行包含四个整数 m,n,K1,K2，意义如「题目描述」所示。<ul><li>1≤m≤n≤10的9次方,1≤K1≤K2≤10的9次方、0≤K2−K1≤10的5次方，T≤20。</li></ul></li><li>输出描述:输出 T 行，每行输出 K2−K1+1个数，表示答案。注意同行的数字中间不需要用空格隔开。</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li>不用从头开始模拟，只需要从 K1 位开始模拟就可以了。 直接通过快速幂+取模算出第 K1位的数字。然后我们发现 K2−K1≤10的5次方，所以暴力枚举除法过程就可以。 时间复杂度 O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ac-nowcoder&quot;&gt;&lt;a href=&quot;#ac-nowcoder&quot; class=&quot;headerlink&quot; title=&quot;ac.nowcoder&quot;&gt;&lt;/a&gt;ac.nowcoder&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;head
      
    
    </summary>
    
      <category term="算法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="快速幂" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
      <category term="题解" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算几何初步</title>
    <link href="ctguljj.github.io/2019/04/05/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%88%9D%E6%AD%A5/"/>
    <id>ctguljj.github.io/2019/04/05/计算几何初步/</id>
    <published>2019-04-05T09:52:58.000Z</published>
    <updated>2019-04-05T09:52:58.930Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二分抽签算法分析</title>
    <link href="ctguljj.github.io/2019/04/05/%E4%BA%8C%E5%88%86%E6%8A%BD%E7%AD%BE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>ctguljj.github.io/2019/04/05/二分抽签算法分析/</id>
    <published>2019-04-05T08:41:59.000Z</published>
    <updated>2019-04-08T10:26:21.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法课"><a href="#算法课" class="headerlink" title="算法课"></a>算法课</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*你的朋友提议玩一个游戏：将写有数字的n个纸片放入口袋中．你可以从口袋中抽取4次纸片，每次记下纸片上的数字后都将其放回口袋中如果这4个数字的和是m，就是你赢，否则就是你的朋友赢。你挑战了好几回，结果一次也没赢过，于是怒而撕破口袋，取出所有纸片，检查自己是否真的有赢的可能性。请你编写一个程序，判断当纸片上所写的数字是k1，k2，…，kn时，是否存在抽取4次和为m的方案。如果存在，输出彻；否则，输出NO.</span></span><br><span class="line"><span class="comment">限制条件:   1≤n ≤ 50;   1 ≤ m ≤ 10^8;   1 ≤ Ki ≤ 10^8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入样例： 3 10 1 3 5             (格式-n,m, k1,k2,..kn)</span></span><br><span class="line"><span class="comment">输出样例：YES</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入样例：3 9 1 3 5 </span></span><br><span class="line"><span class="comment">输出样例：NO</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kk[<span class="number">1000000</span>];<span class="comment">//开大点防止爆掉        </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n*n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(kk[k] == b)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( m &gt;kk[k])</span><br><span class="line">            left = k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = k;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>  ( j=<span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            kk[i*n + j] = a[i]+a[j];<span class="comment">//枚举组合</span></span><br><span class="line">    sort(kk, kk+n*n); </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( bs(m-a[i]-a[j]) )&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法课&quot;&gt;&lt;a href=&quot;#算法课&quot; class=&quot;headerlink&quot; title=&quot;算法课&quot;&gt;&lt;/a&gt;算法课&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
      <category term="算法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
      <category term="题解" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>matlab常用函数之mean</title>
    <link href="ctguljj.github.io/2019/04/04/matlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bmean/"/>
    <id>ctguljj.github.io/2019/04/04/matlab常用函数之mean/</id>
    <published>2019-04-04T13:18:25.000Z</published>
    <updated>2019-04-04T13:21:58.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mean-数组的均值"><a href="#mean-数组的均值" class="headerlink" title="mean(数组的均值)"></a>mean(数组的均值)</h1><ul><li>调用格式:<ul><li><code>M = mean(A)</code>返回 A 沿大小不等于 1 的第一个数组维度的元素的均值。<ul><li>如果 A 是向量，则<code>mean(A)</code>返回元素均值。</li><li>如果 A 为矩阵，那么 <code>mean(A)</code> 返回包含每列均值的行向量。</li><li>如果 A 是多维数组，则 <code>mean(A)</code> 沿大小不等于 1 的第一个数组维度计算，并将这些元素视为向量。此维度会变为 1，而所有其他维度的大小保持不变。</li></ul></li><li><code>M = mean(A,&#39;all&#39;)</code>计算 A 的所有元素的均值。</li><li><code>M = mean(A,dim)</code>返回维度 dim 上的均值。例如，如果 A 为矩阵，则 <code>mean(A,2)</code> 是包含每一行均值的列向量。</li><li><code>M = mean(A,vecdim)</code>计算向量 vecdim 所指定的维度上的均值。例如，如果 A 是矩阵，则 <code>mean(A,[1 2])</code>是 A 中所有元素的均值，因为矩阵的每个元素都包含在由维度 1 和 2 定义的数组切片中。</li><li><code>M = mean(___,outtype)</code>使用前面语法中的任何输入参数返回指定的数据类型的均值。outtype 可以是 ‘default’、’double’ 或 ‘native’。</li><li><code>M = mean(___,nanflag)</code>指定在上述任意语法的计算中包括还是忽略 NaN 值。<code>mean(A,&#39;includenan&#39;)</code> 会在计算中包括所有 NaN 值，而 <code>mean(A,&#39;omitnan&#39;)</code> 则忽略这些值。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mean-数组的均值&quot;&gt;&lt;a href=&quot;#mean-数组的均值&quot; class=&quot;headerlink&quot; title=&quot;mean(数组的均值)&quot;&gt;&lt;/a&gt;mean(数组的均值)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;调用格式:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M = mean(A
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="函数" scheme="ctguljj.github.io/categories/matlab/%E5%87%BD%E6%95%B0/"/>
    
      <category term="mean" scheme="ctguljj.github.io/categories/matlab/%E5%87%BD%E6%95%B0/mean/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab常用函数之rem</title>
    <link href="ctguljj.github.io/2019/04/04/matlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Brem/"/>
    <id>ctguljj.github.io/2019/04/04/matlab常用函数之rem/</id>
    <published>2019-04-04T01:12:04.000Z</published>
    <updated>2019-04-04T12:44:32.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h1><ul><li>调用格式:<code>r = rem(a,b)</code></li><li><code>r = rem(a,b)</code>返回a除以b后的余数，其中a为被除数，b为除数。这个操作在概念上等于<code>r = a - b.*fix(a./b)</code>，它使用与mod函数不同的舍入。rem函数遵循<code>rem(a,0)</code>为NaN的约定。</li><li><p>例题:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>:<span class="number">5</span>;</span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line">r = <span class="built_in">rem</span>(a,b)</span><br><span class="line">r =</span><br><span class="line"> <span class="number">1</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p><code>rem(a,b)</code>finds the remainder after division. If b &lt;&gt; 0, then <code>rem(a,b) = a - fix(a/b)*b</code>. If b = 0 or b = Inf or b = -Inf, then rem returns NaN.<br>The rem function does not support complex numbers: all values must be real numbers.<br>To find the remainder after division of polynomials, use quorem.</p></li><li>当正数与负数取余时，当得到的余数结果的符号希望跟除数(x)一样，用<code>rem()</code>函数；当得到的余数结果的符号希望跟被除数(y)一样，用<code>mod()</code>函数</li><li><code>mod(x,y)</code>与y同号，<code>rem(x,y)</code>与x同号</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rem&quot;&gt;&lt;a href=&quot;#rem&quot; class=&quot;headerlink&quot; title=&quot;rem&quot;&gt;&lt;/a&gt;rem&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;调用格式:&lt;code&gt;r = rem(a,b)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r = rem(a,b)&lt;/
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="函数" scheme="ctguljj.github.io/categories/matlab/%E5%87%BD%E6%95%B0/"/>
    
      <category term="rem" scheme="ctguljj.github.io/categories/matlab/%E5%87%BD%E6%95%B0/rem/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab函数之rand及其相关函数</title>
    <link href="ctguljj.github.io/2019/04/03/matlab%E5%87%BD%E6%95%B0%E4%B9%8Brand/"/>
    <id>ctguljj.github.io/2019/04/03/matlab函数之rand/</id>
    <published>2019-04-03T13:42:32.000Z</published>
    <updated>2019-04-03T14:34:07.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h1><ul><li>matlab中通过rand函数产生的是介于0到1(不包括1)之间的伪随机数 </li><li><code>X = rand</code>范围(0,1).</li><li><code>X = rand(n)</code>表示产生一个n×n的随机矩阵，n必须是整数,否则会报错。</li><li><code>X = rand(sz1,...,szN)</code></li><li><code>X = rand(sz)</code></li><li><code>X = rand(___,typename)</code></li><li><code>X = rand(___,&#39;like&#39;,p)</code></li><li>可以与取整函数搭配使用</li><li>为了使每次执行rand函数时产生和之前不相同的一组伪随机数，通常需要初始化随机数种子。方法很多， 常见的一种是在写m文件时，在程序的开头写：<code>rand(&#39;state&#39;,sum(100*clock))</code> 定义一个随时间变化的初值。</li></ul><h1 id="randi"><a href="#randi" class="headerlink" title="randi"></a>randi</h1><ul><li>randi函数产生均匀分布的伪随机整数(Uniformly distributed pseudorandom integers)</li><li><code>X = randi(imax)</code>返回一个介于1到imax的伪随机整数</li><li><code>X = randi(imax,n)</code>返回一个在[1,imax]范围内的n*n的伪随机整数矩阵</li><li><code>X = randi(imax,sz1,...,szN)</code></li><li><code>X = randi(imax,sz)</code></li><li><code>X = randi(imax,classname)</code></li><li><code>X = randi(imax,n,classname)</code></li><li><code>X = randi(imax,sz1,...,szN,classname)</code></li><li><code>X = randi(imax,sz,classname)</code></li><li><code>X = randi(imax,&#39;like&#39;,p)</code></li><li><code>X = randi(imax,n,&#39;like&#39;,p)</code></li><li><code>X = randi(imax,sz1,...,szN,&#39;like&#39;,p)</code></li><li><code>X = randi(imax,sz,&#39;like&#39;,p)</code></li><li><code>X = randi([imin,imax],___)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rand&quot;&gt;&lt;a href=&quot;#rand&quot; class=&quot;headerlink&quot; title=&quot;rand&quot;&gt;&lt;/a&gt;rand&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;matlab中通过rand函数产生的是介于0到1(不包括1)之间的伪随机数 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;X 
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="函数" scheme="ctguljj.github.io/categories/matlab/%E5%87%BD%E6%95%B0/"/>
    
      <category term="rand及其相关函数" scheme="ctguljj.github.io/categories/matlab/%E5%87%BD%E6%95%B0/rand%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab常用函数之num2str与str2num</title>
    <link href="ctguljj.github.io/2019/04/03/matlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bnum2str%E4%B8%8Estr2num/"/>
    <id>ctguljj.github.io/2019/04/03/matlab常用函数之num2str与str2num/</id>
    <published>2019-04-03T12:08:27.000Z</published>
    <updated>2019-04-03T12:24:47.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="num2str"><a href="#num2str" class="headerlink" title="num2str"></a>num2str</h1><ul><li>调用格式:<ul><li><code>s = num2str(A)</code></li><li><code>s = num2str(A,precision)</code>precision: Maximum number of significant digits.把数组A转换成字符串形式表示，precision表示精度， 比如precision为3表示保留最多3位有效数字</li><li><code>s = num2str(A,formatSpec)</code> formatspec: Format of output fields.按format指定格式进行格式化转换，通常’%11.4g’是默认的。</li></ul></li></ul><h1 id="str2num"><a href="#str2num" class="headerlink" title="str2num"></a>str2num</h1><ul><li>调用格式:<ul><li><code>x = str2num(&#39;str&#39;)</code>str是一个ASCII字符串表示的数值， 这种调用格式把字符串转换成数值。str也可以是一个字符串矩阵， 这种情况下， 字符串矩阵被转换成一个数值矩阵。</li><li><code>[x, status] = str2num(&#39;str&#39;)</code>附加的返回值status用于获取转换状态， status等于逻辑1表示转换成功， 等于0表示转换失败。<ul><li>例题：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> str2num(&apos;2 4 6 8&apos;)              % Separate with spaces.</span><br><span class="line"> ans =</span><br><span class="line">       2     4     6     8</span><br><span class="line"></span><br><span class="line"> str2num(&apos;2,4,6,8&apos;)              % Separate with commas.</span><br><span class="line"> ans =</span><br><span class="line">      2     4     6     8</span><br><span class="line"></span><br><span class="line">  str2num(&apos;[2 4 6 8]&apos;)            % Enclose in brackets.</span><br><span class="line"> ans =</span><br><span class="line">      2     4     6     8 </span><br><span class="line">str2num(&apos;2; 4; 6; 8&apos;)</span><br><span class="line">ans =</span><br><span class="line">    2</span><br><span class="line">    4</span><br><span class="line">    6</span><br><span class="line">    8</span><br><span class="line">And now a 2-by-2 matrix:</span><br><span class="line"></span><br><span class="line">str2num(&apos;2 4; 6 8&apos;)</span><br><span class="line">ans =</span><br><span class="line">    2     4</span><br><span class="line">    6     8</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;num2str&quot;&gt;&lt;a href=&quot;#num2str&quot; class=&quot;headerlink&quot; title=&quot;num2str&quot;&gt;&lt;/a&gt;num2str&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;调用格式:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s = num2str(A)&lt;/code&gt;&lt;/l
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="函数" scheme="ctguljj.github.io/categories/matlab/%E5%87%BD%E6%95%B0/"/>
    
      <category term="str2num与num2str" scheme="ctguljj.github.io/categories/matlab/%E5%87%BD%E6%95%B0/str2num%E4%B8%8Enum2str/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>typora</title>
    <link href="ctguljj.github.io/2019/04/03/typora/"/>
    <id>ctguljj.github.io/2019/04/03/typora/</id>
    <published>2019-04-03T02:00:00.000Z</published>
    <updated>2019-04-03T04:00:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="typora简介"><a href="#typora简介" class="headerlink" title="typora简介"></a>typora简介</h1><ul><li><p>无论是Word中带有加粗等格式的文字，还是Excel中的表格，一旦黏贴到Typora中，都会被自动转化为对应的Markdown格式，所以你再也不用担心每次重新设置格式的麻烦了——Markdown最麻烦的表格也可以在Excel中做完再贴入生成了。</p></li><li><p><strong>专注模式</strong>，也就是除了正在编辑的那行文字，文章上下其余的内容全部变成灰色，不吸引你的视线，不干扰你的思维。</p><ul><li><strong>与专注模式搭配的话，当然还是全屏模式(F11)</strong>最好啦　qwq</li></ul></li><li><p><strong>打字机模式（Typewriter Mode）</strong>:开启这种模式后，Typora 的光标所在行会始终保持在屏幕中间，这样你码字时眼睛可以一直正对着屏幕中间</p></li></ul><h2 id="打开-关闭源代码模式"><a href="#打开-关闭源代码模式" class="headerlink" title="打开/关闭源代码模式"></a>打开/关闭源代码模式</h2><ul><li><blockquote><p>typora默认界面是实时预览的模式,而这也是与其他Markdown软件较大的区别.切换成源代码模式可以更方便地修改内容</p></blockquote><ul><li>方法1:点击左下角的<code>&lt;/&gt;</code>(启用/关闭源代码模式)</li><li>方法2:Ctrl+/</li></ul></li></ul><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul><li>无序列表：输入-之后输入空格</li><li>有序列表：输入数字+“.”之后输入空格</li><li>任务列表：-[空格]空格 文字</li><li>标题：ctrl+数字</li><li>表格：ctrl+t</li><li>生成目录：[TOC]按回车</li><li>选中一整行：ctrl+l</li><li>选中单词：ctrl+d</li><li>选中相同格式的文字：ctrl+e</li><li>跳转到文章开头：ctrl+home</li><li>跳转到文章结尾：ctrl+end</li><li>搜索：ctrl+f</li><li>替换：ctrl+h</li><li>引用：输入&gt;之后输入空格</li><li>代码块：ctrl+alt+f</li><li>加粗：ctrl+b</li><li>倾斜：ctrl+i</li><li>下划线：ctrl+u</li><li>删除线：alt+shift+5</li><li>插入图片：直接拖动到指定位置即可或者ctrl+shift+i</li><li>插入链接：ctrl+k</li></ul><p>   ​        </p><p>参考文献：<a href="https://www.jianshu.com/p/602f6ecf48fd" target="_blank" rel="noopener">typora</a></p><p><a href="http://wwwbuild.net/seekingbeta_earl/358745.html" target="_blank" rel="noopener">typora2</a></p><p><a href="https://blog.csdn.net/it_guang/article/details/53456026" target="_blank" rel="noopener">typora快捷键</a></p><p><a href="https://blog.csdn.net/lzykevin/article/details/83276555" target="_blank" rel="noopener">typora界面入门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;typora简介&quot;&gt;&lt;a href=&quot;#typora简介&quot; class=&quot;headerlink&quot; title=&quot;typora简介&quot;&gt;&lt;/a&gt;typora简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;无论是Word中带有加粗等格式的文字，还是Excel中的表格，一旦黏贴到T
      
    
    </summary>
    
      <category term="markdown编辑器" scheme="ctguljj.github.io/categories/markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="typora" scheme="ctguljj.github.io/categories/markdown%E7%BC%96%E8%BE%91%E5%99%A8/typora/"/>
    
    
      <category term="markdown编辑器" scheme="ctguljj.github.io/tags/markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>markdownpad2使用技巧</title>
    <link href="ctguljj.github.io/2019/04/03/markdownpad2%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>ctguljj.github.io/2019/04/03/markdownpad2使用技巧/</id>
    <published>2019-04-03T02:00:00.000Z</published>
    <updated>2019-04-03T04:01:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdownpad2常用快捷键"><a href="#markdownpad2常用快捷键" class="headerlink" title="markdownpad2常用快捷键"></a>markdownpad2常用快捷键</h1><ul><li>Ctrl + I ： 斜体</li><li>Ctrl + B ： 粗体</li><li>Ctrl + G ： 图片</li><li>Ctrl + Q ： 引用</li><li>Ctrl + 1 ： 标题 1</li><li>Ctrl + 2 ： 标题 2</li><li>Ctrl + 3 ： 标题 3</li><li>Ctrl + K ： 代码块</li><li>Ctrl + L ： 超链接</li><li>Ctrl + T ： 时间戳</li><li>Ctrl + U ： 无序列表</li><li>Ctrl + R ： 水平标尺</li><li>F4 ： 启用水平布局</li><li>F5 ： 启用实时预览</li><li>F6 ： 在浏览器中预览</li><li>Ctrl + Shift + O ： 有序列表</li></ul><p>​                           </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;markdownpad2常用快捷键&quot;&gt;&lt;a href=&quot;#markdownpad2常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;markdownpad2常用快捷键&quot;&gt;&lt;/a&gt;markdownpad2常用快捷键&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Ctrl
      
    
    </summary>
    
      <category term="markdown编辑器" scheme="ctguljj.github.io/categories/markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="markdownpad2" scheme="ctguljj.github.io/categories/markdown%E7%BC%96%E8%BE%91%E5%99%A8/markdownpad2/"/>
    
    
      <category term="markdown编辑器" scheme="ctguljj.github.io/tags/markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>对matlab中diag函数的补充</title>
    <link href="ctguljj.github.io/2019/03/31/%E5%AF%B9matlab%E4%B8%ADdiag%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A5%E5%85%85/"/>
    <id>ctguljj.github.io/2019/03/31/对matlab中diag函数的补充/</id>
    <published>2019-03-31T13:43:27.000Z</published>
    <updated>2019-03-31T13:51:03.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="diag函数的补充"><a href="#diag函数的补充" class="headerlink" title="diag函数的补充"></a>diag函数的补充</h1><ul><li>A是矩阵，那么diag(A)得到的是主对角线上的元素构成的列向量，如果A是行列向量，那么得到的是矩阵（A为对角线元素，其他是0）</li><li><code>X = diag(v,k)</code><br>其中v是一个含有n个元素的向量，该调用格式可以构造一个n+abs(k)阶的方阵X。并把v作为方阵X的第k条对角线（k大于0，表示主对角线上方的第k条对角线，k小于0表示主对角线下侧的第k条对角线，k等于0表示主对线）。</li></ul><ul><li><code>X = diag(v)</code><br>等价于<code>X = diag(v,0)</code></li><li><code>v = diag(X,k)</code><br>以向量形式返回矩阵X中第k条对角线上的元素。</li><li><p><code>v = diag(X)</code><br>等价于<code>v = diag(X, 0)</code></p></li><li><p><code>D = diag(v)</code></p></li><li><code>D = diag(v,k)</code> 如果v为向量，那么当k&gt;0时，D就是v为主对角线以下第k条对角线构成的矩阵，其它元素均为0</li><li><code>x = diag(A)</code> </li><li><code>x = diag(A,k)</code>如果A为矩阵，那么当k&gt;0时，x就是矩阵A主对角线上第k条对角线上的元素构成的列向量 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;diag函数的补充&quot;&gt;&lt;a href=&quot;#diag函数的补充&quot; class=&quot;headerlink&quot; title=&quot;diag函数的补充&quot;&gt;&lt;/a&gt;diag函数的补充&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;A是矩阵，那么diag(A)得到的是主对角线上的元素构成的列向量，如果A
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="函数" scheme="ctguljj.github.io/categories/matlab/%E5%87%BD%E6%95%B0/"/>
    
      <category term="diag" scheme="ctguljj.github.io/categories/matlab/%E5%87%BD%E6%95%B0/diag/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>matlab实用命令</title>
    <link href="ctguljj.github.io/2019/03/31/matlab%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>ctguljj.github.io/2019/03/31/matlab实用命令/</id>
    <published>2019-03-31T07:33:32.000Z</published>
    <updated>2019-03-31T07:39:07.229Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在命令行敲入 <code>dbstop if error</code><br>如果运行出现错误，matlab会自动停在出错的那行，并且保存所有相关变量。再也不用设断点了有没有！！！<ul><li>若要取消，用<code>dbclear if error</code></li><li>现在版本在断点选项里自带</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;在命令行敲入 &lt;code&gt;dbstop if error&lt;/code&gt;&lt;br&gt;如果运行出现错误，matlab会自动停在出错的那行，并且保存所有相关变量。再也不用设断点了有没有！！！&lt;ul&gt;
&lt;li&gt;若要取消，用&lt;code&gt;dbclear if error&lt;/co
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="实用命令" scheme="ctguljj.github.io/categories/matlab/%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>第五周周总结</title>
    <link href="ctguljj.github.io/2019/03/30/%E7%AC%AC%E4%BA%94%E5%91%A8%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <id>ctguljj.github.io/2019/03/30/第五周周总结/</id>
    <published>2019-03-30T11:58:26.000Z</published>
    <updated>2019-03-30T12:12:31.069Z</updated>
    
    <summary type="html">
    
      something about myself
    
    </summary>
    
      <category term="五日三省吾身" scheme="ctguljj.github.io/categories/%E4%BA%94%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
      <category term="周总结" scheme="ctguljj.github.io/categories/%E4%BA%94%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="吾日三省吾身" scheme="ctguljj.github.io/tags/%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>matlab代码练习</title>
    <link href="ctguljj.github.io/2019/03/30/matlab%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/"/>
    <id>ctguljj.github.io/2019/03/30/matlab代码练习/</id>
    <published>2019-03-30T07:22:54.000Z</published>
    <updated>2019-03-30T12:18:52.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="S"><a href="#S" class="headerlink" title="S"></a>S</h1><p><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/matlabtimu.jpg" alt=""><br><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/matlabtimudaan.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;S&quot;&gt;&lt;a href=&quot;#S&quot; class=&quot;headerlink&quot; title=&quot;S&quot;&gt;&lt;/a&gt;S&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/mast
      
    
    </summary>
    
      <category term="matlab" scheme="ctguljj.github.io/categories/matlab/"/>
    
      <category term="代码练习" scheme="ctguljj.github.io/categories/matlab/%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="matlab" scheme="ctguljj.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>数据结构栈</title>
    <link href="ctguljj.github.io/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88/"/>
    <id>ctguljj.github.io/2019/03/30/数据结构栈/</id>
    <published>2019-03-30T06:29:43.000Z</published>
    <updated>2019-03-30T06:29:43.375Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c++stackk</title>
    <link href="ctguljj.github.io/2019/03/30/c-stackk/"/>
    <id>ctguljj.github.io/2019/03/30/c-stackk/</id>
    <published>2019-03-30T06:28:36.000Z</published>
    <updated>2019-03-30T06:34:27.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li>出栈，如例：<code>s.pop();</code>注意，出栈操作只是删除栈顶元素，并不返回该元素</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;出栈，如例：&lt;code&gt;s.pop();&lt;/code&gt;注意，出栈操作只是删除栈顶元素，并不返回该元素&lt;/li&gt;

      
    
    </summary>
    
      <category term="stl" scheme="ctguljj.github.io/categories/stl/"/>
    
      <category term="stack" scheme="ctguljj.github.io/categories/stl/stack/"/>
    
    
      <category term="stl" scheme="ctguljj.github.io/tags/stl/"/>
    
  </entry>
  
</feed>
