<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LjJiaJun&#39; Home</title>
  
  <subtitle>书青春 - 话人生 | Coding - Thinking - Acting</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="ctguljj.github.io/"/>
  <updated>2019-03-09T06:12:39.854Z</updated>
  <id>ctguljj.github.io/</id>
  
  <author>
    <name>LjJiaJun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>blog表格</title>
    <link href="ctguljj.github.io/2019/03/09/blog%E8%A1%A8%E6%A0%BC/"/>
    <id>ctguljj.github.io/2019/03/09/blog表格/</id>
    <published>2019-03-09T06:02:45.000Z</published>
    <updated>2019-03-09T06:12:39.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>| Tables        | Are           | Cool  |</p><p>| ————- |:————-:| —–:|</p><p>| col 3 is      | right-aligned | $1600 |</p><p>| col 2 is      | centered      |   $12 |</p><p>| zebra stripes | are neat      |    $1 |</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">b</th></tr></thead><tbody><tr><td style="text-align:center">c</td><td style="text-align:center">d</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;表格&quot;&gt;&lt;a href=&quot;#表格&quot; class=&quot;headerlink&quot; title=&quot;表格&quot;&gt;&lt;/a&gt;表格&lt;/h1&gt;&lt;p&gt;| Tables        | Are           | Cool  |&lt;/p&gt;
&lt;p&gt;| ————- |:————-:| —–:
      
    
    </summary>
    
      <category term="blog" scheme="ctguljj.github.io/categories/blog/"/>
    
      <category term="表格" scheme="ctguljj.github.io/categories/blog/%E8%A1%A8%E6%A0%BC/"/>
    
    
      <category term="blog" scheme="ctguljj.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>vector简介</title>
    <link href="ctguljj.github.io/2019/03/09/vector%E7%AE%80%E4%BB%8B/"/>
    <id>ctguljj.github.io/2019/03/09/vector简介/</id>
    <published>2019-03-09T06:00:32.000Z</published>
    <updated>2019-03-09T06:00:32.162Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>list列表</title>
    <link href="ctguljj.github.io/2019/03/08/list%E5%88%97%E8%A1%A8/"/>
    <id>ctguljj.github.io/2019/03/08/list列表/</id>
    <published>2019-03-08T12:48:34.000Z</published>
    <updated>2019-03-09T05:59:54.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li>#include ＜list＞</li></ul><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><ul><li>list同样是一个模板类，它底层数据结构为双向循环链表。因此，它支持任意位置常数时间的插入/删除操作，不支持快速随机访问。</li></ul><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ul><li>list的空间配置策略，自然是像我们普通双向链表那样，有多少元素申请多少内存。它不像vactor那样需要预留空间供新元素的分配，也不会因找不到连续的空间而引起整个容器的内存迁移。</li></ul><h2 id="迭代器失效问题"><a href="#迭代器失效问题" class="headerlink" title="迭代器失效问题"></a>迭代器失效问题</h2><ul><li>list 有一个重要性质：插入操作（insert）与接合操作（splice）都不会造成原有的list迭代器失效。这在vector是不成立的，因为vactor的插入可能引起空间的重新配置，导致原来的迭代器全部失效。list的迭代器失效，只会出现在删除的时候，指向删除元素的那个迭代器在删除后失效。<br>通常来说，<code>forward_list</code>在使用灵活度上比不上list，因为它只能单向迭代元素，且提供的接口没有list多。然而，在内存的使用上，它是比list占优势的。当对内存的要求占首要位置时，应该选择<code>forward_list</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;list&quot;&gt;&lt;a href=&quot;#list&quot; class=&quot;headerlink&quot; title=&quot;list&quot;&gt;&lt;/a&gt;list&lt;/h1&gt;&lt;h2 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=&quot;头文件&quot;&gt;&lt;/a&gt;头文
      
    
    </summary>
    
      <category term="stl" scheme="ctguljj.github.io/categories/stl/"/>
    
      <category term="list" scheme="ctguljj.github.io/categories/stl/list/"/>
    
    
      <category term="stl" scheme="ctguljj.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>reverse反转函数</title>
    <link href="ctguljj.github.io/2019/03/08/reverse%E5%8F%8D%E8%BD%AC%E5%87%BD%E6%95%B0/"/>
    <id>ctguljj.github.io/2019/03/08/reverse反转函数/</id>
    <published>2019-03-08T11:56:15.000Z</published>
    <updated>2019-03-08T12:00:25.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reverse函数"><a href="#reverse函数" class="headerlink" title="reverse函数"></a>reverse函数</h1><ul><li>reverse函数可以反转一个容器中的内容，包含在<code>&lt;algorithm&gt;</code>库中。</li><li><p>参数：first、last</p><ul><li>first和last是双向迭代器类型，reverse函数反转的范围是[first,last)，所以包括first指向的元素，不包括last指向的元素。</li></ul></li><li><p><code>reverse(v.begin(),v.end());</code><strong>反向排列</strong>从头到尾部的元素</p></li><li>reverse函数没有返回值。</li><li>复杂度<ul><li>循环交换首尾元素。因此复杂度是线性的，并且循环半个数组长度。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;reverse函数&quot;&gt;&lt;a href=&quot;#reverse函数&quot; class=&quot;headerlink&quot; title=&quot;reverse函数&quot;&gt;&lt;/a&gt;reverse函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;reverse函数可以反转一个容器中的内容，包含在&lt;code&gt;&amp;lt;a
      
    
    </summary>
    
      <category term="c++" scheme="ctguljj.github.io/categories/c/"/>
    
      <category term="常用函数" scheme="ctguljj.github.io/categories/c/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="常用函数" scheme="ctguljj.github.io/tags/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于vector大小（size）和容量（capacity）</title>
    <link href="ctguljj.github.io/2019/03/08/%E5%85%B3%E4%BA%8Evector%E5%A4%A7%E5%B0%8F%EF%BC%88size%EF%BC%89%E5%92%8C%E5%AE%B9%E9%87%8F%EF%BC%88capacity%EF%BC%89/"/>
    <id>ctguljj.github.io/2019/03/08/关于vector大小（size）和容量（capacity）/</id>
    <published>2019-03-08T11:33:26.000Z</published>
    <updated>2019-03-08T11:51:03.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><ul><li>在Vector容器中有以下几个关于大小的函数</li></ul><pre><code>- size()返回容器的大小- empty()判断容器是否为空- max_size()返回容器最大的可以存储的元素- capacity()返回容器当前能够容纳的元素数量</code></pre><ul><li>Vector的容量之所以重要，有以下两个原因：<ul><li><ol><li>容器的大小一旦超过capacity的大小，vector会重新配置内部的存储器，导致和vector元素相关的所有reference、pointers、iterator都会失效。</li></ol></li><li>2.内存的重新配置会很耗时间。</li></ul></li></ul><h2 id="避免内存重新配置的方法"><a href="#避免内存重新配置的方法" class="headerlink" title="避免内存重新配置的方法"></a>避免内存重新配置的方法</h2><ul><li>方法一：Reserve()保留适当容量<pre><code>在创建容器后，第一时间为容器分配足够大的空间，避免重新分配内存。</code></pre><ul><li><code>vec.reverse(n);</code></li></ul></li></ul><ul><li><p>方法二：利用构造函数创建出足够空间</p><pre><code>该方法是创建容器时，利用构造函数初始化的出足够的空间，      </code></pre><ul><li><code>vector&lt;int&gt; v(n);</code></li></ul></li><li><p>但是要注意，如果容器中reserve的容量太大，而实际中根本不需要那么多，或者元素插入完成后，以后就不会再进行插入操作了，那么多出来的这部分空间就是过剩空间，而对于过剩空间，我们可以通过“交换技术”成功缩小空间，交换技巧的变体可以用于清除容器和减少它的容量到你的实现提供的最小值。</p></li></ul><h2 id="Vector内存扩展方式"><a href="#Vector内存扩展方式" class="headerlink" title="Vector内存扩展方式"></a>Vector内存扩展方式</h2><ul><li>vector内存成长方式可归结以下三步曲:<br><span id="inline-toc">（1）</span>另觅更大空间；<br><span id="inline-toc">（2）</span>将原数据复制过去；<br><span id="inline-toc">（3）</span>释放原空间三部曲。</li></ul><ul><li><div class="note warning"><p>对于vector和string来说，当它们的需要更多空间时，就会自动增加空间，而每次增加空间的容量会导致很大的开销，首先必须分配新的内存块，它有容器目前容量的几倍（在大部分实现中，vector和string的容量每次变为2倍），然后把所有元素从容器的旧内存拷贝到它的新内存，接着销毁旧内存中的对象，最后回收旧内存。</p></div></li><li><p>每次重新分配空间，所有指向vector或string中的迭代器、指针和引用都会失效，这意味着简单地把一个元素插入vector或string的动作也可能需要更新其他使用了指向vector或string中的迭代器、指针或引用的数据结构而膨胀。</p></li><li><p><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/vector.jpg" alt=""></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在Vector容器中有以下几个关于大小的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;- s
      
    
    </summary>
    
      <category term="stl" scheme="ctguljj.github.io/categories/stl/"/>
    
      <category term="vector" scheme="ctguljj.github.io/categories/stl/vector/"/>
    
    
      <category term="stl" scheme="ctguljj.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>头文件</title>
    <link href="ctguljj.github.io/2019/03/08/%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>ctguljj.github.io/2019/03/08/头文件/</id>
    <published>2019-03-08T10:57:31.000Z</published>
    <updated>2019-03-08T11:54:40.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="include"><a href="#include" class="headerlink" title="#include"></a>#include<functional></functional></h1><ul><li>STL定义运算函数（代替运算符）</li></ul><h1 id="include-lt-bits-stdc-h-gt"><a href="#include-lt-bits-stdc-h-gt" class="headerlink" title="#include&lt;bits/stdc++.h&gt;"></a>#include&lt;bits/stdc++.h&gt;</h1><ul><li>编译器GCC 4.8支持的万能头文件，基本包含所有头文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=&quot;#include&quot;&gt;&lt;/a&gt;#include&lt;functional&gt;&lt;/functional&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;STL定义运算函数（代替运算符）&lt;
      
    
    </summary>
    
      <category term="头文件" scheme="ctguljj.github.io/categories/%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
      <category term="functioinal" scheme="ctguljj.github.io/categories/%E5%A4%B4%E6%96%87%E4%BB%B6/functioinal/"/>
    
    
      <category term="头文件" scheme="ctguljj.github.io/tags/%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>pair容器</title>
    <link href="ctguljj.github.io/2019/03/08/pair%E5%AE%B9%E5%99%A8/"/>
    <id>ctguljj.github.io/2019/03/08/pair容器/</id>
    <published>2019-03-08T09:33:49.000Z</published>
    <updated>2019-03-08T11:28:47.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><ul><li>pair类型的使用相当的繁琐，如果定义多个相同的pair类型对象，可以使用typedef简化声明：<br><code>typedef pair&lt;string,string&gt; Author;</code></li></ul><ul><li>除了构造函数，标准库还定义了一个<code>make_pair</code>函数，由传递给它的两个实参生成一个新的pair对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; next_auth;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">string</span> first,last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;first&gt;&gt;last) &#123;</span><br><span class="line"></span><br><span class="line">   next_auth=make_pair(first,last);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>等价的更复杂的操作:<code>next_auth=pair&lt;string,string&gt;(first,last);</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pair&quot;&gt;&lt;a href=&quot;#pair&quot; class=&quot;headerlink&quot; title=&quot;pair&quot;&gt;&lt;/a&gt;pair&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;pair类型的使用相当的繁琐，如果定义多个相同的pair类型对象，可以使用typedef简化声明：&lt;br&gt;&lt;co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sort函数</title>
    <link href="ctguljj.github.io/2019/03/08/sort%E5%87%BD%E6%95%B0/"/>
    <id>ctguljj.github.io/2019/03/08/sort函数/</id>
    <published>2019-03-08T09:06:25.000Z</published>
    <updated>2019-03-08T11:54:18.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h1><ul><li>默认的为升序</li><li>第三参数——比较函数。比较函数是一个自己定义的函数，返回值是bool型(一般)，它规定了什么样的关系</li><li>排序的数据类型不局限于整数，只要是定义了小于运算的类型都可以，比如字符串类string。</li><li>如果是没有定义小于运算的数据类型，或者想改变排序的顺序，就要用到第三参数——比较函数。</li><li><p><code>vector&lt;int&gt; v;</code></p><p>  <code>sort(v.begin(), v.end(), greater&lt;int&gt;());</code></p></li></ul><ul><li><code>sort(a, a+n, cmp);</code></li></ul><ul><li>对数组进行排序,其头文件为algorithm.h，形式为<code>sort（数组名，数组名+数组长度）</code>，默认为升序，复杂度为nlog（n）；</li><li>加<code>#include&lt;functional&gt;</code>因为用了<code>greater&lt;int&gt;()</code></li><li><code>sort(begin, end, less&lt;数据类型&gt;（）)，升序；</code></li><li><code>sort(begin, end, greater&lt;数据类型&gt;（）)，降序；</code></li><li><code>sort（数组名，数组名+数组长度，less&lt;数组数据类型&gt;()）,升序；</code></li><li><code>sort(数组名，数组名+数组长度，greater&lt;数组数据类型&gt;（）)，降序。</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sort函数&quot;&gt;&lt;a href=&quot;#sort函数&quot; class=&quot;headerlink&quot; title=&quot;sort函数&quot;&gt;&lt;/a&gt;sort函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;默认的为升序&lt;/li&gt;
&lt;li&gt;第三参数——比较函数。比较函数是一个自己定义的函数，返回值是bo
      
    
    </summary>
    
      <category term="c++" scheme="ctguljj.github.io/categories/c/"/>
    
      <category term="常用函数" scheme="ctguljj.github.io/categories/c/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="常用函数" scheme="ctguljj.github.io/tags/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="ctguljj.github.io/2019/03/08/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>ctguljj.github.io/2019/03/08/字符串/</id>
    <published>2019-03-08T08:57:42.000Z</published>
    <updated>2019-03-08T08:58:53.584Z</updated>
    
    <content type="html"><![CDATA[<ul><li>计算机领域中，这个字典序就不仅仅用来比较英文单词了，而是比较任意字符串。对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。如strcmp函数的原理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;计算机领域中，这个字典序就不仅仅用来比较英文单词了，而是比较任意字符串。对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。如strcmp函数的原理&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="字符串" scheme="ctguljj.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>stl代码练习</title>
    <link href="ctguljj.github.io/2019/03/08/stl%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/"/>
    <id>ctguljj.github.io/2019/03/08/stl代码练习/</id>
    <published>2019-03-08T08:30:45.000Z</published>
    <updated>2019-03-08T10:14:05.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="learn-stl"><a href="#learn-stl" class="headerlink" title="learn_stl"></a>learn_stl</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> name; </span><br><span class="line"><span class="comment">//string暂时可以当成一种结构体变量,专门用来定义字符串,name的长度可以由name.length()获得 </span></span><br><span class="line"><span class="keyword">int</span> grade;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; link_list;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Stack;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_1</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_2</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_3</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_4</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_5</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_6</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_7</span><span class="params">(Student a[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[MAX_SIZE];</span><br><span class="line">Student student[MAX_SIZE];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; student[i].name &gt;&gt; student[i].grade;<span class="comment">//只用于map </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.用vector存入数组中所有的数据并升序排序,然后删去最大元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">vec.push_back(a[i]);</span><br><span class="line">sort(vec.begin(), vec.end());</span><br><span class="line">vec.pop_back();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2. 用list存入数组中所有的元素并升序排序。删除其中最小的节点并再插入一个最大的节点 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">link_list.push_back(a[i]);</span><br><span class="line">link_list.sort();</span><br><span class="line"></span><br><span class="line">link_list.erase(link_list.begin());</span><br><span class="line">link_list.insert(link_list.begin(), *(--link_list.end())); </span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itt = link_list.begin(); itt != link_list.end(); itt++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *itt &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.用deque存入数组中所有的数据，在头尾端插入一个和队头队尾相同的元素。</span></span><br><span class="line"><span class="comment">   将deque中的数据用另一个vector存储起来排序后再放回deque中 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">dq.push_back(a[i]);</span><br><span class="line">dq.push_back(a[n<span class="number">-1</span>]), dq.push_front(a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; haha;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">haha.push_back(a[i]);</span><br><span class="line">sort(haha.begin(), haha.end());</span><br><span class="line">dq.clear();</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq(haha.begin(), haha.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;:: iterator ittt = dq.begin(); ittt != dq.end(); ittt++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ittt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.将数组中的元素依次存入stack中，然后依次存入queue中实现数组元素的reverse </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">Stack.push(a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i  &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">que.push(Stack.top());</span><br><span class="line">Stack.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; que.front() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.不借助其他的函数和变量，利用priority_queue实现数组的升序排序 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; q; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">q.push(a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6.将数组中的元素全部存入set中，并输入一个元素，在set中查找它，找到则删除它 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">s.insert(a[i]);</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;j);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator itt;</span><br><span class="line">itt = s.find(j);</span><br><span class="line"><span class="keyword">if</span>(itt != s.end())</span><br><span class="line">s.erase(itt);</span><br><span class="line"><span class="keyword">for</span>(itt = s.begin(); itt != s.end(); itt++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *itt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.将学生的姓名和成绩全部存入map中，并根据学生成绩降序排序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(不能修改给定map的两个参数的顺序) </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; b)</span></span>;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pa;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"> pa = make_pair(student[i].name, student[i].grade);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    stu.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(student[i].name, student[i].grade));</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt; baba(stu.begin(), stu.end() );</span><br><span class="line">sort(baba.begin(), baba.end(), cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; baba.size(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; baba[i].first &lt;&lt; <span class="string">" "</span> &lt;&lt; baba[i].second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种(就是直接用make_pair插入以及sort函数直接用greater逆序排列) </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">stu.insert(make_pair(student[i].name, student[i].grade)); </span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt; yeye(stu.begin(), stu.end() );</span><br><span class="line">sort(yeye.begin(), yeye.end(), greater&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt;());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; yeye[i].first &lt;&lt; <span class="string">" "</span> &lt;&lt; yeye[i].second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//分割线 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;learn-stl&quot;&gt;&lt;a href=&quot;#learn-stl&quot; class=&quot;headerlink&quot; title=&quot;learn_stl&quot;&gt;&lt;/a&gt;learn_stl&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
      <category term="stl" scheme="ctguljj.github.io/categories/stl/"/>
    
      <category term="代码练习" scheme="ctguljj.github.io/categories/stl/%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="stl" scheme="ctguljj.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>stl介绍</title>
    <link href="ctguljj.github.io/2019/03/08/stl/"/>
    <id>ctguljj.github.io/2019/03/08/stl/</id>
    <published>2019-03-08T05:38:37.000Z</published>
    <updated>2019-03-09T06:02:25.193Z</updated>
    
    <content type="html"><![CDATA[<ul><li>注意，STL头文件没有扩展名.h</li><li>STL中默认是采用小于号来排序的</li><li><p><a href="http://www.cnblogs.com/QG-whz/p/5152963.html#_label2" target="_blank" rel="noopener">stl很好的介绍</a></p><h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1></li><li><p>向量(vector) 连续存储的元素<code>&lt;vector&gt;</code></p></li><li><p>列表(list) 由节点组成的双向链表，每个结点包含着一个元素<code>&lt;list&gt;</code></p></li><li><p>双端队列(deque) 连续存储的指向不同元素的指针所组成的数组<code>&lt;deque&gt;</code></p></li></ul><h1 id="适配器容器"><a href="#适配器容器" class="headerlink" title="适配器容器"></a>适配器容器</h1><ul><li><p>栈(stack) 后进先出的值的排列 <code>&lt;stack&gt;</code></p></li><li><p>队列(queue) 先进先出的值的排列<code>&lt;queue&gt;</code></p></li><li><p>优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 <code>&lt;queue&gt;</code></p></li></ul><h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><ul><li><p>集合(set) 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序<code>&lt;set&gt;</code></p></li><li><p>多重集合(multiset) 允许存在两个次序相等的元素的集合<code>&lt;set&gt;</code></p></li><li><p>映射(map) 由{键，值}对组成的集合，以某种作用于键对上的谓词排列 <code>&lt;map&gt;</code></p></li><li><p>多重映射(multimap) 允许键对有相等的次序的映射<code>&lt;map&gt;</code></p></li></ul><h1 id="基础总结"><a href="#基础总结" class="headerlink" title="基础总结"></a>基础总结</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;注意，STL头文件没有扩展名.h&lt;/li&gt;
&lt;li&gt;STL中默认是采用小于号来排序的&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/QG-whz/p/5152963.html#_label2&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="stl" scheme="ctguljj.github.io/categories/stl/"/>
    
    
      <category term="stl" scheme="ctguljj.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>c++map容器</title>
    <link href="ctguljj.github.io/2019/03/08/c-map%E5%AE%B9%E5%99%A8/"/>
    <id>ctguljj.github.io/2019/03/08/c-map容器/</id>
    <published>2019-03-08T05:37:02.000Z</published>
    <updated>2019-03-08T10:27:45.597Z</updated>
    
    <content type="html"><![CDATA[<ul><li>STL是一个统一的整体，map的很多用法都和STL中其它的东西结合在一起</li><li>map中由于它内部有序，由红黑树保证，因此很多函数执行的时间复杂度都是log2N的，如果用map函数可以实现的功能，而STL  Algorithm也可以完成该功能，建议用map自带函数，效率高一些。</li><li><p>sort算法有个限制，利用sort算法只能对序列容器进行排序，就是线性的（如vector，list，deque）。map是一个集合容器，它里面存储的元素是pair，但是它不是线性存储的（像红黑树），所以利用sort不能直接和map结合进行排序。</p></li><li><p>operator()重载必须是常成员函数，因为常对象只能调用常成员函数</p></li><li>STL中默认是采用小于号来排序的</li></ul><h1 id="对map的排序"><a href="#对map的排序" class="headerlink" title="对map的排序"></a>对map的排序</h1><h2 id="key值排序"><a href="#key值排序" class="headerlink" title="key值排序"></a>key值排序</h2><ul><li>按照Key值自动进行了排序</li><li>上面的按key值排序有个缺点：即当插入的有多个相等的值时，由于key的唯一性，会只保留一个。</li></ul><h3 id="map的定义"><a href="#map的定义" class="headerlink" title="map的定义"></a>map的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;pair&lt;const Key,T&gt; &gt; &gt; <span class="title">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure><ul><li>它有四个参数，其中我们比较熟悉的有两个: Key 和 Value。第四个是 Allocator，用来定义存储分配模型的</li><li>现在重点看下第三个参数： <code>class Compare = less&lt;Key&gt;</code><br>这也是一个class类型的，而且提供了默认值 <code>less&lt;Key&gt;</code>。 less是stl里面的一个函数对象，那么什么是函数对象呢？<br>所谓的函数对象：即调用操作符的类，其对象常称为函数对象（function object），它们是行为类似函数的对象。表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个 类，其实质是对operator()操作符的重载。<ul><li>less的实现：</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">less</span> :</span> binary_function &lt;T,T,<span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> x&lt;y;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>是一个带模板的struct，里面仅仅对()运算符进行了重载，实现很简单，但用起来很方便，这就是函数对象的优点所在。stl中还为四则运算等常见运算定义了这样的函数对象，与less相对的还有greater</p></li><li><p>map这里指定less作为其默认比较函数(对象)，所以我们通常如果不自己指定Compare，map中键值对就会按照Key的less顺序进行组织存储</p></li><li><p>可以在定义map的时候，指定它的第三个参数Compare，比如我们把默认的less指定为greater：要加<strong><code>#include &lt;functional&gt;</code></strong></p><ul><li><code>map&lt;string, int, greater&lt;string&gt; &gt; name_score_map;</code></li></ul></li></ul><ul><li>只要我们自己写一个函数对象，实现想要的逻辑，定义map的时候把Compare指定为我们自己编写的这个就ok啦。<ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">struct CmpByKeyLength &#123;</span><br><span class="line"></span><br><span class="line">bool operator()(const string&amp; k1, const string&amp; k2) const &#123;</span><br><span class="line"></span><br><span class="line">return k1.length() &lt; k2.length();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>-`map&lt;string, int, CmpByKeyLength&gt; name_score_map;`</code></pre><h2 id="按照value排序"><a href="#按照value排序" class="headerlink" title="按照value排序"></a>按照value排序</h2><ul><li><p>思路1：可以考虑将value作为key值进行自动排序。</p></li><li><p>思路2：可以把map中的key值和value值分别转存到一个pair类型的vector中，在对vector按照一定的规则排序即可。这样的方法对值一样的情况也能够使用。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; PAIR;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; name_score_map;</span><br><span class="line">name_score_map.insert(make_pair(<span class="string">"Bing"</span>, <span class="number">99</span>));</span><br><span class="line"></span><br><span class="line">name_score_map.insert(make_pair(<span class="string">"Albert"</span>, <span class="number">86</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;PAIR&gt; name_score_vec(name_score_map.begin(), name_score_map.end());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sort(name_score_vec.begin(), name_score_vec.end(), cmp);</span><br></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul><li>对key 排序的话，直接使用<code>greater&lt;string&gt;</code>在map定义的时候就。而要对value排序，则是使用函数对象，先将map转换为vector，调用sort函数中传入一个函数对象，则可以实现对value 的排序。还有一点是pair 只重载了<code>&amp;lt;</code>，则stl 则不能使用 == 运算符。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;STL是一个统一的整体，map的很多用法都和STL中其它的东西结合在一起&lt;/li&gt;
&lt;li&gt;map中由于它内部有序，由红黑树保证，因此很多函数执行的时间复杂度都是log2N的，如果用map函数可以实现的功能，而STL  Algorithm也可以完成该功能，建议用
      
    
    </summary>
    
      <category term="stl" scheme="ctguljj.github.io/categories/stl/"/>
    
      <category term="map" scheme="ctguljj.github.io/categories/stl/map/"/>
    
    
      <category term="stl" scheme="ctguljj.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>bool类型</title>
    <link href="ctguljj.github.io/2019/03/08/bool%E7%B1%BB%E5%9E%8B/"/>
    <id>ctguljj.github.io/2019/03/08/bool类型/</id>
    <published>2019-03-08T05:03:30.000Z</published>
    <updated>2019-03-08T05:31:34.204Z</updated>
    
    <content type="html"><![CDATA[<ul><li>千万不要让编译器决定你的默认值，永远初始化 </li><li>变量未初始化的默认值要看变量的存储类型，也可能与编译器有关，跟其它因素</li></ul><h1 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h1><ul><li>c++中有bool类型</li><li>bool可用于定义函数类型为布尔型，函数里可以有 return TRUE; return FALSE 之类的语句。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>为了安全起见， 最好初始化为false.</li><li>bool值一定要初始化</li></ul><h1 id="在GCC编译器下各个类型的全局变量的默认值："><a href="#在GCC编译器下各个类型的全局变量的默认值：" class="headerlink" title="在GCC编译器下各个类型的全局变量的默认值："></a>在GCC编译器下各个类型的全局变量的默认值：</h1><ul><li>表示数字的变量类型默认值都为0<ul><li>bool型默认值为false</li><li>string型默认值为空字符串</li><li>char 型比较特殊。char类型默认值为’\0’， 即字符串结束标志，其整数值为0。如果用printf(“%d”)输出时值为 0， 但用printf(“%c”),或cout 输出时显示为”a”， char型数组默认值为空字符串，其中的每个元素与单个char类型相同，所以用puts() 和printf(“%s”)<br>输出都是空字符串。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;千万不要让编译器决定你的默认值，永远初始化 &lt;/li&gt;
&lt;li&gt;变量未初始化的默认值要看变量的存储类型，也可能与编译器有关，跟其它因素&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;bool类型&quot;&gt;&lt;a href=&quot;#bool类型&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="c++" scheme="ctguljj.github.io/categories/c/"/>
    
      <category term="数据类型" scheme="ctguljj.github.io/categories/c/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="c++" scheme="ctguljj.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>类型转换</title>
    <link href="ctguljj.github.io/2019/03/06/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>ctguljj.github.io/2019/03/06/强制转换/</id>
    <published>2019-03-06T05:32:14.000Z</published>
    <updated>2019-03-06T13:31:39.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul><li>进行不同数据的强制转换其实就是数据占用字节扩充或者截断。 </li><li>将数据由值域较宽类型强制转换到值域较窄类型时，有可能出现数据信息丢失。</li><li>char 型数据在机器里通过 ASCII 码存储，也就是用一个整数存储的。</li><li>当执行一个运算时（如这里的a&gt;b），如果它的一个运算数是有符号的而另一个数是无符号的，那么C语言会隐式地将有符号 参数强制类型为无符号数，并假设这两个数都是非负的，来执行这个运算</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类型转换&quot;&gt;&lt;a href=&quot;#类型转换&quot; class=&quot;headerlink&quot; title=&quot;类型转换&quot;&gt;&lt;/a&gt;类型转换&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进行不同数据的强制转换其实就是数据占用字节扩充或者截断。 &lt;/li&gt;
&lt;li&gt;将数据由值域较宽类型强制转换到值域
      
    
    </summary>
    
      <category term="数据类型" scheme="ctguljj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="类型转换" scheme="ctguljj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
    
      <category term="数据类型" scheme="ctguljj.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>代码块高亮</title>
    <link href="ctguljj.github.io/2019/03/06/%E4%BB%A3%E7%A0%81%E5%9D%97%E9%AB%98%E4%BA%AE/"/>
    <id>ctguljj.github.io/2019/03/06/代码块高亮/</id>
    <published>2019-03-06T04:33:23.000Z</published>
    <updated>2019-03-06T04:36:01.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主题自带样式-代码块高亮"><a href="#主题自带样式-代码块高亮" class="headerlink" title="主题自带样式 代码块高亮"></a>主题自带样式 代码块高亮</h1><ul><li><p>这里指的是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```[language] [title] [url] [link-text]</span><br><span class="line"></span><br><span class="line">代码</span><br></pre></td></tr></table></figure></p></li><li><p>[language] 是代码语言的名称，用来设置代码块颜色高亮，非必须；</p></li><li>[title] 是顶部左边的说明，非必须；</li><li>[url] 是顶部右边的超链接地址，非必须；</li><li>[link text] 如它的字面意思，超链接的名称，非必须。</li><li>亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主题自带样式-代码块高亮&quot;&gt;&lt;a href=&quot;#主题自带样式-代码块高亮&quot; class=&quot;headerlink&quot; title=&quot;主题自带样式 代码块高亮&quot;&gt;&lt;/a&gt;主题自带样式 代码块高亮&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这里指的是&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="blog" scheme="ctguljj.github.io/categories/blog/"/>
    
      <category term="markdown" scheme="ctguljj.github.io/categories/blog/markdown/"/>
    
    
      <category term="blog" scheme="ctguljj.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>素数筛选法</title>
    <link href="ctguljj.github.io/2019/03/05/%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95/"/>
    <id>ctguljj.github.io/2019/03/05/素数筛选法/</id>
    <published>2019-03-05T14:44:50.000Z</published>
    <updated>2019-03-07T05:16:30.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h1><ul><li>一个数 n 如果是合数，那么它的所有的因子不超过sqrt(n)–n的开方</li><li>质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数</li><li>质数大于等于2 不能被它本身和1以外的数整除</li></ul><h1 id="素数筛选法"><a href="#素数筛选法" class="headerlink" title="素数筛选法"></a>素数筛选法</h1><ul><li>素数是数学中一个很重要的数，很多算法中都需要用到素数相关的性质，因此传统的暴力循环求素数的效率显得十分低效，这里我们有两种高效求1~n以内的素数的方法。需要大家掌握，特别是欧拉筛法里面用到一点数学性质，大家可自行百度欧拉筛法掌握具体的原理，以后的出现的算法中还会出现。</li></ul><h1 id="欧拉筛法-时间复杂度（n"><a href="#欧拉筛法-时间复杂度（n" class="headerlink" title="欧拉筛法-时间复杂度（n)"></a>欧拉筛法-时间复杂度（n)</h1><ul><li><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/欧拉筛选法.png" alt=""></li><li>最简单的素数筛法是这样的：10000000内的素数，用这个筛选法可以大大的降低时间复杂度</li></ul><p>1.开一个大的bool型数组prime[]，大小就是n+1就可以了.先把所有的下标为奇数的标为true,下标为偶数的标为false.</p><p>2.然后：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">3</span>; i&lt;=<span class="built_in">sqrt</span>(n); i+=<span class="number">2</span> )</span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">if</span>(prime)</span><br><span class="line"><span class="keyword">for</span>( j=i+i; j&lt;=n; j+=i ) prime[j]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.最后输出bool数组中的值为true的单元的下标，就是所求的n以内的素数了。</p><pre><code>原理很简单，就是当i是质(素)数的时候，i的所有的倍数必然是合数。如果i已经被判断不是质数了，那么再找到i后面的质数来把这个质数的倍数筛掉。</code></pre><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>No.1使用 合数=最大因数(除1和本身外)<em>最小质因数 的原理来筛，每个数只会被筛一次<br>对于每个数i，令它是某数的最大因数，然后从小到大地找&lt;=i的素数j，则i</em>j是合数<br>直到找到某个j使得i%j == 0,因为再往后的话，j’&gt; i的某个因子，我们能交换j’和i的这个因子，所以i不是i<em>j’的最大因数（或者说i</em>j’的最小质因数是刚才的那个j），再往后做没有意义</li></ul><ul><li><p>No.2回顾经典的Eratosthenes筛法，它可能对同一个质数筛去多次。那么如果用某种方法使得每个合数只被筛去一次就变成是线性的了。<br>不妨规定每个合数只用其最小的一个质因数去筛，这便是欧拉筛了。</p></li><li><p>No.3<br>线性筛有两个地方与一般筛不同:</p></li></ul><p>1.两层循环的顺序不同（一般筛是第一维prime[i] 第二维j，欧拉筛是第一维i 第二位prime[j]）</p><p>2.一行神奇的代码：<br>           <code>if(i%prime[j]==0)break;</code></p><p>prime[]数组中的素数是递增的,当i能整除prime[j]，那么i<em>prime[j+1]这个合数肯定被prime[j]乘以某个数筛掉。<br>   因为i中含有prime[j],prime[j]比prime[j+1]小，即    `i=k</em>prime[j]<code>，那么</code>i<em>prime[j+1]=(k</em>prime[j])<em>prime<code></code> [j+1]=k’</em>prime[j]<code>，接下去的素数同理。所以不用筛下去了。因此，在满足</code>i%prime[j]==0`这个条件之前以及第一次<br>   满足改条件时,prime[j]必定是prime[j]*i的最小因子。</p><p>No.4 证明分两部分。首先证每个合数都会被筛到（正确性），其次证每个合数只会被筛到一次（复杂度）。<br>每个合数都会被筛到<br>设有一合数 （为质数）<br>则一定会在  时被筛去（此时 ），因为对于小于 的质数，一定不会被  整除<br>每个合数都只会被筛到一次<br>与上面一样，还是设有一合数 （ 为质数）<br>倘若存在一个质因子  也筛去了，那么此时 。<br>o，此时在内层循环中已经早早地break掉了，因为 。<br>o，此时还没加进质数表QwQ（顺便一提：这种情况只有可能在  时发生）</p><p>代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler_sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">totPrimes = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag)); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123; </span><br><span class="line"><span class="keyword">if</span> (!flag[i]) </span><br><span class="line">primes[totPrimes++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i * primes[j] &lt;= n; j++) &#123; </span><br><span class="line">flag[i*primes[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>j &lt; totPrimes</code>为何不加？</li></ul><div class="note warning"><br>o当  为质数时，内层循环会在最后一个质数（也就是  自己）终止。<br><br><br>o当  为合数时，内层循环会在它的第一个质因数终止。<br>当然加了也没有问题<p></p></div><h2 id="埃拉特斯特尼筛法，时间复杂度（nlogn）"><a href="#埃拉特斯特尼筛法，时间复杂度（nlogn）" class="headerlink" title="埃拉特斯特尼筛法，时间复杂度（nlogn）"></a>埃拉特斯特尼筛法，时间复杂度（nlogn）</h2><p><img src="https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/埃拉特斯特尼筛法.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学原理&quot;&gt;&lt;a href=&quot;#数学原理&quot; class=&quot;headerlink&quot; title=&quot;数学原理&quot;&gt;&lt;/a&gt;数学原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个数 n 如果是合数，那么它的所有的因子不超过sqrt(n)–n的开方&lt;/li&gt;
&lt;li&gt;质数又称素数。一个大
      
    
    </summary>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法</title>
    <link href="ctguljj.github.io/2019/03/05/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    <id>ctguljj.github.io/2019/03/05/分治法/</id>
    <published>2019-03-05T13:33:34.000Z</published>
    <updated>2019-03-05T13:54:12.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="可使用分治法求解的一些经典问题"><a href="#可使用分治法求解的一些经典问题" class="headerlink" title="可使用分治法求解的一些经典问题"></a>可使用分治法求解的一些经典问题</h2><ul><li>（1）二分搜索<br>（2）大整数乘法<br>（3）Strassen矩阵乘法<br>（4）棋盘覆盖<br>（5）合并排序<br>（6）快速排序<br>（7）线性时间选择<br>（8）最接近点对问题<br>（9）循环赛日程表<br>（10）汉诺塔</li></ul><p>-</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分治法&quot;&gt;&lt;a href=&quot;#分治法&quot; class=&quot;headerlink&quot; title=&quot;分治法&quot;&gt;&lt;/a&gt;分治法&lt;/h1&gt;&lt;h2 id=&quot;可使用分治法求解的一些经典问题&quot;&gt;&lt;a href=&quot;#可使用分治法求解的一些经典问题&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="算法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分治法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>输入输出</title>
    <link href="ctguljj.github.io/2019/03/05/c-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>ctguljj.github.io/2019/03/05/c-输入输出/</id>
    <published>2019-03-05T10:17:49.000Z</published>
    <updated>2019-03-06T15:32:23.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="续行符"><a href="#续行符" class="headerlink" title="续行符"></a>续行符</h1><ul><li>宏定义只能在一行内完成</li><li>字符串多行书写有两种规则：在字符串换行处加一个反斜杠\，下一行前不能有空格或者Tab键；使用双引号。</li><li>代码中的“\”是 C 语言中的续行符语法，表示续行符的下一行与续行符所在的代码是同一行,因为宏定义关键字“#define”只是对当前行有效，所以使用续行符来连接</li><li>应用续行符的时候要注意，在“\”后面不能有任何字符(包括注释、空格)，只能直接回车。在要强制换行的地方输入反斜杠然后回车</li><li>c语言中还有一种拆分字符串的方法，那就是将其写个多个相邻的字符串。这些字符串之间用0个或者多个空白、制作符以及换行符隔开。    <code>printf(&quot;Programming&quot; &quot; in c&quot; &quot; is fun&quot;\n);//Programing in c is fun</code>    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">printf(</span><br><span class="line">   &quot;                ********\n&quot;</span><br><span class="line">   &quot;               ************\n&quot;</span><br><span class="line">   &quot;               ####....#.\n&quot;</span><br><span class="line">   &quot;             #..###.....##....\n&quot;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><ul><li>gets()函数并不读取换行符’\n’,它会吧换行符替换成空字符’\0’,作为c语言字符串结束的标志.此时换行符已经没了！！</li><li>gets在C99标准中，已经不再建议使用gets()函数，而在C11中更是直接抛弃了这个函数,gets函数没有限制读入的个数，这很可能会导致程序向未知的内存空间写入数据，而导致程序出错。</li><li>fgets函数中第二个参数限制了读取的个数，这也解决了gets函数存在的问题，但要注意fgets函数只会读取n-1个字符（如果遇到换行符会更少），并在最后添加字符串结束标志，而且，fgets也会将换行符读入。<br><code>char *fgets(char *buf, int bufsize, FILE *stream)；</code>注意一下第二个参数bufsize，这个参数就限制了读取的字符的个数，这就可以解决gets()函数的缺陷。我们知道fgets() 函数主要用于读取文件，如果要读取键盘，则stream参数应该为stdin，需要注意的是，如果bufsize设置为n，那么fgets()函数最多读取n-1个字符，之所以用“最多”这个词是因为，如果在之前遇到了换行符，fgets函数也会返回。还有一点就是，fgets()函数会读取换行符（这一点和gets函数不同），当读取结束后，fgets函数会为buf在末尾添加一个空字符作为字符串的结束.</li><li>scanf函数要实现修改变量值的功能，传地址就相当于传指针（指向一个内存位置）！<br>printf只是对变量值执行输出功能，不涉及改变！</li></ul><h1 id="输入输出返回值"><a href="#输入输出返回值" class="headerlink" title="输入输出返回值"></a>输入输出返回值</h1><ul><li><p>scanf为函数，printf为函数(输入与输出函数)：返回值：scanf 函数的返回值反映的是按照指定的格式符正确读入的数据的个数。<br>如果输入数据与指定格式不符，则会产生输入错误。遇到输入错误，scanf函数会立即终止，返回已经成功读取的数据的个数。所以通过scanf函数的返回值和指定输入数据的个数（由格式符决定）的比较，可以判断数据输入是否成功。</p></li><li><p>scanf 函数是有返回值的，它的返回值可以分成三种情况</p></li></ul><ul><li><p>正整数，表示正确输入参数的个数。例如执行 scanf(“%d %d”, &amp;a, &amp;b); </p><pre><code>如果用户输入&quot;3 4&quot;，可以正确输入，返回2（正确输入了两个变量）；如果用户输入&quot;3,4&quot;，可以正确输入a，无法输入b，返回1（正确输入了一个变量）。 </code></pre></li><li><p><span id="inline-blue"> 0，表示用户的输入不匹配，无法正确输入任何值。如上例，用户如果输入”,3 4”，返回0。</span></p></li><li><p>EOF，这是在stdio.h里面定义的常量（通常值为-1），表示输入流已经结束(scanf遇到格式不对返回EOF或结束时)(EOF == end of file)</p></li></ul><ul><li>printf的返回值是输出的字符数，例如，<code>printf(&quot;1234&quot;)</code>的返回值是4，而<code>printf(&quot;1234\n&quot;)</code>的返回值是5。不知道有木有这样写的习惯<code>while (~scanf(&quot;....&quot;))</code>。这里出现了~这个符号，这个是位运算取反的意思。因为<code>~(n)=-(n+1)</code>。所以这里scanf的返回值为-1时~(-1)=0才退出循环。这就是这样写的意思。</li></ul><h1 id="c-输入输出"><a href="#c-输入输出" class="headerlink" title="c++输入输出"></a>c++输入输出</h1><ul><li>cout在输出很大的数时,会用科学计数法输出,若不想如此输出，可将原来输出数double类型与float类型改为int类型，或者如下.</li><li><code>cout&lt;&lt;std::fixed&lt;&lt; a &lt;&lt;endl;</code></li><li><code>printf(&quot;%.0lf&quot;, a);</code></li><li>当数字过大时可能数字有变化或丢失(自测)</li><li>fixed后面还可以加格式控制符控制位数，setprecision(n)——设置输出浮点数的精度，配合fixed设定，指的是小数位数，设置setprecision(0)即指输出不带小数位的int值。</li><li>还有其它方法！！！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;续行符&quot;&gt;&lt;a href=&quot;#续行符&quot; class=&quot;headerlink&quot; title=&quot;续行符&quot;&gt;&lt;/a&gt;续行符&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;宏定义只能在一行内完成&lt;/li&gt;
&lt;li&gt;字符串多行书写有两种规则：在字符串换行处加一个反斜杠\，下一行前不能有空格或者
      
    
    </summary>
    
    
      <category term="输入输出" scheme="ctguljj.github.io/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>二分法</title>
    <link href="ctguljj.github.io/2019/03/04/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <id>ctguljj.github.io/2019/03/04/二分法/</id>
    <published>2019-03-04T15:28:49.000Z</published>
    <updated>2019-03-04T15:59:55.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分法-折半查找"><a href="#二分法-折半查找" class="headerlink" title="二分法(折半查找)"></a>二分法(折半查找)</h1><ul><li>将所给关键词和指定有序集合中间数进行比较,如果比较相等则返回结果,如果不相等,则按照所给出的结果,将集合减半后继续查找</li><li>二分法是减治法的思想</li><li>二分法：<code>(low+high)/2</code>,如果故意卡数据即low与high很大的话,会越界.所以可以为<code>(high - low)/2+low;</code></li></ul><h2 id="优化-先确定范围"><a href="#优化-先确定范围" class="headerlink" title="优化(先确定范围)"></a>优化(先确定范围)</h2><ul><li>插值查找</li><li>这里的插值查找法,是对二分法的一种改进.<strong>此法和二分法一样对数据要求有序且尽量分布均匀</strong></li><li>对于二分法有:    <code>mid = (low + high)/2;</code><br>不难得到  <code>mid = low + 1/2*(high-low);</code><br>试想,对于在字典中进行查找时,对于’you’或’and’<br>来说,我们通常的处理方法肯定不是从中间开始进行查找,而是根据所给出的值,大致确定范围后再来进行查找.<br>这里的大致范围是通过,所查找的value值在所查集合中所大概处于的位置,定位到后进行比较<br>故有如下公式:<br><code>key = low + ((value - a[low])/(a[high]-a[low]))*（high-low);</code></li></ul><p>伪代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int insertseek(int value,int map[])</span><br><span class="line"></span><br><span class="line">   int low,high,key;</span><br><span class="line"></span><br><span class="line"> low = 0; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">high = n -1 ;</span><br><span class="line"></span><br><span class="line">while(low&lt;=high)</span><br><span class="line"></span><br><span class="line">key = low + ((value - low)/(high-low))*（high -low);</span><br><span class="line"></span><br><span class="line">if(key = value) return key;</span><br><span class="line"></span><br><span class="line">else if(key &lt; value) low = key;</span><br><span class="line"></span><br><span class="line">else  high = key;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分法-折半查找&quot;&gt;&lt;a href=&quot;#二分法-折半查找&quot; class=&quot;headerlink&quot; title=&quot;二分法(折半查找)&quot;&gt;&lt;/a&gt;二分法(折半查找)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;将所给关键词和指定有序集合中间数进行比较,如果比较相等则返回结果,如果不相等
      
    
    </summary>
    
      <category term="算法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分法" scheme="ctguljj.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
    
      <category term="算法" scheme="ctguljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>c与c++常用函数</title>
    <link href="ctguljj.github.io/2019/03/04/c%E4%B8%8Ec-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>ctguljj.github.io/2019/03/04/c与c-常用函数/</id>
    <published>2019-03-04T04:51:49.000Z</published>
    <updated>2019-03-08T04:29:57.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><ul><li>max, min, fill, memset, sort, swap</li></ul><h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><ul><li>字符串比较函数strcmp因为原理是两个字符串一个个比较，所以可以比较字符是否相同！！！！！<div class="note success"><p>如果把序号按字符串存储，则会可以通过strcmp比较序号是否相同。</p></div>(有用)</li><li>Strlen函数如果没有遇到’\0’，会一直计算下去，字符串二维数组不可以用strlen，因为二维数组每一行相当于一个字符串一维数组，每一行都有’\0’！</li></ul><h1 id="tolower函数"><a href="#tolower函数" class="headerlink" title="tolower函数"></a>tolower函数</h1><ul><li>定义函数：int tolower(int c);</li></ul><p>函数说明：若参数 c 为大写字母则将该对应的小写字母返回。</p><p>返回值：返回转换后的小写字母，若不须转换则将参数c 值返回。<br>tolower(s[i]);</p><ul><li><code>#include &lt;cctype&gt;</code></li></ul><h1 id="fill函数"><a href="#fill函数" class="headerlink" title="fill函数"></a>fill函数</h1><ul><li>在头文件<code>&lt;algorithm&gt;</code>里面</li><li>按照单元赋值，将一个区间的元素都赋同一个值<br><code>fill(arr, arr + n, 要填入的内容);</code><br>vector也可以：<code>fill(v.begin(), v.end(), 要填入的内容);</code></li><li>fill 和fill_n函数是C++ Primer第十二章泛型算法部分内容，并把它们称为生成和变异算法，也就是说<strong>这两个函数只能对输入范围内已存在的元素进行操作</strong>。如果试图对空容器进行fill_n操作，会导致严重的运行错误，所以在对元素进行写入操作时要检查目标的大小是否足以存储要写入的元素。</li></ul><h2 id="与memset-函数的区别："><a href="#与memset-函数的区别：" class="headerlink" title="与memset()函数的区别："></a>与memset()函数的区别：</h2><ul><li><p>两者都可以用来对数组填充，memset是对按照字节来填充的，所以一般用来填充char型数组，也经常用于填充int型的全0或全-1操作。</p></li><li><p>fill是按照单元来填充的，所以可以填充一个区间的任意值。</p></li></ul><h1 id="fill-n函数"><a href="#fill-n函数" class="headerlink" title="fill_n函数"></a>fill_n函数</h1><ul><li>在头文件<code>&lt;algorithm&gt;</code>里。</li><li><code>fill_n(vec.begin, cnt, val);</code>从当前起始点开始，将之后的cnt个元素赋值为val。<br>  注意：不能在没有元素的空容器上调用fill_n()函数</li></ul><h1 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h1><ul><li>在头文件<code>&lt;cstring&gt;</code>里面</li><li>Memset函数:可以本身就是为字符数组设计的源代码：unsigned int 有一个特性就是如果将其赋值或者当作字节来使用的话，编译器将会截取低八位作为一个字节使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void *(memset)(void *s, int c, size_t n)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">const unsigned char uc = c;</span><br><span class="line">unsigned char *su;</span><br><span class="line">for (su = s; 0 &lt; n; ++su, --n)</span><br><span class="line">    *su = uc;</span><br><span class="line">return (s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码说明对于数组参数是按照字符数组的形式进行赋值的。<br>也就是c的值每次赋值给一个字节，而不是4个字节，c的类型是int类型，4个字节，<br>但只会赋值最低位的一个字节的内容。</p><ul><li><p>对于非单字节数据类型只能初始化为0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值0的结果都是0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果。</p></li><li><p>对于变量：当结构体类型中包含指针时，在使用memset初始化时需要小心。<br>struct sample_strcut stTest;用memset就非常方便：memset(&amp;stTest,0,sizeof(struct sample_struct));<br>原因是memset初始化的时候是按字节一个一个填充的，int有四个字节，于是填充成0000 0001 0000 0001 0000 00001 0000 0001，这样得出数组中的每个元素的值就是16843009了。<br>赋值时0与’\0’效果一样。</p></li><li>可以用于清空数组内元素与赋,memset函数一般用来填充char型数组,也经常用于填充int型的全0或全-1.不可用其它值，除非高低字节相同.</li></ul><p>-<br>    <code>`</code></p><pre><code>#define INF 0x3f3f3f3fint num[N];memset(num, INF, sizeof(num));</code></pre><p>这样得到的数组里面的每一个元素数值都是INF<br>看一下INF的二进制表示：<br>00111111001111110011111100111111<br>可以看出低8位是00111111，<strong><em>也就是实际赋值时是用<br>00111111来填充一个int类型</em></strong>，结果正好也是<br>00111111001111110011111100111111<br>于是就成功用memset进行了赋值。</p><h3 id="INF小知识"><a href="#INF小知识" class="headerlink" title="INF小知识"></a>INF小知识</h3><ul><li>0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。</li><li><p>另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。</p></li><li><p>最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！<strong><em>所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))</em></strong>。<br>所以在通常的场合下，const int INF = 0x3f3f3f3f;真的是一个非常棒的选择。</p></li><li><div class="note warning"><p>因为在某些编译器分配空间时,内存中默认值并不为0,所以先用memset函数赋初值0.</p></div></li></ul><h1 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h1><h2 id="atoi-函数"><a href="#atoi-函数" class="headerlink" title="atoi()函数"></a>atoi()函数</h2><ul><li>用来将字符串转换成整数(int)：<code>int atoi (const char * str);</code></li><li>【返回值】返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。</li><li>atoi() 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回。</li><li>Enter a number: 233cyuyan</li><li>The value entered is 233.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用函数&quot;&gt;&lt;a href=&quot;#常用函数&quot; class=&quot;headerlink&quot; title=&quot;常用函数&quot;&gt;&lt;/a&gt;常用函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;max, min, fill, memset, sort, swap&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;字符
      
    
    </summary>
    
      <category term="c++" scheme="ctguljj.github.io/categories/c/"/>
    
      <category term="常用函数" scheme="ctguljj.github.io/categories/c/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="c++" scheme="ctguljj.github.io/tags/c/"/>
    
  </entry>
  
</feed>
