<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python入门]]></title>
    <url>%2F2020%2F01%2F12%2Fpython%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[基础 Python可以直接定义变量名字并进行赋值的，例如我们写出a = 4时，Python解释器干了两件事情： 在内存中创建了一个值为4的整型数据 在内存中创建了一个名为a的变量，并把它指向4 if _name_ == &quot;_main_&quot;:由于每个python模块（python文件）都包含内置的变量name，当运行模块被执行的时候，name等于文件名（包含了后缀.py）。如果import到其他模块中，则name等于模块名称（不包含后缀.py）。而“main”等于当前执行文件的名称（包含了后缀.py）。所以当模块被直接执行时，name == ‘main‘结果为真；而当模块被import到其他模块中时，name == ‘main‘结果为假，就是不调用对应的方法。 简而言之就是：name 是当前模块名，当模块被直接运行时模块名为 main 。当模块被直接运行时，代码将被运行，当模块被导入时，代码不被运行。让你写的脚本模块可以导入到别的模块中用 爬虫request库This browser does not support PDFs. Please download the PDF to view it: Download PDF]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c/c++ 基础]]></title>
    <url>%2F2019%2F09%2F17%2Fc-c-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[循环 for (int i = 0, len = strlen(s); i &lt; len; i++)代替for (int i = 0; i &lt; strlen(s); i++) 基本运算和函数 在乘以2（或2的整数次幂）或除以2（或2的整数次幂）的时候尽量用位运算来替代。 尽量减少使用除法运算（可以适当转换为乘法，如条件判断时将if (a == b / c)替换为if (a * c == b)。除法运算需要更多的移位和转换操作，往往需要的时间是相应乘法的两倍） 多使用+=、-=、*=、/=等复合运算符，以加一为例，效率由高到低是(i++ 、 i += 1 、 i = i + 1)]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab GUI]]></title>
    <url>%2F2019%2F07%2F26%2Fmatlab-GUI%2F</url>
    <content type="text"><![CDATA[matlab GUI G=graphic图形 U=user用户 I=interface界面 一个Gui程序，由两个部分组成。界面是界面，是表层，通过.fig文件进行控制；代码是代码，是底层，通过与.fig相同文件名的.m文件进行控制。 在保存GUI文件的一刹那，Matlab会自动生成两个文件，一个是.fig文件，对应guide开发界面的样子；另外一个是.m文件，是和.fig文件平行的代码控制文件。 GUI对应的脚本部分，编写自定义的函数 回调函数Callback，获取输入函数get(),设定输出函数set()]]></content>
      <categories>
        <category>matlab</category>
        <category>GUI</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F06%2F18%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 单链表实现并且为交点交换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;//结点deftypedef struct node &#123; int data; struct node *next;&#125; Node,*Linklist;//构建链表头void IniList(Linklist *L) &#123; *L=(Linklist)malloc(sizeof(Node)); (*L)-&gt;next=NULL;&#125;//读入数据进链表void CreList(Linklist *L) &#123; int i,n,t; Linklist r,s; IniList(L); r=*L; scanf("%d",&amp;n); for(i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;t); s=(Linklist)malloc(sizeof(Node)); s-&gt;data=t; s-&gt;next=r-&gt;next; r-&gt;next=s; r=s; &#125;&#125;//对链表进行排序void maopao(Linklist L) &#123; //排序中没有修改头节点指针值，只是修改指针内容head-&gt;next的值 Linklist pre, p, tail, temp; tail=NULL; pre=L; Linklist head = L; while((head-&gt;next-&gt;next)!=tail) &#123; //(head-&gt;next)!=tail同样适用 ，多执行最后一个步比较 p=head-&gt;next; pre=head; while(p-&gt;next!=tail) &#123; if((p-&gt;data)&gt;(p-&gt;next-&gt;data)) &#123; /* pre-&gt;next=p-&gt;next; //交换节点方法一 p-&gt;next = p-&gt;next-&gt;next; pre-&gt;next-&gt;next = p; p = pre-&gt;next; */ pre-&gt;next=p-&gt;next; //交换节点方法二 temp=p-&gt;next-&gt;next; p-&gt;next-&gt;next=p; p-&gt;next=temp; p=pre-&gt;next; //p回退一个节点 &#125; p=p-&gt;next; //p再前进一个节点 pre=pre-&gt;next; &#125; tail=p; &#125;&#125;//打印链表void PriList(Linklist L) &#123; Linklist p=L-&gt;next; while(p) &#123; printf("%d ",p-&gt;data); p=p-&gt;next; &#125;&#125;int main() &#123; Linklist L; CreList(&amp;L); //创建链表 maopao(L); //你要填的排序 printf("\n"); PriList(L); //输出 return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[二级指针 B是一个指针变量,其中存放着C的地址，但是B也要占空间的啊，所以B也有地址，B的起始地址是0x00000004,但是B内存中存放的是C的地址，所以B代表0x00000008即B指向的内容的地址。 123B= 0x00000008; //B指向的内容的地址 *B = "一段内容"; //B解引用，也就是B指针指向的C的值&amp;B = 0x00000004; //B取地址，B的地址是0x00000004 A是二级指针变量，其中存放着B的地址0x00000004,A也有地址，是0x00000000; 若函数需要改变原本的指针指向，函数形参可以使用二重指针，不过使用c++中的引用(对一级指针)效率更高1234*A = B= 0x00000008; //A解引用也就是B的内容 **A = *B = "一段内容"; //B解引用，也就是B指针指向的C的值A = &amp;B = 0x00000004; //A存的是B本身的地址，B的地址是0x00000004&amp;A = 0x00000000; //A取地址 定义 123int a=1;int *p=&amp;a; // p为a变量的地址，通过*p可以得到a的值int **q=&amp;p; // q为p指针的地址，通过**q可以得到a的值 二级指针是指向指针的指针，所以函数形参是二级指针时，实参应该是一级指针，而非二级指针 123456789node *tree;insert(&amp;tree);node *insert(node **root)()&#123;&#125;//引用写法，就不要二级指针node *insert(node* &amp;root)&#123;&#125;]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之图]]></title>
    <url>%2F2019%2F06%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图 图（Graph）通常表示为： G(V,E)。其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。 在图中，不允许没有顶点。若 V 是图的顶点的集合，那么，V 是非空有穷集合。 图的任意两个顶点之间都可能有关系，它们的关系用边来表示。边集可以是空的。 无向边用小括号 “（）”表示，有向边用尖括号“&lt;&gt;”表示。 无向图 邻接矩阵存储结构 12345678910111213141516171819202122232425262728293031typedef char VertexType;typedef int EdgeType;#define MAXVEX 100; // 最大顶点数#define INFINITY 65535; typedef struct&#123; VertexType vexs[MAXVEX]; // 顶点表 EdgeType arc[MAXVEX][MAXVEX]; // 邻接矩阵，可看作边表 int numVertexes, numEdges; // 图中当前顶点数和边数&#125;MGraph;void CreateGraph(MGraph *G)&#123; int i, j, k, w; printf("%s", "输入顶点数和边数:\n"); scanf("%d, %d", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); // 输入顶点数和边数 for(i = 0; i &lt; G-&gt;numVertexes; i++)&#123; scanf(&amp;G-&gt;vexs[i]); &#125; for(i = 0; i &lt; G-&gt;numVertexes; i++)&#123; for(j = 0; j &lt; G-&gt;numVertexes; j++)&#123; G-&gt;arc[i][j] = INFINITY; // 邻接矩阵初始化 &#125; &#125; for(k = 0; k &lt; G-&gt;numEdges; k++)&#123; // 读入numEdges条边，建立邻接矩阵 printf("输入边(vi,vj)上的下标i、下标j和权w:\n"); scanf("%d, %d, %d", &amp;i, &amp;j, &amp;w); // 输入边（vi,vj）上的权w G-&gt;arc[i][j] = w; G-&gt;arc[j][i] = G-&gt;arc[i][j]; // 因为是无向图，矩阵对称 &#125;&#125; 邻接表结构 当图为无向图的时候，这个线性表叫做顶点 $v_i$ 的边表。123456789101112131415161718192021typedef char VertexType;typedef int EdgeType;typedef struct EdgeNode // 边表结点&#123; int adjvex; // 邻接点域，存储该顶点对应的下标 EdgeType weight; // 权值 struct EdgeNode *next; // 链域，指向下一个连接点&#125;EdgeNode;typedef struct VertexNode // 顶点表结点&#123; VertexType data; // 顶点域，存储顶点信息 EdgeNode *firstEdge; // 边表头指针&#125;VertexNode, AdjList[MAXVEX];typedef struct&#123; AdjList adjList; int numVertexes, numEdges; // 图中当前顶点数和边数&#125;GraphAdjList; 无向图的邻接表创建代码 12345678910111213141516171819202122232425void CreateALGraph(GraphAdjList *G)&#123; int i, j, k; EdgeNode *e; printf("输入顶点数和边数：\n"); scanf("%d, %d", &amp;G-&gt;numVertexes, &amp;G-&gt;numEdges); // 输入顶点数和边数 for(i = 0; i &lt; G-&gt;numVertexes; i++)&#123; scanf(&amp;G-&gt;adjList[i].data); // 输入顶点信息。 G-&gt;adjList[i].firstEdge = NULL; // 将边表置为空表。 &#125; for(k = 0; k &lt; G-&gt;numVertexes; i++)&#123; // 建立边表 printf("输入边(Vi,Vj)上的顶点序号：\n"); scanf("%d, %d", &amp;i, &amp;j); // 输入边(Vi,Vj)上的顶点序号 e = (EdgeNode *)malloc(sizeof(EdgeNode)); // 申请内存空间，创建边表结点 e-&gt;adjvex = j; // 邻接序号为j e-&gt;next = G-&gt;adjList[i].firstEdge; // 将e指针指向当前顶点指向的结点 G-&gt;adjList[i].firstEdge = e; // 将当前顶点的指针指向e e = (EdgeNode *)malloc(sizeof(EdgeNode)); // 申请内存空间，创建边表结点 e-&gt;adjvex = i; // 邻接序号为i e-&gt;next = G-&gt;adjList[j].firstEdge; // 将e指针指向当前顶点指向的结点 G-&gt;adjList[j].firstEdge = e; // 将当前顶点的指针指向e &#125;&#125; 有向图 邻接表结构 当图为有向图的时候，这个线性表叫做顶点 $v_i$ 作为弧尾的出边表。 网 邻接表结构]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迪杰斯特拉算法]]></title>
    <url>%2F2019%2F06%2F09%2F%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法</category>
        <category>迪杰斯特拉算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab主成分分析以及相关函数]]></title>
    <url>%2F2019%2F05%2F25%2Fmatlab%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[相关函数princomp-]]></content>
      <categories>
        <category>matlab</category>
        <category>主成分分析以及相关函数</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab解方程]]></title>
    <url>%2F2019%2F05%2F23%2Fmatlab%E8%A7%A3%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[syms 创建符号变量(或数组)和方程 diff diff函数式用于求导数和差分的.微分方程 dsolve 与solve函数类似可以使用向量式输入 一阶微分方程$dÿ/dt=ty$ 1234syms y（t）ode = diff（y，t）== t * yode（t）= diff（y（t），t）== t * y（t）ySol（t）= dsolve（ode） 如果增加一个条件y(0) = 2 12cond = y(0) == 2;ySol(t) = dsolve(ode,cond) $(dy/dt+y)^2=1,y(0)=0.$ 1234syms y(t)ode = (diff(y,t)+y)^2 == 1;cond = y(0) == 0;ySol(t) = dsolve(ode,cond) $du/dt=3u+4v,dv/Sdt=−4u+3v.$ 123456789101112syms u(t) v(t)%Define the equations using == and represent differentiation using the diff function.ode1 = diff(u) == 3*u + 4*v;ode2 = diff(v) == -4*u + 3*v;odes = [ode1; ode2]%odes(t) = diff(u(t), t) == 3*u(t) + 4*v(t) diff(v(t), t) == 3*v(t) - 4*u(t)%Solve the system using the dsolve function which returns the solutions as elements of a structure.S = dsolve(odes) 参考 dsolve csdn]]></content>
      <categories>
        <category>matlab</category>
        <category>解方程</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab文件的读取]]></title>
    <url>%2F2019%2F05%2F19%2Fmatlab%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%2F</url>
    <content type="text"><![CDATA[数据的导入与导出 注意设置当前路径为文件所在路径 save save save XXX;是将当前文件中的全部变量存起来，得到一个名为XXX.mat的文件。 save filename 是命令形式的语法。命令形式需要的特殊字符较少。您无需键入括号或者将输入括在单引号或双引号内。使用空格（而不是逗号）分隔各个输入项。 123456789例如，要保存名为 test.mat 的文件，这些语句是等效的：save test.mat % command formsave('test.mat') % function form您可以包括先前语法中介绍的任何输入。例如，要保存名为 X 的变量：save test.mat X % command formsave('test.mat','X') % function form当有任何输入（例如 filename）为变量或字符串时，请不要使用命令格式。 load load load filename 是该语法的命令形式。命令形式需要的特殊字符较少。您无需键入括号或者将输入括在单引号或双引号内。使用空格（而不是逗号）分隔各个输入项。 12345678910例如，要加载名为 durer.mat 的文件，以下语句是等效的：load durer.mat % command formload('durer.mat') % function form您可以包括先前语法中介绍的任何输入。例如，要加载名为 X 的变量：load durer.mat X % command formload('durer.mat','X') % function form当有任何输入（例如 filename）为变量或字符串时，请不要使用命令格式。 text文件的读取与写入textread textread 读取文本文件中的数据；写入多个输出 语法: [A,B,C,...] = textread(filename,format) [A,B,C,...] = textread(filename,format,N) [...] = textread(...,param,value,...) 必须严格遵守用法不可出现data=textread(filename,format,N)的形式 其中括号里面变量的个数必须和format中定义的个数相同。 textread不用先fopen那个文件，适用于格式统一的txt文件的一次性大批量读取。textread读取某个文件后，下次再用textread读取这个文件时，还是会从文件头开始读取。 [A,B,C,…]=textread（filename，format，N） [A,B,C,…]：读取的数据 Filename：文件名 Format：读取格式 N：读取次数 其中 N 是大于零的整数。如果 N 小于零，textread 将读取整个文件。 如果每N行相同格式的数据，可采用[A,B,C,…] = textread （filename,format,N）的语法，读取N次。 读取大型文本文件、从文件中的特定点读取或将文件数据读取到元胞数组而非多个输出时，您可以首选使用 textscan 函数。 textscan 导入混合格式文本 textscan(fid, &#39;format&#39;, N, &#39;param&#39;, value); 其中，fid为文件句柄；format为读取格式；N表示用该格式读取N次数据；’param’, value（可选项）指定分隔符和值对。 注意：使用textscan之前，必须先用fopen打开要读入的文件；函数textread用法类似。12345fid = fopen('myfile.txt');C = textscan(fid, '%s%s%f%d%s');fclose(fid)；使用textscan函数读取文件，输出C为1*5的细胞数组，每个数组中存放每列的数据 优势： textscan更适合读入大文件； textscan可以从文件的任何位置开始读入，而textread 只能从文件开头开始读入； textscan也可以从上一次textscan结束的位置开始读入，而textread不能； textscan只返回一个数组（其实应该说是一个细胞矩阵），而textread要返回多个数组（嗯嗯）； textscan提供更多转换读入数据的选择； textscan提供给用户更多的配置参数。 textread不用先fopen那个文件，适用于格式统一的txt文件的一次性大批量读取。而使用textscan函数之前需要先用fopen函数打开要读取的文件并返回句柄fid textscan函数每次读完数据后，其对应的句柄fid都是指向接下来要读数据的地方，类似于C函数中的文件读取指针，这样更方便于读取文本时的精确控制。 extscan函数可以将多组数据读到一个元胞矩阵中，而textread函数只能将数据分别读取到不同的向量中。比如一个含有10行3列浮点数的文件，textscan函数可以将之读取到一个变量名A下 A=textscan(fid, &#39;%f%f%f&#39;), 而使用textread函数必须将之读入到三个变量名中 [A,B,C] = textread（filename,&#39;%f%f%f&#39;）。 xls文件的读取与写入xlsread xlsread 读取 Microsoft Excel 电子表格文件 语法： num = xlsread(filename) 读取名为 filename 的 Microsoft® Excel® 电子表格工作表中的第一张工作表，并在一个矩阵中返回数值数据。 num = xlsread(filename,sheet) 读取指定的工作表。 num = xlsread(filename,xlRange) 从工作簿的第一个工作表的指定范围内读取数据。使用 Excel 范围语法，例如 ‘A1:C3’。 [num,txt,raw]=xlsread(&#39;data1.xlsx&#39;,&#39;Sheet1&#39;,&#39;A1:H4&#39;) 数据返回num；文本返回txt；不处理直接作为元胞返回raw A=xlsread(filename,sheet,’range’) A：读取的数据 Filename：文件名 Sheet：读取的工作表 Range：读取范围 filename - 文件名 字符向量 | 字符串 文件名，指定为字符向量或字符串。 示例： ‘myFile.xlsx’ 或 “myFile.xlsx” xlswrite 写入 Microsoft Excel 电子表格文件 语法: xlswrite(filename,A) 将矩阵 A 写入 Microsoft® Excel® 电子表格工作簿 filename 中的第一张工作表，从单元格 A1 开始写入。 xlswrite(filename,A,sheet) 将数据写入指定的工作表。 xlswrite(filename,A,xlRange) 将数据写入工作簿的第一个工作表中由 `xlRange 指定的矩形区域内。使用 Excel 范围语法，例如 ‘A1:C3’。 xlswrite(filename,A,sheet,xlRange) 将数据写入指定的工作表和范围。 status = xlswrite(___) 使用先前语法中的任何输入参数返回写入操作的状态。当操作成功时，status 为 1。否则，status 为 0。 xlRange - 矩形范围 字符向量 | 字符串 矩形范围，指定为字符向量或字符串。 使用两个对角指定 xlRange，这两个对角用来定义要写入的区域。例如，’D2:H4’ 表示工作表上两个角落 D2 和 H4 之间的 3×5 矩形区域。xlRange 输入不区分大小写，并使用 Excel A1 引用样式（请参阅 Excel 帮助）。xlswrite 不能识别命名范围。 s=xlswrite(filename,data,sheet,range) s:是否写入成功 Filename：文件名-Data：被写入的数据 Sheet：写入的工作表 Range：写入的范围]]></content>
      <categories>
        <category>matlab</category>
        <category>文件</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lingo]]></title>
    <url>%2F2019%2F05%2F19%2Flingo%2F</url>
    <content type="text"><![CDATA[lingo Lingo文件类型： 文件后缀名为“.lg4” 变量默认大于0，若取负数，要另外说明 每个语句必须以分号“;”结束，每行可以有多个语句，语句可以跨行； 可以给语句加上标号，例如[OBJ] MAX= … ; 以“!”开头，以“;”结束的语句是注释语句； 变量名称必须以字母(A-Z)开头，由字母、数字(0-9)和下划线“_”组成，长度不超过32个字符，不区分大小写； 求目标函数的最大值和最小值分别用MAX= …或MIN= …来表示； 直译法 对于简单的模型，可以直接照搬到lingo上，lingo是可以识别的 lingo模型以model:开头，end:结尾,对于简单的模型，可以省略 Lingo一般是把全部代码放在 model: ……. end 中间（就解决一个问题，省略也行），整个叫做模型段。12345678910111213model: sets: !定义集合(数据)类型; ..... endsets data: !数据的初始化; .... enddata min/max... 约束条件end 集合段：sets: …… endsets ——用来声明和定义数组变量； 数据段：data: …… enddata ——用数据对变量赋值； lingo中数据部分不能使用分式，例如数据部分不能使用1/3 初始化段: 在数据段给变量赋值以后,该变量在整个程序运行阶段都是 常量,而不是决策变量. 如果想对决策变量赋一定初始值,希望该初始值作为寻找最 优解的起始值(变量本身不是常量),可以在程序中增加初始 段 初始化段以语句INIT:开头,以语句ENDINIT结束 如下程序 INIT: X=0.99; Y=0.01; ENDINIT Y&lt;=@LOG(X); X^2+Y^2&lt;=1; 注: 初始化段只对非线性模型起作用,在线性模型中不起任何 作用. LINGO中建立的优化模型可以由六个部分组成，或称为六“段”。 123456集合段：用于定义数组型性变量SETS: ……ENDSETS数据段：用于变量赋值与数据传递DATA: ……ENDDATA目标与约束段：用于列出目标与约束唯一一个没有段的开始和结束标记计算段：用于数据初始整理计算CALC: ……ENDCALC初始段：用于变量赋初值迭代寻优INIT: ……ENDINIT子模型段：用于表达子模型进行调用@SUBMODEL mymodel:可执行语句（约束+目标）ENDSUBMODEL 注意：用[]表示该部分内容可选,[]内部可以是符号加其它 lingo中矩阵数据是按行存储的，matlab中数据是按列存储 lingo集合是按列赋值 实时数据处理 在某些情况，对于模型中的某些数据并不是定值。譬如模型中有一个通货膨胀率的参数，我们想在2%至6%范围内，对不同的值求解模型，来观察模型的结果对通货膨胀的依赖有多么敏感。我们把这种情况称为实时数据处理（what if analysis）。LINGO有一个特征可方便地做到这件事。在本该放数的地方输入一个问号（?）。 123data: interest_rate,inflation_rate = .085 ?;enddata 每一次求解模型时，LINGO都会提示为参数inflation_rate输入一个值。在WINDOWS操作系统下，将会接收到一个对话框.直接输入一个值再点击OK按钮，LINGO就会把输入的值指定给inflation_rate，然后继续求解模型。 除了参数之外，也可以实时输入集的属性值(定义的变量或常量)，但不允许实时输入集成员名(集合成员列表)。 数据部分的未知数值 有时只想为一个集的部分成员的某个属性指定值，而让其余成员的该属性保持未知，以便让LINGO去求出它们的最优值。在数据声明中输入两个相连的逗号表示该位置对应的集成员的属性值未知。两个逗号间可以有空格。 123456sets: years/1..5/: capacity;endsetsdata: capacity = ,34,20,,;enddata 属性capacity的第2个和第3个值分别为34和20，其余的未知。 集合 集合定义部分(类比c++) 集合是一组相关对象构成的组合 集合分为初始(基本\原始)集合和衍生(派生)集合 集合在使用之前需要预先给出定义, 初始集合的定义三要素: 集合的名称（结构体名称或者为c++类）, 集合的元素（也叫做成员列表，相当于c++类中的成员元素或者结构体中的成员）, 集合的属性(定义的变量或常量). lingo中集合的属性不要按之前想法理解。。。。 初始集合的定义格式: 集合的名称/集合的元素/:集合的属性; 衍生集合的定义四要素: 集合的名称, 对应的初始集合, 集合的元素(可以省略), 集合的属性(可以没有). 如果集合的元素省略不写, 则默认衍生集合的元素取它所对应初始集合的所有可能组合. 定义一个原始集，用下面的语法：setname[/member_list/][:attribute_list]; 在attribute_ list可以指定一个或多个集成员的属性，属性之间必须用逗号隔开。 Member_list是集成员列表 可以把集、集成员和集属性同C语言中的结构体作个类比。如下图： 集 ←→ 结构体/类名 集成员 ←→ 结构体的成员/类的成员 集属性 ←→ 定义的结构体/对象 衍生集合 12links(wh, wa):c; //此时的衍生集合c相当于二维矩阵(数组)，c++派生函数 数据初始化部分以“DATA:” 开始, 以ENDDATA结束， 这两个语句必须单独成一行； 数据之间的逗号和空格可以替换 supplys /1 .. 3/: S; 声明一个长度为 3 的一维数组 supplys, 并用它定义一个这样的一维数组变量 S. 先是数组名（随便起），再是用两个 / 夹在中间的是数组的下标范围，中间 .. 是省略表示法，接着用 : 定义数组变量 S。 demands/1..4/: D; 声明一个长度为 4 的一维数组 demands，并定义一个这样的一维数组变量 D。 links(supplys, demands): c, x; 声明一个 的二维数组 links，并用它定义两个这样的二维数组变量 c, x. 把两个一维数组放一起，起个名字叫 links，得到二维数组 links，第1个一维数组的维数就是二维数组的行数维度，第2个一维数组的维数就是二维数组的列数维度。 注意：这里 links 不是Lingo关键字，可以随便起名。 集部分以关键字sets:开始，以endsets结束。一个模型可以没有集部分，或有一个简单的集部分，或有多个集部分。一个集部分可以放置于模型的任何地方，但是一个集及其属性在模型约束中被引用之前必须定义了它们。 当显式罗列成员时，必须为每个成员输入一个不同的名字，中间用空格或逗号搁开，允许混合使用 当隐式罗列成员时，不必罗列出每个集成员。可采用如下语法：setname/member1..memberN/[: attribute_list]; 当用隐式罗列方式时，只需在集成员列表中输入首成员和末成员，而中间的成员由LINGO产生。 派生集 c++中的派生函数 可用下面的语法定义一个派生集：setname(parent_set_list)[/member_list/][:attribute_list]; setname是集的名字。parent_set_list是已定义的集的列表，多个时必须用逗号隔开。如果没有指定成员列表，那么LINGO会自动创建父集成员的所有组合作为派生集的成员。派生集的父集既可以是原始集，也可以是其它的派生集。(类似c++中派生函数) 一个派生集的成员列表有两种方式生成：①显式罗列；②设置成员资格过滤器 123456789101112131415sets: !学生集：性别属性sex，1表示男性，0表示女性；年龄属性age. ; students/John,Jill,Rose,Mike/:sex,age; !男学生和女学生的联系集：友好程度属性friend，[0，1]之间的数。 ; linkmf(students,students)|sex(&amp;1) #eq# 1 #and# sex(&amp;2) #eq# 0: friend; !男学生和女学生的友好程度大于0.5的集; linkmf2(linkmf) | friend(&amp;1,&amp;2) #ge# 0.5 : x;endsetsdata: sex,age = 1 16 0 14 0 17 0 13; friend = 0.3 0.5 0.6;enddata 用竖线（|）来标记一个成员资格过滤器的开始。 &amp;1可看作派生集的第1个原始父集的索引，它取遍该原始父集的所有成员；&amp;2可看作派生集的第2 个原始父集的索引，它取遍该原始父集的所有成员；&amp;3，&amp;4，……，以此类推。注意如果派生集B的父集是另外的派生集A，那么上面所说的原始父集是集A向前回溯到最终的原始集，其顺序保持不变，并且派生集A的过滤器对派生集B仍然有效。因此，派生集的索引个数是最终原始父集的个数，索引的取值是从原始父集到当前派生集所作限制的总和。 数据段补充 目标函数与目标条件 @sum@SUM是LINGO提供的内部函数，其作用是对某个集合的所有成员，求指定表达式的和. @SUM有两个参数：集合名称和表达式,如MIN = @SUM(LINKS(I, J): C(I, J)*X(I, J)); 如果表达式中参与运算的属性属于同一个集合，则@SUM的索引可以省略. 即MIN = @SUM(LINKS: C*X); 目标函数是求最小，所以用 “min=” 有 $\sum$，所以需要用到 @sum() 函数， 这是Lingo里的求和函数，首先得告诉它求和的范围， i 从1到3， j 从1到4，这不正好是前面声明的（对应的）二维数组 links 的大小吗，所以就用 links(i, j)来告诉（也只能用声明的数组来告诉），并用 i 表示行索引， j 表数列索引。 然后，冒号，求和里面的表达式。 @for是LINGO提供的内部函数，其作用是对某个集合的所有成员分别生成一个约束表达式.有两个参数：集合名和约束表达式 @FOR(WH(I): @SUM(VD(J): X(I, J)) &lt;= AI(I) );wh(i)是对集合wh的下标i进行循环，然后@sum内部的vd(j)是对集合vd的下标j进行循环，内外循环就是相当于二重for循环，外循环为i，内循环为j 函数 0-1规划中@bin限制为整数0或1 如果整数规划问题中的所有变量仅限于取0或1两个值，则称此问题为0-1整数规划，简称0-1规划，其变量为0-1变量. 金融函数 @fpa(I,n) @fpl(I,n) 运算符 LINGO中关系运算符有3种： &lt; (即&lt;=，小于等于) = (等于) &gt;(即&gt;=，大于等于) 用竖线（|）来标记一个成员资格过滤器的开始 这些运算符的优先级由高到低为：高 #not# #eq# #ne# #gt# #ge# #lt# #le#低 #and# #or# 下面给出以上三类操作符的优先级：1234567高 #not# ﹣（取反） ＾ ﹡ ／ ﹢﹣#eq# #ne# #gt# #ge# #lt# #le##and# #or#低 &lt;= = &gt;= 窗口 状态窗口 状态窗口(Solver Status)的详细的介绍如下： Model Class:模型类别显示的模型类别为LP, QP ILP, QP, ILP, IQP, LP, NLP等 Model Class 当前模型的类型 可能显示：LP(线性规划)，QP(二次规划)，ILP(整数线性规划)，IQP(整数二次规划)，PILP(纯整数线性规划)，PIQP(纯整数二次规划)，NLP(非线性规划)，MIP(混合整数规划)，INLP(整数非线性规划)，PINLP(纯整数非线性规划)． 注 以 I 开头表示 IP(整数规划)，以 PI 开头表示 PIP(纯整数规划)． State: Possible states are “Global Optimum”表示求出了全局最优解;, “Local Optimum”, “Feasible”可行解, “Infeasible”不可行, “Unbounded”无界, “Interrupted”, and “Undetermined”未确定. Objective: 目标函数的当前值. Infeasibility: 当前约束不满足的总量(不是不满足的约束的个数):实数（即使该值=0，当前解也可能不可行，因为这个量中没有考虑用上下界命令形式给出的约束） Iterations: 迭代次数 报告（Solve Report）窗口 Slack or Surplus（小于：松弛，大于：过剩）：如果满足约束条件,则该值是左右差的绝对值. 如果不满足约束条件,则该值为负数. 如果该值为0,说明两边相等. lingo灵敏度分析 灵敏度分析报告（Range Report） lingo只能对线性的模型做灵敏度分析 灵敏性分析是在求解模型时作出的，因此在求解模型时灵敏性分析是激活状态，但是默认是不激活的。为了激活灵敏性分析，运行LINGO|Options…，选择General Solver Tab， 在Dual Computations列表框中，选择Prices and Ranges选项。然后点击Apply按钮。 设置好了之后，你把需要进行灵敏度分析的程序写好了按 Ctrl+r 就行了]]></content>
      <categories>
        <category>lingo</category>
      </categories>
      <tags>
        <tag>lingo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2019%2F05%2F18%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树 任一棵树中，结点总数=度数*该度数对应的结点数+1 子节点个数为n0即各个度对应的个数乘以度减一然后累加后加1123456789101112131415已知一棵度为m的树中：n1个度为1的结点，n2个度为2的结点，…，nm个度m的结点，问该树中共有多少个叶子结点？设该树的总结点数为n，则n=n0+n1+n2+…+nm又：n=分枝数+1=0xn0+1xn1+2xn2+…+mxnm由上述两式可得：n0=n2+2n3+…+(m-1)nm+1即 dn0 =( Σ n(i) * (i - 1)) + 1 ​ i=1 (其中，i ∈ Integer，d为树的度) 树中边和结点的关系为：结点数=边数+1 -&gt; 边数 = 结点数-1 哈夫曼树 创建哈夫曼树并输出所有度为2的结点权值的和(huffman tree没有度为1的结点，度为0为叶子结点)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;using namespace std;struct huffman&#123; int data; int parent; int lchild; int rchild;&#125;;int n, i, a, b, sum;//a,b是构造过程中的用于构造哈夫曼树的两个结点的下标，sum是计算所有度为2的结点的权值之和，n是叶子结点个数huffman huff[105];const int INF = 0x3f3f3f3f;int select()&#123;//选出huff[1]到huff[i-1]中权值最小的且无父母结点的两个结点用以构造哈夫曼树 int huffdata1 = INF, huffdata2 = INF; for(int j = 1; j &lt;= i-1; j++)&#123; if(huff[j].parent == 0)&#123; if(huff[j].data &lt; huffdata1)&#123; if(huff[j].data &lt; huffdata2)&#123; switch(huffdata2 &gt; huffdata1)&#123; //注意因为huff[j].data可能小于huffdata2，而huffdata1如果小于huffdata2，那么应该将huffdata2权值更新为huffdata1，因为每次要选出结点权值最小的两个结点 case 1: huffdata2 = huffdata1; b = a; huffdata1 = huff[j].data; a = j; break; case 0: huffdata1 = huff[j].data; a = j; break; &#125; &#125; &#125; else if(huff[j].data &lt; huffdata2)&#123; huffdata2 = huff[j].data; b = j; &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; huff[i].data; huff[i].lchild = huff[i].rchild = huff[i].parent = 0; &#125; for(i = n+1; i &lt;= 2*n-1; i++) huff[i] = &#123;0, 0, 0, 0&#125;; for(i = n+1; i &lt;= 2*n-1; i++)&#123; select(); sum += huff[a].data + huff[b].data; huff[i].data = huff[a].data + huff[b].data; huff[a].parent = huff[b].parent = i; huff[i].lchild = a, huff[i].rchild = b; &#125; cout &lt;&lt; sum; return 0;&#125;模拟哈夫曼树构造过程:4 5 1 2 1 3 1 11 1 2 2 3 4 52 2 2 3 4 52 3 4 4 54 4 5 55 5 88 1018 二叉树二叉排序树查找123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdlib&gt;#define M 20using namespace std;struct node&#123; int data; struct node *l,*r;&#125;;int k = 0;int kk = 0;node *bst = NULL;node bstnode;int insert(node* &amp;bs, int k)&#123; if(bs == NULL)&#123; node* s = new node; s -&gt; data = k; s -&gt; l = NULL, s -&gt; r = NULL; bs = s; &#125; else if(k &lt; (bs) -&gt; data)&#123; insert(bs -&gt; l, k); &#125; else&#123; insert(bs -&gt; r, k); &#125; return 0;&#125; node* search(node* bs, int k)&#123; if(!bs) return NULL; else if(bs -&gt; data == k)&#123; kk++; return bs; &#125; else if(bs -&gt; data &gt; k) kk++, search(bs -&gt; l, k); else if(bs -&gt; data &lt; k) kk++, search(bs -&gt; r, k); return bs;&#125; int main()&#123; node *bs = NULL; cin &gt;&gt; k; while(1)&#123; insert(bs, k); cin &gt;&gt; k; if(k == -1) break; &#125; cin &gt;&gt; k; search(bs, k); cout &lt;&lt; kk; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数]]></title>
    <url>%2F2019%2F05%2F18%2F%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[美素数12345678910111213141516171819202122232425262728293031五：美素数Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 10835 Accepted Submission(s): 3669Problem Description 小明对数的研究比较热爱，一谈到数，脑子里就涌现出好多数的问题，今天，小明想考考你对素数的认识。 问题是这样的：一个十进制数，如果是素数，而且它的各位数字和也是素数，则称之为“美素数”，如29，本身是素数，而且2+9 = 11也是素数，所以它是美素数。 给定一个区间，你能计算出这个区间内有多少个美素数吗？ Input第一行输入一个正整数T，表示总共有T组数据(T &lt;= 10000)。接下来共T行，每行输入两个整数L，R(1&lt;= L &lt;= R &lt;= 1000000)，表示区间的左值和右值。 Output对于每组数据，先输出Case数，然后输出区间内美素数的个数（包括端点值L,R）。每组数据占一行，具体输出格式参见样例。 Sample Input31 1002 23 19 Sample OutputCase #1: 14Case #2: 1Case #3: 4]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F05%2F18%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[动态规划矩阵连乘问题1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int a[n+1]; for(int i = 0; i &lt;= n; i++) cin &gt;&gt; a[i]; //将输入从i = 1，改为i = 0， 就通过了，还未搞通 int d[100][100]; int dt; for(int i = 1; i &lt;= n; i++) d[i][i] = 0; for(int dis = 1; dis &lt; n; dis++)&#123; for(int i = 1, j = 1+dis; j &lt;= n; i++, j++)&#123; d[i][j] = 3242424; for(int k = i; k &lt; j; k++)&#123; dt = d[i][k]+d[k+1][j]+ a[i-1]*a[k]*a[j]; if(dt &lt; d[i][j])&#123; d[i][j] = dt; &#125; &#125; &#125; &#125; cout &lt;&lt; d[1][n];&#125; 数字三角形1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;using namespace std;int d[100][100];int a[100][100];int n;int ds(int i, int j)&#123; if(d[i][j] &gt;= 0) return d[i][j]; return d[i][j] = a[i][j]+(i == n?0:max(ds(i+1, j), ds(i+1, j+1) )); &#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; i+1; j++) cin &gt;&gt; a[i][j]; &#125; memset(d, -1, sizeof(d)); cout &lt;&lt; ds(0,0); &#125; 红鲤鱼与绿鲤鱼1234567891011121314151617181920第15周任务-红鲤鱼和绿鲤鱼时间限制：1秒 内存限制：128兆7 次提交 2 次通过题目描述Polarbear（P.B.）有很多红鲤鱼和绿鲤鱼，它们在鱼缸排成一列，非常好看。P.B.可以任选一条鲤鱼把它染成红色或绿色，它的目标是在完成染色之后，让每条红色的鲤鱼R都比绿色的鲤鱼G离左侧更近（当然当所有鲤鱼颜色都相同时，很显然也满足这个条件）。P.B.想知道它最少需要涂染几条鲤鱼。如样例所示: s = RGRGRR我们涂染之后变成RRRRRR就满足要求了,涂染的个数为2,没有比这个更好的涂染方案。输入输入包括一个字符串s,字符串s长度length(1&lt;=length&lt;=50),其中只包括'R'或者'G',分别表示红鲤鱼和绿鲤鱼。输出输出一个整数,表示P.B.最少需要涂染的鲤鱼的数量。样例输入RGRGRR样例输出2题目分析：本题也是一道动态规划思想的题目，每次有两种选择，在所有选择中找最优选择方案。由于这题数据范围比较小。所有大部分人暴力的方法用双重循环遍历所有选择方案，最后也能解决问题。这是方法的时间复杂度是O（n^2），但是如果我给的字符串长度超过了10000，这种方法基本就无法解决问题了。这里我用动态规划的思想给出一种O（n）的解决方法。可以参照你们的解法和我的解法的区别，体会动态规划的思想和暴力解法的不同之处。 如何推导出状态转移方程式动态规划的难点，例如本题的状态转移方程就是:dp[1][i] = min(dp[0][i-1]), dp[1][i-1]) + (str[i] == ‘G’ ? 0 : 1);即第i次染色的最少染色次数为：[0,i-1]区间最少染色次数加上当前是否染色。则完成了[0,i-1]到[0,i]区间最优解的转移。 01背包12345678910111213141516171819202122第15周任务-01背包时间限制：1秒 内存限制：128兆26 次提交 5 次通过题目描述背包最大允许装载为C, 有n个物品要放进背包，每个物品的重量为w[1],w[2],...w[n],每个物品的价值为v[1],v[2],...v[n], 请选择物品装进背包，使得价值最大。C为整数。输入第一行为物体个数n,以及背包容量C；第二行为n个重量（实数），空格隔开第三行为n个价值（实数），空格隔开输出第一行为最大装载的总价值第二行为每个物品是否装载，1表示装，0表示不装，中间用空格隔开(测试数据能保证最优解唯一)样例输入5 102 2 6 5 46 3 5 4 6样例输出151 1 0 0 10-1背包是动态规划问题非常经典的一个入门题，可以从多个方面来理解0-1背包推导过程。这里我用递归到递推两种形式来给出0-1背包问题解决方法。 1、递归解法：递归的方法较为直观，可以很直观的看出状态转移的思路。但是可能递归的中间过程比较难以想象。但是递归的思维方式比较简单，只需要抓住两点：递归终点和递归方程。终点就是在递归的边界情况的返回值，递归方程即从当前节点继续搜索子问题的最优解。注意结合这里递归方程理解dp中的状态转移方程。 很明显这种方式无法记录我们最后选择了那些物品，而且在递归的过程中存在很多不必要的搜索，所以我们需要用到记忆化搜索来剪枝并且记录节点的选择。 2、递推解法递推的方法其实也就是我们用到的双重循环，实际上我们可以把循环递推看成递归的一个逆过程。递归是当前不知道当前最优解，一直往子问题搜索，直到递归到子问题的边界然后开始回退，依次求出路径中的最优解。而递推则是通过已知的最优解通过状态转移方程逐步递推下一步的最优解，和贪心思想相似，只不过这里的最优解是动态的可修改的。我看见大家都是写的二维数组，这里我提供一个一维数组的方法。]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n皇后]]></title>
    <url>%2F2019%2F05%2F17%2Fn%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[n皇后位运算版1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;long sum=0, upperlim=1; void test(long row, long ld, long rd)&#123; if (row!=upperlim) //row表示为表示对应行的列是放置，放置了放1，没放置放0； &#123; long pos = upperlim &amp; ~(row | ld | rd); //可以放置的列的位置,对应位为0， while (pos) //pos为0 皇后没有地方可放，回溯； &#123; long p=pos&amp;-pos; //取得可以放皇后的最右边的列，其余bit置0 pos-=p; //将最后边的列置为0，为下一次选可放置的列做准备，后面并没有用 //其用途用于循环判断以及求出下一个p ----我的注释 test(row+p, (ld+p)&lt;&lt;1,(rd+p)&gt;&gt;1); //row ,ld,rd的新的值记录用于排除下一行禁忌列； &#125; &#125; else sum++;&#125;int main(int argc, char *argv[])&#123; int n; scanf("%d",&amp;n); upperlim = (upperlim &lt;&lt; n) - 1; //移位减一，让可以放皇后的所有的行的存储列的位置置为1； test(0, 0, 0); printf("%d\n", sum); return 0;&#125; 回溯法 用数组c[row]表示第row行放置在第i列，check()函数检查是否满足条件，满足则放置下一行，否侧继续循环找到可放置的解或者回溯12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int total = 0;int n;int c[17];int check(int cow)&#123; for(int i = 0; i &lt; cow; i++)&#123; if(c[cow] == c[i]||abs(c[cow] - c[i]) == cow - i) return 0; &#125; return 1;&#125;int queen(int cow)&#123; if(cow == n) total++; else&#123; for(int i = 0; i &lt; n; i++)&#123; c[cow] = i; if(check(cow)) queen(cow+1); &#125; &#125; return 0;&#125;int main()&#123; cin &gt;&gt; n; queen(0); cout &lt;&lt; total; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%A0%88%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[基本操作 stl中stack出栈，如例：s.pop();注意，出栈操作只是删除栈顶元素，并不返回该元素 运用 任何出栈的元素后面出栈的元素必须满足以下三点，在原序列中相对位置比它小的，对于该元素后面必须是逆序 (2n)!/(n!(n+1)!)为出栈顺序总类数后缀表达式 后缀表达式又称逆波兰表达式，后缀记法 后缀表达式计算机求值 与前缀表达式类似，只是顺序是从左至右： 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 步骤: 题目：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109ctguoj191.2016栈与队_表达式转换 (20分) C时间限制：3000 毫秒 | C内存限制：3000 Kb题目内容： 算术表达式有前缀表示法、中缀表示法、后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，即二元运算符位于两个运算数之间。请设计程序将中缀表达式转换为后缀表达式。中缀表示：2+3-4后缀表示：2 3 + 4 -， 符号在两个运算数据的后面。后缀表达有很多好处，例如可以不要括号，见下面的样例。 输入描述输入在一行中给出不含空格的中缀表达式，可包含+、-、*、/、（、）运算符，以#结束表达式输出描述在一行中给出转换后的表达式，要求不同对象（运算数、运算符号）之间以空格分隔输入样例2+3*(7-4)##include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;stack&lt;char&gt; st2; stack&lt;char&gt; st;int compre(char a)&#123; switch(a)&#123; case '*': case '/': return 1; default: if(!st.empty())&#123; char b = st.top(); if(b == '*'||b == '/') return 0; else return 1; &#125; else&#123; return 1; &#125; &#125;&#125;int main()&#123; string str; cin &gt;&gt; str; int i; for(i = 0; i &lt; str.size(); i++)&#123; switch(str[i])&#123; case '(': case ')': //((2+3)*4-(8+2))/5# if(str[i] == '(') st.push(str[i]); else&#123; if(!st.empty())&#123; char a = st.top(); int c = st.size(); for(int j = 0; j &lt; c; j++)&#123; a = st.top(); if(a != '(') st2.push(a); st.pop(); &#125; &#125; &#125; break; case '*': case '/': case '-': case '+': if(st.empty() || (st.top() == '(') )&#123; st.push(str[i]); &#125; else&#123; if(compre(str[i])) st.push(str[i]); else&#123; int a = st.top(); st2.push(a); st.pop(); if(compre(str[i])) st.push(str[i]); &#125; &#125; break; case '#': break; default: st2.push(str[i]); &#125; &#125; int size1 = st.size(); for(i = 0; i &lt; size1; i++)&#123; st2.push( st.top() ); st.pop(); &#125; string str2; int size2 = st2.size(); for(i = size2-1; i &gt;= 0; i--)&#123; if(!st2.empty())&#123; str2 += st2.top(); st2.pop(); &#125; &#125; for(i = str2.length()-1; i &gt;= 0; i--)&#123; if(str2[i] != '(') cout &lt;&lt; str2[i] &lt;&lt; " "; else continue;&#125;//((2+3)*4-(8+2))/5# return 0;&#125; 括号匹配 检验表达式中左右括号(多种&amp;&amp;嵌套)是否可以对应匹配12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;int march(char a, char b)&#123; switch(a)&#123; case '(': if(b == ')') return 1; else return 0; break; case '[': if(b == ']') return 1; else return 0; break; case '&#123;': if(b == '&#125;') return 1; else return 0; break; &#125; &#125;int main()&#123; int k = 0; string str; stack&lt;char&gt; st; cin &gt;&gt; str; for(int i = 0; i &lt; str.size()-1; i++)&#123; switch(str[i])&#123; case '(': case '[': case '&#123;': case ')': case ']': case '&#125;': k = 1; break; &#125; if(k == 1) break; &#125; if(k == 0)&#123; cout &lt;&lt; "NO"; return 0; &#125; for(int i = 0; i &lt; str.size()-1; i++)&#123; switch(str[i])&#123; case '(': case '[': case '&#123;': st.push(str[i]); break; case ')': case ']': case '&#125;': if(st.empty())&#123; cout &lt;&lt; "NO"; return 0; &#125; else&#123; if( march(str[i], st.top()) )&#123; st.pop(); &#125; else&#123; cout &lt;&lt; "NO"; return 0; &#125; &#125; &#125; &#125; if(st.empty()) cout &lt;&lt; "YES"; else&#123; cout &lt;&lt; "NO"; &#125; return 0;&#125; 资料 博客园]]></content>
      <categories>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的创建与遍历]]></title>
    <url>%2F2019%2F05%2F08%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树创建与遍历 对于每个节点来说,每个节点自身又是根结点，所以任然遍历到自身，会访问到自身值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt; #define Dtype char using namespace std; typedef struct Node&#123; Dtype data; struct Node *LChild; struct Node *RChild; &#125;Bnode,* Btree; void visit(Bnode *root) &#123; if(root != NULL)&#123; cout &lt;&lt; root-&gt;data &lt;&lt; " "; &#125; &#125; void CreateBtree(Btree &amp;t) &#123; Dtype e; cin &gt;&gt; e; if(e == '#') t = NULL; else &#123; t = (Btree)malloc(sizeof(Bnode)); t-&gt;data = e; CreateBtree(t-&gt;LChild); CreateBtree(t-&gt;RChild); &#125; &#125; void Pre_visit(Btree t) //前序遍历 &#123; if(t) &#123; visit(t); Pre_visit(t-&gt;LChild); Pre_visit(t-&gt;RChild); &#125; &#125; void In_visit(Btree t) //中序遍历 &#123; if(t) &#123; In_visit(t-&gt;LChild); visit(t); In_visit(t-&gt;RChild); &#125; &#125; void Post_visit(Btree t) //后序遍历 &#123; if(t) &#123; Post_visit(t-&gt;LChild); Post_visit(t-&gt;RChild); visit(t); &#125; &#125; void print_leaf(Btree t) &#123; if(t) &#123; if(!t-&gt;LChild &amp;&amp; !t-&gt;RChild) cout &lt;&lt; t-&gt;data &lt;&lt; " "; print_leaf(t-&gt;LChild); print_leaf(t-&gt;RChild); &#125; &#125; int PostTreeDepth(Btree t) &#123; int h1,h2,max; if(t) &#123; h1 = PostTreeDepth(t-&gt;LChild); h2 = PostTreeDepth(t-&gt;RChild); max = h1 &gt; h2 ? h1 : h2; return max+1; &#125; else return 0; &#125; int main() &#123; Btree t; CreateBtree(t); cout &lt;&lt; "前序遍历二叉树" &lt;&lt; endl; Pre_visit(t); cout &lt;&lt; endl &lt;&lt; "中序序遍历二叉树" &lt;&lt; endl; In_visit(t); cout &lt;&lt; endl &lt;&lt; "后序遍历二叉树：" &lt;&lt; endl; Post_visit(t); cout &lt;&lt; endl &lt;&lt; "输出叶子节点：" &lt;&lt; endl; print_leaf(t); cout &lt;&lt; endl &lt;&lt; "输出树的深度：" &lt;&lt; endl; cout &lt;&lt; PostTreeDepth(t) &lt;&lt; endl; return 0; &#125; /* a b # d f # # g # # c # e # h # # */ 二叉树练习 先序遍历用顺序存储的二叉树 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int n;int tree[10000];int preorder(int a)&#123; if(a &gt;= n+1) return 0; cout &lt;&lt; tree[a] &lt;&lt; " "; if(2*a &lt;= n) preorder(2*a); if(2*a+1 &lt;= n) preorder(2*a+1); return 0;&#125;int main()&#123; int i; cin &gt;&gt; n; for(i = 1; i &lt; n+1; i++) cin &gt;&gt; tree[i]; tree[i] = -1; preorder(1); return 0;&#125; 一维数组输树输出中序遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172580.数据结构第六章-二叉树顺序存储变链式存储 (20分) C时间限制：3000 毫秒 | C内存限制：3000 Kb题目内容： 一个二叉树不是完全的，也可以类似于完全二叉树存储在一维数组中，只是那些树中的空孩子结点的所应在的数组元素也空起来。因此这种表示方法有空间的浪费。写一个算法将顺序存储的普通二叉树转变为链式存储结构。然后输出中序遍历的结果输入描述先输入n，再输入n个整数到一维数组，数组中正整数表示结点值，而-1表示该处没有结点输出描述最后中序遍历的结果输入样例72 -1 3 -1 -1 4 2输出样例2 3 4 2#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n;int a[10000], k[100];int judge(int i)&#123; if(2*i &lt;= n)&#123; if(a[2*i] != -1) return 0; &#125; return 1;&#125;int tree(int ii)&#123; for(int i = ii; i &lt;= n; i++)&#123; if(a[i] != -1)&#123; if(2*i &lt;= n)&#123; if(a[2*i] != -1)&#123; if(judge(2*i)&amp;&amp;k[2*i] != -1)&#123; cout &lt;&lt; a[2*i] &lt;&lt; " "; k[2*i] = -1; &#125; tree(2*i); &#125; if(k[i] != -1)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; k[i] = -1; &#125; if(2*i+1 &lt;= n)&#123; if(a[2*i+1] != -1)&#123; if(judge(2*i+1)&amp;&amp;k[2*i+1] != -1)&#123; cout &lt;&lt; a[2*i+1] &lt;&lt; " "; k[2*i+1] = -1; &#125; tree(2*i+1); &#125; &#125; &#125; &#125; &#125; return 0;&#125;int main()&#123; cin &gt;&gt; n; memset(k, 0, sizeof(k)); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; tree(1); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub扩展]]></title>
    <url>%2F2019%2F04%2F29%2FGitHub%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[汇总 扩展 October 它在 GitHub 页面的左侧上方添加了一个按钮，点击后会展开一个菜单，显示当前项目的整个文件夹结构。你可以浏览或下载单个源文件]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器以及扩展]]></title>
    <url>%2F2019%2F04%2F29%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[edge扩展 油猴子tamperMonkey 链接 uBlock Origin 广告过滤“新牌”扩展 Video Downloader Professional:下载网页上的视频 欢迎来到 Greasy Fork，这里是一个提供用户脚本的网站。 Greasy Fork OpenUserJs 鼠标手势 grammarly for microsoft edge softonic 百分浏览器 emmm一堆]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客与GitHub进阶操作]]></title>
    <url>%2F2019%2F04%2F29%2Fhexo%E5%8D%9A%E5%AE%A2%E4%B8%8EGitHub%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[GitHub与hexo GitHub改名后使用hexo clean命令清除之前的网页信息(改名后一些设置与图片丢失),再重新上传 每次优化博客，新增了一些功能布局什么的，可以先用hexo clean确保可以立马实现(不然博客可能一时半会跟原来一样) GitHub上commit可以查看历史提交记录，修改记录与相应时间的仓库原状，可以clone/download历史版本 $ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 主题文件中avatar更改头像，favicon更改网页头像 注意事项 swig与js]]></content>
      <categories>
        <category>blog</category>
        <category>捣鼓记</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数汇总]]></title>
    <url>%2F2019%2F04%2F27%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[kron Kronecker 张量积 语法: K = kron(A,B) 返回矩阵 A 和 B 的 Kronecker 张量积。如果 A 是 m×n 矩阵，而 B 是 p×q 矩阵，则 kron(A,B)是通过获取 A 元素与矩阵 B 元素之间的所有可能积而形成的一个 mp×nq 矩阵。 如果 A 是 m×n 矩阵，而 B 是 p×q 矩阵，则 A 和 B 的 Kronecker 张量积是通过将 B 乘以 A 的各元素形成的一个大型矩阵。 ismember ismember intersect 设置两个数组的交集 mat2str 将矩阵转换为字符]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>汇总</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab实现dfs/bfs]]></title>
    <url>%2F2019%2F04%2F27%2Fmatlab%E5%AE%9E%E7%8E%B0dfs-bfs%2F</url>
    <content type="text"><![CDATA[dfs与bfs Matlab 深度优先搜索求解迷宫问题 Matlab 广度优先搜索求解迷宫问题 12345678910111213141516171819clc,clear;%a = kron(eye (2),[-1 1] )%a(:,1)%maze = [0 2 5 5 1 0 1 1 5 1 0 1 3 5 1 0 1 0 0 1];%ismember(maze(1,1),[1,2,5] )%maze = [1 2 3 4 5 2 23 3 1 5];%ismember(maze,[1:3])% 定义四个方向%directions = kron(eye(2),[-1,1]);% 路径个数%sol = 0;% [I,J] = find(maze == 2);% 找到起点]]></content>
      <categories>
        <category>matlab</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2019%2F04%2F20%2Fgit%2F</url>
    <content type="text"><![CDATA[git起步 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存(staged),git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库 如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果 git clone –bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。 windows下编辑文本文件时最好用Notepad++而不要用自带记事本，因为后者在文件头部添加的十六进制字符0xefbbbf容易导致编译报错。Notepad++最好设置默认编码为UTF-8 (without BOM) Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令基础 基础命令 pwd命令用于显示当前目录。 如果使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名(包括父目录)不包含中文。 通过git init命令把目录变成Git可以管理的仓库： 添加文件到Git仓库，分两步： 使用命令git add &lt; file &gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt; message &gt;，完成。 git status查看工作区状态 git diff查看difference(修改的内容) cat &lt; file &gt;查看文件内容 版本回退 HEAD指向的版本是当前版本，HEAD^表示上一个版本，HEAD^^前一个的上个版本,HEAD~n前第n个版本 git log可以查看提交历史 git reflog可以查看命令历史，查看commit_id(版本号) git reset --hard &lt; commid id&gt;回到该版本号的版本 git reset --hard HEAD^回到上一版本 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 克隆仓库的命令格式为 git clone [url]。 管理修改 git diff比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --cached 命令。 请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。 git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area Git跟踪并管理的是修改，而非文件 Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 git diff HEAD -- &lt; file &gt;命令可以查看工作区和版本库里面最新版本的区别 撤销修改 命令git checkout -- &lt; file &gt;意思就是，把file在工作区的修改全部撤销，这里有两种情况: 一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git reset HEAD &lt; file &gt;可以把暂存区的修改撤销掉，HEAD表示当前版本(最新). 若已经提交到版本库，修改就要用版本回退 删除文件 1.先手动删除文件后，若想继续删除版本库里的文件，则git rm &lt; file &gt;,然后更新版本库git commit -m &quot;remove &lt; file &gt;&quot;，若想恢复文件，则git checkout -- &lt; file &gt; 注意git rm &lt;file&gt;和git add&lt;file&gt;在这里都可以 git checkout是用版本库里的版本替代工作区里的版本 2.使用命令rm &lt; file &gt; 远程仓库 远程仓库是指托管在网络上的项目仓库 如果在GitHub上创建仓库时默认了创建readme.md，那么刚刚建立的仓库中因为没有该md文件，所以要么删除md文件，要么git pull origin master --allow-unrelated-histories,然后进入编辑器后，若填写好原因，那么按ESC，：，wq的顺序先后按出. 貌似可以先clone一下也可以，那样md文件也同步了 新建仓库，然后在文件夹git remote add origin git@github.com:Github账号名/仓库名.git 远程仓库默认名字为origin git remote add [shortname] [url] 要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字 也可以加上 -v 选项（译注：此为 –verbose 的简写，取首字母），显示对应的克隆地址： git push [remote-name] [branch-name]推送数据到远程仓库。 克隆操作会自动使用默认的 master 和 origin 名字 只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。 如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。(类似于第二条readme.md,因为必须同步) 关联后，使用命令git push -u origin master第一次推送master分支的所有内容 git remote show [remote-name] 查看某个远程仓库的详细信息 远程仓库的删除和重命名，在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行： 1234$ git remote rename pb paul$ git remoteoriginpaul 注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm命令： 123$ git remote rm paul$ git remoteorigin git clone [url]从远程仓库clone下来 分支 Git 保存的不是文件差异或者变化量，而只是一系列文件快照 在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先 不想看了，先放着哈哈哈哈哈 唧唧复唧唧 打标签 列出现有标签的命令非常简单，直接运行 git tag 即可 显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。 以用特定的搜索模式列出符合条件的标签,若只对1.4.2系列的版本感兴趣12345$ git tag -l &apos;v1.4.2.*&apos;v1.4.2.1v1.4.2.2v1.4.2.3v1.4.2.4 Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated） 。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般建议使用含附注型的标签，以便保留相关信息 含附注的标签 创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可 而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。12345$ git tag -a v1.4 -m &apos;my hero 1.4&apos;$ git tagv0.1v1.3v1.4 可以使用 git show 版本号 命令查看相应标签的版本信息，并连同显示打标签时的提交对象 轻量级标签 轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可git tag 名字 运行 git show 查看此标签信息，就只有相应的提交对象摘要 验证标签 可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证 后期加注标签 只要在打标签的时候跟上对应提交对象的校验和（或前几位字符） 分享标签 默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可 如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项 现在，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。 技巧与窍门 在输入 Git 命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议 然后输入s，再敲一下tab会自动补全，然后可以继续tab，看看有没有相关命令，tab多敲几下就知道了12$ git pu&lt;tab&gt;&lt;tab&gt;pull push 可以用 git config 为命令设置别名 若要输入git commit只要输入git ci即可 使用这种技术还可以创造出新的命令，比方说取消暂存文件时的输入比较繁琐12345678910$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status//简化$ git config --global alias.unstage 'reset HEAD --'//与下面相同$ git unstage fileA$ git reset HEAD fileA GitHub实用指南 在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码。 Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README（仅限博客） GitHub创建仓库最好不要用中文,路径也是 GitHub Pages GitHub Pages is a static site hosting service designed to host your personal, organization, or project pages directly from a GitHub repository. 查询资料 Pro git Git 教程-廖雪峰]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客网页访问量与访客计数问题]]></title>
    <url>%2F2019%2F04%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E7%BD%91%E9%A1%B5%E8%AE%BF%E9%97%AE%E9%87%8F%E4%B8%8E%E8%AE%BF%E5%AE%A2%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[访问量解决 busuanzi域名改了⛷🏂1&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>blog</category>
        <category>博客优化</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm小思路小技巧]]></title>
    <url>%2F2019%2F04%2F20%2Falgorithm%E5%B0%8F%E6%80%9D%E8%B7%AF%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[数学题 小明用字母A 对应数字1，B 对应2，以此类推，用Z 对应26。对于27以上的数字，小明用两位或更长位的字符串来对应，例如AA 对应27，AB 对应28，AZ 对应52，LQ 对应329。请问2019 对应的字符串是什么？ 用ABCD替换掉了1234, 注意26个字母应该是逢27进1, 也就是27进制, 而不是26进制1234567891011121314151617181920212223242526272829303132333435363738394041424344%法一#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;string solve(int n, int r)&#123; string ret; while(n &gt; 0)&#123; int t = n%r; n = (n-1)/r; //不是26进制 if(t == 0) t = 26; ret += 'A'+t-1; &#125; return ret;&#125;int main()&#123; int n; cin &gt;&gt; n; string ans = solve(n, 26); for(int i = ans.length()-1; i &gt;= 0; i--) cout &lt;&lt; ans[i]; return 0;&#125;%法二#include &lt;bits/stdc++.h&gt;using namespace std;//702 --&gt; ZZ//703 --&gt; AAA//18278 --&gt; ZZZ//18279 --&gt; AAAAvoid dfs(int N) &#123; if (N &gt; 26) dfs((N - 1) / 26); putchar('A' + (N - 1) % 26);&#125;int main() &#123; int N; while (cin &gt;&gt; N) &#123; dfs(N); cout &lt;&lt; endl; &#125; return 0;&#125; n转r进制的模板1234567891011121314 void solve(int n, int r) &#123; char ans[maxn], index = 0; ms(ans, 0); while(n &gt; 0)&#123; int t = n%r; n /= r; if(t &gt; 9) ans[index++] = (t-10+'A'); else ans[index++] = (t+'0'); &#125; &#125;//从后往前输出 给定数列1, 1, 1, 3, 5, 9, 17, …，从第4 项开始，每项都是前3 项的和。求第20190324 项的最后4 位数字。 1234567891011121314151617181920212223242526272829%一#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 30000000;int a[MAXN];int main() &#123; int N = 20190324; a[1] = a[2] = a[3] = 1; for (int i = 4; i &lt;= N; ++i) a[i] = (a[i - 1] + a[i - 2] + a[i - 3]) % 10000; printf("%d\n", a[N]); return 0;&#125;%二#include &lt;cstdio&gt;using namespace std;int main() &#123; int a = 1, b = 1, c = 1; int N = 20190324; //scanf("%d", &amp;N); for (int i = 4; i &lt;= N; ++i) &#123; int t = (a + b + c) % 10000; c = b; b = a; a = t; &#125; printf("%d\n", a); return 0;&#125; 把2019 分解成3 个各不相同的正整数之和，并且要求每个正整数都不包含数字 2 和 4，一共有多少种不同的分解方法？注意交换3个整数的顺序被视为同一种方法，例如1000+1001+18 和 1001+1000+18 被视为同一种。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;bool isOK(int x) &#123; for (/* */; x &gt; 0; x /= 10) if (x % 10 == 2 || x % 10 == 4) return false; return true;&#125;int main() &#123; int N = 2019; int cnt = 0; for (int i = 1; i &lt; N / 3; ++i) if (isOK(i)) //k = N - i - j &gt; j //判断重复可以i &lt; j &lt; k, 然后判断i, j, k是否含2和4就行了 for (int j = i + 1; N - i - j &gt; j; ++j) if (isOK(j) &amp;&amp; isOK(N - i - j)) ++cnt; cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125; 小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导0），在1 到 40 中这样的数包括1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。请问，在 1 到n 中，所有这样的数的和是多少？ 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int N;bool isOK(int x) &#123; for (/* */; x &gt; 0; x /= 10) &#123; int t = x % 10; if (t % 10 == 2 || t % 10 == 0 || t % 10 == 1 || t % 10 == 9) return true; &#125; return false;&#125;int main() &#123; cin &gt;&gt; N; int ret = 0; for (int i = 1; i &lt;= N; ++i) if (isOK(i)) ret += i; cout &lt;&lt; ret &lt;&lt; endl; return 0;&#125; 奕奕的几何很差，然而奕奕并不承认，所以华华扔给奕奕一道题目。如图： 已知大半圆的半径等于两个小半圆半径之和。若给出红色部分的面积，那么大圆的半径最小是多少呢？反正奕奕是不会的，所以现在请你回答。 链接：https://ac.nowcoder.com/acm/contest/894/A来源：牛客网 精度问题，因为刚开始使用pi = 3.1415，通过很少样例，然后改用3.14159265，通过的多一些，之后改用acos(-1)通过更多，然后因为s刚开始为int型，所以后改用为double类型，才通过所有样例 注意.3lf输出时，用四舍五入，该题精度有四舍五入12345678910#include&lt;cstdio&gt;#define pi 3.14259265#include&lt;cmath&gt;int main()&#123; double s; double r; scanf("%lf", &amp;s); r =sqrt( 4*s/acos(-1)); printf("%.3lf", r);&#125; 枚举a的每一位1234while(a != 0)&#123; if(a%10 == m) ... a /= 10;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab函数之vpa]]></title>
    <url>%2F2019%2F04%2F18%2Fmatlab%E5%87%BD%E6%95%B0%E4%B9%8Bvpa%2F</url>
    <content type="text"><![CDATA[vpa vpa]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>vpa</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab代码练习二]]></title>
    <url>%2F2019%2F04%2F18%2Fmatlab%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[competition 提取12345和67899这两个五位数的每一位数字，并把他们存储到一个2*5的矩阵里。 要求矩阵第一行是12345从万位到个位的所有位数字，第二行为67899从个位到万位的所有位数字123456clc,clear;a=12345;b=67899;a=str2num(num2str(a)')';b=fliplr(str2num(num2str(b')')');[a;b] 以pi/100为间隔，比较函数sin(2x+3)和cos(3x-1)在0到2π的函数值大小，只画出函数值相对较大的那一部分图像。 123456clc;clear;close all;x=0:pi/100:2*pi;y1=sin(2*x+3);y2=cos(3*x-1);plot(x,max(y1,y2)); 有如下数列：1 3 59 8 74 2 1 3 46 8 7 4 5 6 9 8 5 4 22 25 52 32 64 62 13 1 61 31 31 32 15 4 54 32 24 23 24 15 21 10 30 45 56 14 24 34 13 21 24 23 35 26 15 14 12 13 142 412 43 16 23 4 55 25 21 24 34 12 34 12 43 12 43 14 23 14 12 23 14 21 23 74 14 ； 求出数列中每个数出现的次数. 并按原序列先后顺序输出(其中相同的数字只保留第一次出现的)。1234567891011121314151617181920clc,clear;a=[1 3 59 8 74 2 1 3 46 8 ... 7 4 5 6 9 8 5 4 ... 22 25 52 32 64 62 13 ... 1 61 31 31 32 15 4 54 32 ... 24 23 24 15 21 10 30 45 56 ... 14 24 34 13 21 24 23 35 26 ... 15 14 12 13 142 412 43 16 23 ... 4 55 25 21 24 34 12 34 12 ... 43 12 43 14 23 14 12 ... 23 14 21 23 74 14];A=unique(a,'stable')for i=1:length(A) [m,n]=find(a==A(i)); if length(m)&gt;=2 %用的好，因为find函数放回的是向量(若向量长度大于2，那么说明该数的横坐标有多个，所以出现了多次) disp(strcat(num2str(A(i)),'重复',num2str(length(m)),... '次','位置为:',mat2str([m n]))) end end 随机生成四组坐标，判断第四个点是否在前三个点构成的三角形内（不包括线上），并画出图像，计算精度为5位有效数字。 （海伦公式：假设在平面内，有一个三角形，边长分别为a、b、c，三角形的面积S可由以下公式求得：..而公式里的p为周长的一半）123456789101112131415161718clc,clear;a=rand(4,2);d=squareform(pdist(a));f=@(a,b,c)sqrt((a+b+c)/2*((a+b+c)/2-a)*((a+b+c)/2-b)*((a+b+c)/2-c));s1=f(d(1,2),d(1,3),d(2,3));s2=f(d(1,2),d(1,4),d(2,4))+f(d(1,3),d(1,4),d(3,4))+f(d(3,2),d(3,4),d(2,4));if vpa(s1,5)==vpa(s2,5) fprintf('第四个点在前三个点组成的三角形内')else fprintf('第四个点不在前三个点组成的三角形内')endx=a(:,1)';y=a(:,2)';x1=[x(1:3) x(1)];y1=[y(1:3) y(1)];plot(x1,y1,'b-')%用plot画封闭曲线需要在最后添上第一个点的坐标text(x+0.01,y+0.01,&#123;'1' '2' '3' '4'&#125;)hold onplot(x,y,'ro')s1-s2 这题跟算法博弈不一样，matlab。。。。 CTGUMCM是一个大佬云集的地方。已知矩阵a如图4所示，其中1表示大佬，0表示小白。 （1）在这里大佬小白各有多少位呢？试分别统计，并将大佬们的位置存储在矩阵z中。 （2）大佬们在这里喜欢抱团。我们称位置（x,y）与其上下左右四个位置（x,y+1）,(x,y-1), (x+1,y),(x-1,y)是相邻的。如果矩阵中有若干个1是相邻的（不必两两相邻），那么称这些1构成了一个“大佬集”，试求矩阵a中“大佬集”的个数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950clc,clear;a = [0 1 1 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 0 1 1 1 0 1 0 0 1 1 1 1 0 0 0];[x,y] = find(a == 1);a1 = length(x);z = [x y];[x1,y1] = find(a == 0);b1 = length(x1);fprintf('大佬有%d位\n',a1);fprintf('小白有%d位\n',b1);fprintf('大佬们的位置');disp(z);%%*******第二问********%%clc,clear;global a zz=0;%a=[0 0 0 0 0;0 1 1 0 0;0 1 0 1 0;0 0 1 1 0;0 0 0 0 0];a=[0 0 0 0 0 0 0 0 0;0 0 1 1 1 0 0 1 0;0 0 0 1 0 0 0 0 0;0 0 0 0 0 1 0 0 0;0 0 0 0 1 1 1 0 0;0 1 1 1 0 1 0 0 0;0 1 1 1 1 0 0 0 0;0 0 0 0 0 0 0 0 0;];[ax,ay]=size(a);for i0=1:ax for j0=1:ay bfs(i0,j0) endendfprintf('矩阵a中共有%d个大佬集\n',z)function bfs(x0,y0)global a zx=x0;y=y0;k=0;x1=[0 0 -1 1];y1=[1 -1 0 0];if a(x0,y0)==1 while length(x)~=0 k=k+1; for i=1:4 newx=x(1)+x1(i);newy=y(1)+y1(i); if a(newx,newy)==1 x=[x,newx];y=[y,newy]; end end a(x(1),y(1))=0; x(1)=[];y(1)=[]; end if k&gt;1 z=z+1; endendend 在青青草原旁边的小树林里，有两头爱吃蜂蜜的小熊熊。熊大做了一个5*5的VIP单层蜂箱，熊二找到了5只小蜜蜂5只大蜜蜂，它们都表示愿意住在里面，但提出了要求：每只蜜蜂独占一个小房间，且相同大小的蜜蜂不能在同一行、同一列、同一对角线上。聪明的你能帮助小熊熊们设计出10只蜜蜂的居住方案吗 （1）请编程输出一种满足所有条件的方案 （2）请编程输出所有方案，并统计共有多少方案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748%%*******B卷第五题********%%clc,clear;n=5;z=0;zzz=[];for a1=1:5 for a2=1:5 for a3=1:5 for a4=1:5 for a5=1:5 a=[a1 a2 a3 a4 a5];%行号 if length(unique(a))==5 zz=0; for i=1:4%列号 for j=i+1:5 if ((a(i)+i)==(a(j)+j))||((a(i)-a(j))==(i-j)) zz=1; break end end if zz==1 break end end if i==4&amp;&amp;j==5 z=z+1; zzz=[zzz;a]; end end end end end endendzzzzz2=0;[x,y]=size(zzz);for i=1:y-1 for j=i+1:y if length(find(zzz(i,:)-zzz(j,:)))==5 [zzz(i,:);zzz(j,:)] z2=z2+1; end endendfprintf('一共有%d种方案\n',z2);%TAKE IT EASY.JUST HAVE FUN!]]></content>
      <categories>
        <category>matlab</category>
        <category>代码练习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab自定义函数]]></title>
    <url>%2F2019%2F04%2F18%2Fmatlab%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数 向脚本中添加函数 R2016b 或更高版本支持脚本中的函数。 基础和函数工作区 函数优先顺序 函数类型 在工作区之间共享数据 global 将变量声明为全局变量 除了定义使用global，在其它自定义函数内使用时也要使用global先定义。 function function 声明函数名称、输入和输出 function [y1,...,yN] = myfun(x1,...,xM) 声明名为 myfun 的函数，该函数接受输入 x1,…,xM 并返回输出 y1,…,yN。此声明语句必须是函数的第一个可执行代码行。有效的函数名称以字母字符开头，并且可以包含字母、数字或下划线。 可以将函数保存在以下位置： 只包含函数定义的函数文件中。文件的名称应与文件中其函数的名称一致。 包含命令和函数定义的脚本文件中。函数必须位于该文件的末尾。脚本文件不能与文件中的函数具有相同的名称。R2016b 或更高版本才可以在脚本中直接写直接用函数。 文件可以包含多个局部函数或嵌套函数。为提高可读性，可使用 end 关键字来表示文件中每个函数的末尾。以下情况下需要 end 关键字： 文件中有任意函数包含嵌套函数。 该函数是函数文件中的局部函数，并且文件中有局部函数使用 end 关键字。 该函数是脚本文件内的局部函数。 在文件中创建函数 在文件中创建函数 程序文件可以包含多个函数。如果文件仅包含函数定义，则第一个函数是主函数，也是 MATLAB 与文件名关联的函数。主函数或脚本代码后面的函数称为局部函数。局部函数只能在文件内使用。 匿名函数 格式：函数句柄变量=@（匿名函数输入参数）匿名函数表达式123456EG:f1=@(x,y)x^2+y^2;f1(3,4)ans = 25 自定义函数12345678910111213141516171819202122232425262728293031一：function 输出形参表=函数名（输入形参表）注释（对这个函数的解释说明）函数体语句End EG:圆的周长和面积function [s,c]=circle(r)%求圆的周长和面积c=2*pi*r;s=pi*r^2;End[s,c]=circle(3)%保存好函数文件，在命令行窗口或另一个脚本里调用二:function 函数名注释（对这个函数的解释说明）函数体语句endEG:最强代号function CTGUMCMaxis off; %关闭坐标轴%Menubar是菜单条 none就是不显示图上方的菜单条set(gcf,'menubar','none','toolbar','none','unit', 'normalized', 'position', [0,0,1,1]);for k=1:377 h=text(rand, rand, ... ['\fontsize&#123;',num2str(unifrnd(5,77)),'&#125; CTGU MCM'],... 'color',rand(1,3),'Rotation',360*rand); pause(0.2);end]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>自定义函数</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab绘图补充]]></title>
    <url>%2F2019%2F04%2F17%2Fmatlab%E7%BB%98%E5%9B%BE%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[函数set 设置图形对象属性(set) 调用格式: set(H,Name,Value)为 H 标识的对象指定其 Name 属性的值。使用时须用单引号将属性名引起来，例如，set(H,&#39;Color&#39;,&#39;red&#39;)。如果 H 是对象的向量，则 set 会为所有对象设置属性。如果 H 为空（即 []），set 不执行任何操作，但不返回错误或警告。 set(H,NameArray,ValueArray) set(H,S) s = set(H) values = set(H,Name) 栗子:1234567%绘制一个线条并以 p 的形式返回图形线条对象。将行的 Color 属性设置为 'red'。p = plot(1:10);set(p,'Color','red')%使用随机数据创建一个包含四个线条的图形，并将这四个线条返回至 P。将所有线条的 Color 属性设置为 'red'。P = plot(rand(4));set(P,'Color','red') rectangle rectangle 创建带有尖角或圆角的矩形 Rectangle 属性 pie pie 逆时针画图 pie(X,explode) 将扇区从饼图偏移一定位置。explode 是一个由与 X 对应的零值和非零值组成的向量或矩阵。pie 函数仅将对应于 explode 中的非零元素的扇区偏移一定的位置。1234X = [1 3 0.5 2.5 2];pie(X)explode = [0 1 0 1 0]; %通过将对应的 explode 元素设置为 1 来偏移第二和第四块饼图扇区。pie(X,explode) explode - 偏移扇区 数值向量或矩阵 | 字符向量元胞数组 | 字符串数组 偏移扇区，指定为数值向量、矩阵、字符向量元胞数组或字符串数组。 如果 X 为数值，则 explode 必须是逻辑向量或数值向量，或由对应于 X 的零或非零值组成的矩阵。一个真（非零）值从饼图中心将相应的扇区偏移一定位置， pie(X,labels) 指定扇区的文本标签。X 必须是数值数据类型。标签数必须等于 X 中的元素数。 123X = 1:3;labels = &#123;'Taxes','Expenses','Profit'&#125;;pie(X,labels) 绘图多个饼图 创建两个数据向量并在各自的饼图中绘制和标记每一个向量。12345678910X = [0.2 0.4 0.4];labels = &#123;'Taxes','Expenses','Profit'&#125;;ax1 = subplot(1,2,1);pie(ax1,X,labels)title(ax1,'2012');Y = [0.24 0.46 0.3];ax2 = subplot(1,2,2);pie(ax2,Y,labels)title(ax2,'2013'); bar bar(y) 创建一个条形图，y 中的每个元素对应一个条形。如果 y 是矩阵，则 bar 根据 y 中的行对条形分组。12y = [75 91 105 123.5 131 150 179 203 226 249 281.5];bar(y) bar(x,y) 在 x 指定的位置绘制条形。x就是坐标123x = 1900:10:2000;y = [75 91 105 123.5 131 150 179 203 226 249 281.5];bar(x,y) 显示条形组12y = [2 2 3; 2 5 6; 2 8 9; 2 11 12];bar(y) bar(___,style) 指定条形组的样式。例如，使用 ‘stacked’ 将每个组显示为一个多种颜色的条形 style - 条形组样式 ‘grouped’为 y 中的每一行显示一组。 如果 y 是一个 m×n 矩阵，bar 显示 m 组 n 个垂直条，其中，m 是 y 的行数，n 是列数。 如果 y 是长度为 n 的向量，bar 会显示由 n 个条形构成的一个条形组。bar 函数将所有向量当作列向量处理。 显示堆叠条形图 为矩阵中的每一行显示一个条形。每个条形的高度是行中各元素之和。12y = [2 2 3; 2 5 6; 2 8 9; 2 11 12];bar(y,'stacked') x - x 值 向量 | 矩阵 x 值，指定为向量或矩阵。如果 x 和 y 均为向量，则它们的长度必须相同。如果 x 和 y 均为矩阵，则它们的大小必须相同。如果 x 为向量而 y 为矩阵，则 x 的长度必须等于 y 中的行数。 x 值不必按顺序排列，但它们不能包含重复值。如果 x 是矩阵，则它不能在各列中包含重复值。 y- y 值 向量 | 矩阵 y 值，指定为向量或矩阵。 如果 y 为向量，则 bar 为每个元素绘制一个条形。bar 函数将所有向量当作列向量处理。 如果 y 是矩阵，则 bar 根据 y 中的行对条形分组。 画垂直柱状图图用的是 bar() 函数，画水平柱状图时用的是 barh() 函数。 hist 直方图 hist(x)将向量x的元素平均分到十个等间隔的容器中，并且返回每个容器的元素个数。如果x是一个矩阵，hist指令逐列元素操作 其长度代表容器中数据的多少 x轴是范围(bin)，y轴是频率(个数) 123x = [0 2 9 2 5 8 7 3 1 9 4 3 5 8 10 0 1 2 9 5 10];hist(x)%hist 将 x 中的值有序划分入介于向量中最小值和最大值间的 10 个等间距 bin 中，在本例中，最小值是 0，最大值是 10。 多列组成的直方图 生成由 1,000 个随机数组成的三列并绘制三列叠加的直方图。 x 中的值将有序划分入介于最小值和最大值间的 10 个等间距 bin 中。hist 分别对 x 的各列排序、存储，并使用不同的颜色绘制每列。12x = randn(1000,3); hist(x) x - 输入数组 向量或矩阵 输入向量或矩阵。 如果 x 是向量，hist 创建一个直方图。 如果 x 为矩阵，则 hist 为每列创建一个单独的直方图并使用不同的颜色绘制直方图。]]></content>
      <categories>
        <category>matlab</category>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab函数之line]]></title>
    <url>%2F2019%2F04%2F17%2Fmatlab%E5%87%BD%E6%95%B0%E4%B9%8Bline%2F</url>
    <content type="text"><![CDATA[line line 调用格式: line(x,y) 使用向量 x 和 y 中的数据在当前坐标区中绘制线条。如果 x 和 y 中有一个是矩阵或两者都是矩阵，则 line 将绘制多个线条。与 plot 函数不同，line 会向当前坐标区添加线条，而不删除其他图形对象或重置坐标区属性。 line(x,y,z) 在三维坐标中绘制线条。 line 使用默认属性设置绘制一条从点 (0,0) 到 (1,1) 的线条(y = x,横纵坐标都是从0到1)。(就是直接输入line) line(&#39;XData&#39;,x,&#39;YData&#39;,y) line(&#39;XData&#39;,x,&#39;YData&#39;,y,&#39;ZData&#39;,z) line(___,Name,Value) line(ax,___) pl = line(___) 栗子:123456789101112%通过将 x 和 y 指定为矩阵来绘制两个线条。使用 line 绘制 y 的列对 x 的列的单独线条。x = linspace(0,10)';y = [sin(x) cos(x)];line(x,y)%通过指定 x、y 和 z 的值，在三维坐标中绘制线条。使用 view(3) 将坐标区更改为三维视图。t = linspace(0,10*pi,200);x = sin(t);y = cos(t);z = t;line(x,y,z)view(3)]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>绘图</category>
        <category>line</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab运算符]]></title>
    <url>%2F2019%2F04%2F14%2Fmatlab%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[运算符 Error:Matlab ||和&amp;&amp;运算符的操作数必须能够转换为逻辑标量值 解决:||和&amp;&amp;为值运算， |与&amp;为向量运算，改为|与&amp; &amp;&amp;和||被称为&amp;和|的short circuit形式， A&amp;B （1）首先判断A的逻辑值，然后判断B的值，然后进行逻辑与的计算。 （2）A和B可以为矩阵（e.g. A=[1 0],B=[0 0]）。 A&amp;&amp;B （1）首先判断A的逻辑值，如果A的值为假，就可以判断整个表达式的值为假，就不需要再判断B的值。 （2）A和B不能是矩阵，只能是标量。 “|”与“||”同理。 A&amp;&amp;B 首先判断A的逻辑值，如果A的值为假，就可以判断整个表达式的值为假，就不需要再判断B的值。这种用法非常有用，如果A是一个计算量较小的函数，B是一个计算量较大的函数，那么首先判断A对减少计算量是有好处的。另外这也可以防止类似被0除的错误 中括号[]的一个用法是，用来接收多个返回值/结果(数值或矩阵)。 运算符的优先级 运算符的优先级 AND 和 OR 运算符的优先级 MATLAB 始终将 &amp; 运算符的优先级指定为高于 | 运算符。尽管 MATLAB 通常按从左到右的顺序计算表达式，但表达式 a|b&amp;c 按 a|(b&amp;c) 形式计算。对于包含 &amp; 和 | 组合的语句，比较好的做法是使用括号显式指定期望的语句优先级。该优先级规则同样适用于 &amp;&amp; 和 || 运算符。 转载 matlab中&amp;&amp;和&amp;的区别_ 逻辑运算符：短路 &amp;&amp; || and, &amp;(计算逻辑 AND)]]></content>
      <categories>
        <category>matlab</category>
        <category>基础</category>
        <category>运算符</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之unique]]></title>
    <url>%2F2019%2F04%2F14%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bunique%2F</url>
    <content type="text"><![CDATA[unique unique C = unique(A) 返回与 A 中相同的数据，但是不包含重复项。C 已排序。 如果 A 是表或时间表，则 unique 按排序顺序返回 A 中的唯一行。对于时间表，当确定行是否唯一时，unique 会考虑行时间和行值，并按行时间对输出时间表 C 排序。 C = unique(A,setOrder) 以特定顺序返回 A 的唯一值。setOrder 可以是 ‘sorted’（默认值）或 ‘stable’。 setOrder - 顺序标志 顺序标志以 ‘sorted’ 或 ‘stable’ 指定，指示 C 中值（或行）的顺序。 ‘sorted’ 按排定的顺序返回 C 中的值（或行）。例如：C = unique([5 5 3 4],&#39;sorted&#39;) 返回 C = [3 4 5]。 ‘stable’ 按与 A 中相同的顺序返回 C 中的值（或行）。例如：C = unique([5 5 3 4],&#39;stable&#39;)返回 C = [5 3 4]。 C = unique(A,occurrence) 指定遇到重复值时应返回哪个索引。occurrence 可以是 ‘first’（默认值）或 ‘last’。 occurrence - 出现次数标志 ‘first’ （默认） | ‘last’ 出现次数标志，指定为 ‘first’ 或 ‘last’，指示在 A 中发现重复值时，ia 是包含第一个索引还是最后一个索引。 ‘last’如果 A 中有重复的值（或行），则 ia 包含最后一次出现重复值的索引 ‘first’如果 A 中有重复的值（或行），则 ia 包含第一次出现重复值的索引]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>unique</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之sum]]></title>
    <url>%2F2019%2F04%2F13%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bsum%2F</url>
    <content type="text"><![CDATA[sum 其实sum(a)默认的是sum(a,1),还有sum(a,2)。 sum(a,1)把矩阵的每一列分别加起来形成新的行矩阵。 sum(a,2)把矩阵的每一行分别加起来形成新的列矩阵。 提示：矩阵a是行矩阵时，sum(a)不再是sum(a,1),而转换为了sum(a,2)。 求一个矩阵所有元素12345678910111213141516171819202122232425262728clc,clear;close all;a = [1 2 3 4 5 6];sum(a)sum(sum(a))sum(a(:))sum(a(:, :)) %a(:, :)与原矩阵相同%answerans = 9 12ans = 21ans = 21ans = 9 12]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>sum</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab矩阵操作补充]]></title>
    <url>%2F2019%2F04%2F13%2Fmatlab%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[矩阵 删除例题2中第1、3、5、7行以及第3、8列。 12345678clc;clear;a=ones(10); for i=2:10 a(i,:)=i; end a( 1:2:7 , :) = [ ]; a( : , [3 8] ) = [ ]; %体会[]与：的运用 a 矩阵与某数字相加，所有元素全部加上这个数字，构成新矩阵。数字相减也是一样 数字与矩阵相乘，也是所有元素全部乘以这个数字，构成新矩阵。除法也是 创建、串联和扩展矩阵 创建、串联和扩展矩阵串联矩阵 可以使用方括号将现有矩阵连接在一起。这种创建矩阵的方法称为串联。 要串联两个矩阵，它们的大小必须兼容。也就是说，水平串联矩阵时，它们的行数必须相同。垂直串联矩阵时，它们的列数必须相同。 串联矩阵的另一种方法是使用串联函数，如 horzcat，它可以水平串联两个兼容的输入矩阵。 扩展矩阵 通过将一个或多个元素置于现有行和列索引边界之外，可以将它们添加到矩阵中。MATLAB 会自动用 0 填充矩阵，使其保持为矩形。例如，创建一个 2×3 矩阵，然后在 (3,4) 的位置插入一个元素，使矩阵增加一行一列。 123456789A = [10 20 30; 60 70 80]%A = 2×3 10 20 30 60 70 80A(3,4) = 1 %A = 3×4 10 20 30 0 60 70 80 0 0 0 0 1 可以通过在现有索引范围之外插入新矩阵来扩展其大小。 123456789101112A = [10 20 30; 60 70 80]%A = 2×3 10 20 30 60 70 80A(3,4) = 1 A(4:5,5:6) = [2 3; 4 5]%A = 5×6 10 20 30 0 0 0 60 70 80 0 0 0 0 0 0 1 0 0 0 0 0 0 2 3 0 0 0 0 4 5 要重复扩展矩阵的大小，例如在 for 循环中，通常最好要为预计创建的最大矩阵预分配空间。如果没有预分配空间，MATLAB 必须在每次大小增加时分配内存，因此会降低操作速度。例如，通过将矩阵的元素初始化为零，预分配一个最多容纳 10000 行和 10000 列的矩阵。A = zeros(10000,10000);如果之后还要预分配更多元素，可以通过在矩阵索引范围之外指定元素或将另一个预分配的矩阵与 A 串联来进行扩展。 就是先定义一个大小矩阵 基本运算的兼容数组大小 基本运算的兼容数组大小 大多数二元（两个输入）运算符和函数都支持具有兼容大小的数值数组。对于每个维度，如果两个输入的维度大小相同或其中一个为 1，则这些输入将具有兼容的大小。以最简单的情况为例，如果两个数组大小完全相同或其中一个为标量，则这两个数组大小是兼容的。执行按元素运算或函数时，MATLAB 会将大小兼容的数组隐式扩展为相同的大小。 大小不兼容的输入 不兼容的输入的大小无法隐式扩展为相同的大小。例如： 其中一个维度大小不相等，并且维度大小均不为 1。 A: 3-by-2 B: 4-by-2 两个长度不相同的非标量行向量。 A: 1-by-3 B: 1-by-4 大小兼容的输入二维输入 以下是一些具有兼容大小的标量、向量和矩阵的组合： 多维数组 略 空数组 对于空数组或维度大小为零的数组，规则是相同的。不等于 1 的维度大小确定输出的大小。这意味着，大小为零的维度必须与另一个数组中大小为 1 或 0 的维度进行配对，并且输出的维度大小为 0。 A: 1-by-0 B: 3-by-1 Result: 3-by-0 attention 要简化向量-矩阵运算，请对维函数（例如 sum、mean、min 以及其他）使用隐式扩展。 行向量和列向量相加 行向量和列向量的大小兼容，当您对它们执行运算时，结果为一个矩阵。 使用关系运算符进行数组比较 文档 关系运算符使用“小于”、“大于”和“不等于”等运算符对操作数进行定量比较。- 关系比较的结果是一个逻辑数组，指示关系为 true 的位置。 数组比较数值数组 关系运算符会在两个数组之间执行按元素比较。数组的大小必须兼容以便于执行运算。执行计算时，具有兼容大小的数组会隐式扩展为相同的大小。以最简单的情况为例，两个操作数为大小相同的数组，或者其中一个操作数为标量。 将一个 1×N 行向量与一个 M×1 列向量进行比较，则 MATLAB 会在执行比较之前将每个向量都扩展为一个 M×N 矩阵。生成的矩阵包含这些向量中元素的每个组合的比较结果。 1234567891011A = 1:3%A = 1 2 3B = [2; 3]%B = 2 3A &gt;= B%ans = 0 1 1 0 0 1 关系运算符可用于其中有任一维度大小为零的数组，只要两个数组的大小兼容。 数组索引 文档-1234567891011A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]%A = 4×4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16%可以在一个向量中指定多个元素的索引，从而一次引用多个元素。例如，访问 A 的第二行中的第一个和第三个元素。r = A(2,[1 3])%r = 1×2 5 7 使用逻辑值进行索引 使用 true 和 false 逻辑指示符也可以对数组进行索引，在处理条件语句时尤其便利 矩阵 A 中的元素是否小于另一个矩阵 B 中的对应元素。当 A 中的元素小于 B 中的对应元素时，小于号运算符返回元素为 1 的逻辑数组。 12345678910111213141516171819202122clc,clear;A = [1 2 6 4 3 6];B = [0 3 7 3 7 5];ind = A&lt;B%现在已经知道满足条件的元素的位置，可以使用 ind 作为索引数组来检查各个值。MATLAB 将 ind 中值 1 的位置与 A 和 B 中的对应元素进行匹配，并在列向量中列出它们的值。Avals = A(ind)Bvals = B(ind)%ansind = 0 1 1 0 1 0Avals = 2 3 6Bvals = 3 7 7 MATLAB 中的 is 函数(前面带is的函数)还返回逻辑数组，指示输入中的哪些元素满足特定条件。 查找符合条件的数组元素 文档 应用单个条件 123456789101112131415161718192021222324252627clc,clear;a = [1 2 3 4 5 6 7 8];b = a &gt; 5a(b)i = find(a &gt; 5)a(i)%answerb = 0 0 0 0 0 1 1 1ans = 7 6 8i = 4 7 8ans = 7 6 8 结果为一个逻辑矩阵。b 中的每个值都表示为逻辑值 1 (true) 或逻辑值 0 (false) 的状态，以指示 a 的对应元素是否符合条件 a&gt;5。 虽然 b 包含有关 a 中哪些元素大于 5 的信息，但它不会指出这些元素的具体值是多少。您可以使用 b 创建 a 的索引，而不必逐元素比较这两个矩阵。 结果为一个由 a 中大于 5 的元素组成的列向量。由于 b 为逻辑矩阵，因此该运算称为逻辑索引 find函数结果为一个由线性索引组成的列向量。每个索引描述a 中一个大于5的元素的位置，因此实际上 a(i) 与 a(b) 返回的结果相同。差别在于 a(b) 使用逻辑索引，而 a(i) 使用线性索引。 应用多个条件 可以使用逻辑 and、or 和 not 运算符将任意多个条件应用于一个数组；条件的数量并不局限于一个或两个。 逻辑索引 12345678910111213141516171819202122232425262728293031323334353637383940clc,clear;a = [1 2 3 4 5 6 7 8 9 10];b = a(a &gt; 5&amp; ~mod(a, 2))c = a(a &gt; 5&amp; ~mod(a, 2)&amp;a ~= 8)t = find(a &gt; 5&amp; ~mod(a, 2)&amp;a ~= 8);d = a(t)e = a(a &gt; 2&amp;a &lt;5)f = a(2&lt;a&lt;5)%结果为 a 中同时符合这两个条件的元素的列表。%务必使用单独的语句指定每个条件，并用逻辑运算符连接起来。%例如，不能通过 a(2 &lt; a &lt; 5) 指定以上条件，因为其计算结果为 A(2&lt;A | A&lt;5)。%ansb = 6 8 10c = 6 10d = 6 10e = 3 4f = 1 3 5 7 9 2 4 6 8 10 查找 a 中大于 5 且为偶数的元素。 结果为 a 中大于5的所有偶数元素的列表。使用逻辑 NOT 运算符 ~ 将矩阵 mod(A,2) 转换为逻辑矩阵，并在可被 2 整除的元素位置放置逻辑值 1 (true)。 替换符合条件的值 有时，同时更改多个现有数组元素的值会很有用。将逻辑索引与简单的赋值语句一起使用，可替换数组中符合条件的值。 将 a 中大于 10 的所有值替换为数值 10。 123456789101112131415161718192021222324252627282930313233clc,clear;a = [1 2 3 4 5 6 7 8 9 10 11 12 12 13 14 15];a(a&gt;10) = 10%将 a 中不等于 10 的所有值替换为 NaN 值。a(a~=10) = nan%将 a中的所有 NaN 值替换为 0，并应用逻辑 NOT 运算符 ~A。a(isnan(a)) = 0c = ~a%ansa = 1 2 3 4 5 6 7 8 9 10 10 10 10 10 10 10a = NaN NaN NaN NaN NaN NaN NaN NaN NaN 10 10 10 10 10 10 10a = 0 0 0 0 0 0 0 0 0 10 10 10 10 10 10 10c = 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 生成的矩阵用逻辑值 1 (true) 取代 NaN 值，用逻辑值 0 (false) 取代 10。逻辑 NOT 运算 ~a 将数值数组转换为逻辑数组，因此 a&amp;c 返回逻辑值 0 (false) 的矩阵，a|c 返回逻辑值 1 (true) 的矩阵。 数组与矩阵运算 注意matlab版本 MATLAB® 具有两种不同类型的算术运算：数组运算和矩阵运算。您可以使用这些算术运算来执行数值计算，例如两数相加、计算数组元素的给定次幂或两个矩阵相乘。 矩阵运算遵循线性代数的法则。与之不同，数组运算则是执行逐元素运算并支持多维数组。句点字符 (.) 将数组运算与矩阵运算区别开来。但是，由于矩阵运算和数组运算在加法和减法的运算上相同，因此没有必要使用字符组合 .+ 和 .-。 数组与矩阵运算 数组运算 数组运算可针对向量、矩阵和多维数组的对应元素执行逐元素运算。如果操作数的大小相同，则第一个操作数中的每个元素都会与第二个操作数中同一位置的元素匹配。如果操作数的大小兼容，则每个输入都会根据需要进行隐式扩展以匹配另一个输入的大小。 如果一个操作数是标量，而另一个操作数不是标量，则 MATLAB 会将该标量隐式扩展为与另一个操作数具有相同的大小。例如，您可以计算一个标量和一个矩阵的按元素乘积。 12345678A = [1 2 3; 1 2 3]%A = 1 2 3 1 2 33.*A%ans = 3 6 9 3 6 9 如果从一个 3×3 矩阵中减去一个 1×3 向量，隐式扩展仍然会起作用，因为它们的大小是兼容的。当您执行减法运算时，该向量将隐式扩展为一个 3×3 矩阵。 12345678910111213A = [1 1 1; 2 2 2; 3 3 3]%A = 1 1 1 2 2 2 3 3 3m = [2 4 6]%m = 2 4 6A - m%ans = -1 -3 -5 0 -2 -4 1 -1 -3 行向量和列向量的大小兼容。如果您将一个 1×3 向量与一个 2×1 向量相加，则每个向量都会在 MATLAB 执行按元素加法之前隐式扩展为一个 2×3 矩阵。 1234567891011x = [1 2 3]%x = 1 2 3y = [10; 15]%y = 10 15x + y%ans = 11 12 13 16 17 18 如果两个操作数的大小不兼容，则将会收到错误消息。 矩阵运算 矩阵运算遵循线性代数的法则，与多维数组不兼容]]></content>
      <categories>
        <category>matlab</category>
        <category>矩阵</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maltab常用函数之isempty]]></title>
    <url>%2F2019%2F04%2F13%2Fmaltab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bisempty%2F</url>
    <content type="text"><![CDATA[isempty 文档 Syntax: TF = isempty(A) Description TF = isempty(A) returns logical 1 (true) if A is empty, and logical 0 (false) otherwise. An empty array, table, or timetable has at least one dimension with length 0, such as 0-by-0 or 0-by-5.]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>isempty</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之xlim及其相关函数]]></title>
    <url>%2F2019%2F04%2F11%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bxlim%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[xlim 文档 相关网站 含义:(x limit)设置或查询 x 坐标轴范围 调用格式:y有多种，暂时写一种 xlim([xmin xmax])sets the axis limits in the current axes to the specified values. 将当前轴中的轴限制设置为指定的值。]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>绘图</category>
        <category>xlim,ylim,zlim</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之pdist与squareform]]></title>
    <url>%2F2019%2F04%2F11%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bpdist%E5%92%8Csquareform%2F</url>
    <content type="text"><![CDATA[pdist 文档 调用格式: D = pdist(X)returns the Euclidean distance between pairs of observations in X. 一个矩阵A的大小为MN，那么B=pdist(A)得到的矩阵B的大小为1行M(M-1)/2列，表示的意义是M行数据，每两行计算一下欧式距离pdist(x,distance),distance也可以用来表示其他距离，默认的是欧式距离。 返回函数中的观测对之间的欧几里得距离 D = pdist(X,Distance) returns the distance by using the method specified by Distance. D = pdist(X,Distance,DistParameter) returns the distance by using the method specified by Distance and DistParameter. You can specify DistParameter only when Distance is ‘seuclidean’, ‘minkowski’, or ‘mahalanobis’. Distance — Distance metric Distance metric, specified as a character vector, string scalar, or function handle, as described in the following table. metric’取值如下： ‘euclidean’：欧氏距离（默认）； 栗子:Compute the Euclidean distance between pairs of observations, and convert the distance vector to a matrix using squareform. 计算观测对之间的欧氏距离，并用squareform将距离矢量转换为矩阵。123456789101112131415161718192021222324252627282930313233rng('default') % For reproducibilityX = rand(3,2);%生成矩阵坐标，第一列为横坐标，第二列为纵坐标D = pdist(X)%answerD = 1×3 0.2954 1.0670 0.9448%**The pairwise distances are arranged in the order (2,1), (3,1), (3,2)**. **You can easily locate the distance between observations i and j by using squareform.**%**如果a是3*2矩阵，那么pdist函数计算欧几里德距离的顺序是第二行与第一行计算欧几里得距离，然后是第3行于第一行计算欧几里得距离，最后是第3行与第2行的欧几里德距离**% 如果`b = squareform(pdist(a))`，那么`b(i,j)`就是矩阵a第i行与第j行之间的欧几里得距离Z = squareform(D)Z = 3×3 0 0.2954 1.0670 0.2954 0 0.9448 1.0670 0.9448 0%squareform returns a symmetric matrix **where Z(i,j) corresponds to the pairwise distance between observations i and j**. For example,** you can find the distance between observations 2 and 3.**%squareform返回一个对称矩阵，**其中Z(i,j)对应于观察i和j之间的成对距离。**Z(2,3)ans = 0.9448%验证pdist函数计算行顺序clc,clear;a = [0 0 3 4 5 6];b = pdist(a);d = sqrt(3^2+4^2)e = sqrt(5^2+6^2)g = sqrt(2^2+2^2)b]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>pdist</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之isprime]]></title>
    <url>%2F2019%2F04%2F11%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bisprime%2F</url>
    <content type="text"><![CDATA[isprime 文档 调用格式: TF = isprime(X) 返回与 X 大小相同的逻辑数组。如果 X(i) 为质数，则 TF(i) 的值为 true。否则，值为 false。 栗子:1234tf = isprime([2 3 0 6 10])tf = 1x5 logical array 1 1 0 0 0%2 和 3 是质数，但 0、6 和 10 不是。]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>isprime</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之primes]]></title>
    <url>%2F2019%2F04%2F11%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bprimes%2F</url>
    <content type="text"><![CDATA[primes 文档 调用格式: p = primes(n)返回包含所有小于或等于 n 的质数的行向量。p 与 n 具有相同的数据类型。 栗子:123p = primes(25)p = 1×9 2 3 5 7 11 13 17 19 23]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>primes</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之symsum]]></title>
    <url>%2F2019%2F04%2F10%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bsymsum%2F</url>
    <content type="text"><![CDATA[数学期望问题 原地址 symsum symsum文档 调用格式: F = symsum(f,k,a,b) returns the sum of the series with terms that expression f specifies, which depend on symbolic variable k. The value of k ranges from a to b. If you do not specify the variable, symsum uses the variable that symvar determines. If f is a constant, then the default variable is x. 返回表达式f指定的一系列项的和，这些项依赖于符号变量k。k的值范围从a到b。如果不指定变量，symsum将使用symvar确定的变量。如果f是常数，那么默认变量是x。 F = symsum(f,k) 栗子: 1234567891011syms k x S1 = symsum(k^2, k, 0, 10)S2 = symsum(1/k^2, k, 1, Inf) S3 = symsum(x^k/factorial(k), k, 0, Inf)%分母为阶乘 %answer S1 = 385 S2 = pi^2/6 S3 = exp(x)]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>symsum</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之solve]]></title>
    <url>%2F2019%2F04%2F10%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bsolve%2F</url>
    <content type="text"><![CDATA[solveCharacter vector inputs have been removed. Instead, use syms to declare variables and replace inputs such as solve(‘2x == 1’,’x’) with solve(2x == 1,x). 调用格式: S = solve(eqn,var)solves the equation eqn for the variable var. If you do not specify var, the symvar function determines the variable to solve for. For example, solve(x + 1 == 2, x) solves the equation x + 1 = 2 for x. S = solve(eqn,var,Name,Value) Y = solve(eqns,vars) Y = solve(eqns,vars,Name,Value) [y1,...,yN] = solve(eqns,vars) [y1,...,yN] = solve(eqns,vars,Name,Value) [y1,...,yN,parameters,conditions] = solve(eqns,vars,&#39;ReturnConditions&#39;,true) 栗子: 12345%Use the == operator to specify the equation sin(x) == 1 and solve it.syms xeqn = sin(x) == 1;solx = solve(eqn,x)%answer:solx = pi/2]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>solve</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学]]></title>
    <url>%2F2019%2F04%2F09%2F%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[数学期望 数学期望 知乎 数学期望 百科 大数定律规定，随着重复次数接近无穷大，数值的算术平均值几乎肯定地收敛于期望值 排列组合 高中数学排列组合21种模型 弧度与角度 转换 海伦公式 公式描述： s = sqrt(p * ( p-a ) * (p-b) * (p-c) )公式中a，b，c分别为三角形三边长，p为半周长，S为三角形的面积。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与迭代]]></title>
    <url>%2F2019%2F04%2F06%2F%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[递归与迭代 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出./相对/ 迭代是从远到近，不断逼近answer 利用变量的原值推算出变量的一个新值，迭代就是A不停的调用B.]]></content>
      <categories>
        <category>c++</category>
        <category>递归与迭代</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制与位运算]]></title>
    <url>%2F2019%2F04%2F06%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[位运算与乘除法的换算 说明：（1）位运算符中除 ~ 外，均为二目运算符，即要求出侧各有一个运算量。（2）运算早只能是整型或字符型的数据，不能为实型数据。 使用位移运算可以提高因乘除运算带来的效率的问题，它的缺点是存在精度损失且不直观。 使用移位运算来避免乘法运算是一种常用技巧，不过乘数必须都是正整数，而且必须至少有一个是 2 的 n 次方，例如：2，4，8，16，32……移位运算的特点是速度快，而乘法运算速度较慢，把乘法运算转化为移位运算可以稍微提高程序运行效率。 例题1：12345678910111213141516171819202122232425262728293031//乘法12 * 2 = 12 &lt;&lt; 112 * 4 = 12 &lt;&lt; 212 * 8 = 12 &lt;&lt; 312 * 16 = 12 &lt;&lt; 412 * 32 = 12 &lt;&lt; 512 * 64 = 12 &lt;&lt; 612 * 128 = 12 &lt;&lt; 712 * 256 = 12 &lt;&lt; 8//除法12 / 2 = 12 &gt;&gt; 112 / 4 = 12 &gt;&gt; 212 / 8 = 12 &gt;&gt; 312 / 16 = 12 &gt;&gt; 412 / 32 = 12 &gt;&gt; 512 / 64 = 12 &gt;&gt; 612 / 128 = 12 &gt;&gt; 712 / 256 = 12 &gt;&gt; 8//其它num *= 32; //等同于 num &lt;&lt;= 5; /* 2 的 5 次方等于 32 */ //如果乘数不是 2 的 n 次方，我们可以把乘数分解成几个 2 的 n 次方的和： num *= 20;//等于 num *= (16 + 4);//等于 num = num * 16 + num * 4;//等于num = (num &lt;&lt; 4) + (num &lt;&lt; 2); 二进制 原码:指一个二进制数左边加上符号位后所得到的码，且当二进制数大于0时，符号位为0；二进制数小于0时，符号位为1；二进制数等于0时，符号位可以为0或1 反码：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码：正数的补码与原码相同，负数的补码是其对应正数二进制所有位取反后加1。 在计算机中通常使用补码进行储存。 二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数 位运算“~”运算又称取反运算，就是对一个二进制数按位取反。对于 int 来说，~x = −x−1 “&amp;”运算 “&amp;”运算，即“and” 运算，也是一种逻辑运算符，对于二进制运算来说，“&amp;”运算的意义是对于两个二进制数的每一位，除了11得1，其他均为0 可以用 &amp; 运算判断一个数是奇数还是偶数，当 x 为奇数时， x 二进制下的第 0 位一定是 1 ，否则为 0 。我们让x &amp; 1，就可以知道 x 的奇偶性了。 &amp;运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。所以可以用来判断奇偶性 举个栗子：10101(21) &amp; 11100(28) = 10100{20} 如果参加 &amp; 是负数（-3 &amp; -5），则以补码形式表示为二进制数。然后按位进行 与 运算。 x &amp; (x - 1)用于消去x二进制最后一位的1 123x = 1100 00|0100|1100x - 1 = 1011 00|0100|1011x &amp; (x - 1) = 1000 00|0100|1000 “|” 运算 即 “or” 运算，也是一种逻辑运算符，对于二进制运算来说，“|” 运算的意义是对于两个二进制数的每一位，除了00得0，其它都是1 举个栗子：10101(21) | 11100(28) = 11101(29) 通过与运算和或运算的栗子可以观察到一下规律：x &amp; y&lt;=x和x | y&gt;=x “^”运算 “^”运算，又称“xor”运算，异或运算。定义是对于两个二进制数的每一位，相同为0，不同为1 举个栗子：10101(21) ^ 11100(28) = 1001(9) 对于一个形如2∗n 的数 x， x ^ 1=x+1,而对于一个形如 2∗n+1的数x，x ^ 1=x−1 异或运算的妙用： 0^0=0,0^1=1 可理解为：0异或任何数，其结果=任何数 1^0=1,1^1=0 可理解为： 1异或任何数，其结果=任何数取反 任何数异或自己，等于把自己置0 异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a. 如果 x ^ y=z 那么 y ^ z=x， x ^ z=y a xor c == b xor c 则 a == b a ^ b = b ^ a a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c; d = a ^ b ^ c 可以推出 a = d ^ b ^ c. a ^ b ^ a = b. (a xor b） xor b = a; 由于xor满足交换律，所以上述特性这样表述也是对的： (b xor a) xor b = a; b xor (a xor b) = a;交换2个数 不借助中间变量，交换两个数有以下方法👇 1. 相互加减 1234567a = a + b; //但是加法可能导致溢出b = a - b; //x和y同号的情况下容易溢出a = a - b;x=x-y; //x和y异号的情况下容易溢出y=x+y;x=y-x; 2.异或运算 12345a = a^b;b = a^b;a = a^b;//可简写为如下b ^= a ^= b ^= a; 这东西理论上能比正常的交换优一点，当然还是用 swap 吧，毕竟人家什么都能换，这个只能换整数。 找出2n+1个数中不成对的数 给出n个数，其中有且仅有一个出现了奇数次，其余的都出现了偶数次。用线性时间常数空间找出这个出现奇数次的数原-lowbit运算快速判断奇偶性 上面有在状压情况下的操作快速幂位运算的优先级 位运算的优先级，大致按下面排序 加减运算 &gt; 移位运算 &gt; 比较大小运算 &gt; 与运算 &gt; 异或运算 &gt; 或运算]]></content>
      <categories>
        <category>c++</category>
        <category>二进制与位运算</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[快速幂 直接看吧]]></content>
      <categories>
        <category>算法</category>
        <category>快速幂</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂题解]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%BF%AB%E9%80%9F%E5%B9%82%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ac.nowcoder题目 题目描述:立华奏在学习初中数学的时候遇到了这样一道大水题： “设箱子内有 n 个球，其中给 m 个球打上标记，设一次摸球摸到每一个球的概率均等，求一次摸球摸到打标记的球的概率” “emmm…语言入门题” 但是她改了一下询问方式：设最终的答案为 p ,请输出 p 小数点后 K1 到 K2 位的所有数字（若不足则用 0 补齐） 输入描述:第一行一个整数 T,表示有 T 组数据。接下来每行包含四个整数 m,n,K1,K2，意义如「题目描述」所示。 1≤m≤n≤10的9次方,1≤K1≤K2≤10的9次方、0≤K2−K1≤10的5次方，T≤20。 输出描述:输出 T 行，每行输出 K2−K1+1个数，表示答案。注意同行的数字中间不需要用空格隔开。 解答 不用从头开始模拟，只需要从 K1 位开始模拟就可以了。 直接通过快速幂+取模算出第 K1位的数字。然后我们发现 K2−K1≤10的5次方，所以暴力枚举除法过程就可以。 时间复杂度 O(n)12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt; #define Re register#define LL long long#define U unsigned#define FOR(i,a,b) for(Re int i = a;i &lt;= b;++i)#define ROF(i,a,b) for(Re int i = a;i &gt;= b;--i)#define CLR(i,a) memset(i,a,sizeof(i))#define BR printf("--------------------\n")#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; std::endl inline LL qpow(LL a,LL b,LL p)&#123; LL res = 1; for(;b;b&gt;&gt;=1,a=a*a%p) if(b&amp;1) res = res * a % p; return res;&#125; int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; LL a,b,k1,k2; std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; k1 &gt;&gt; k2; LL ans = ((a % b) % b * qpow(10, k1 - 1, b)) % b; for(LL i = k1;i &lt;= k2;i++,ans = ans % b) &#123; ans *= 10; std::cout &lt;&lt; ans / b; &#125; std::cout &lt;&lt; std::endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分抽签算法分析]]></title>
    <url>%2F2019%2F04%2F05%2F%E4%BA%8C%E5%88%86%E6%8A%BD%E7%AD%BE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[算法课123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*你的朋友提议玩一个游戏：将写有数字的n个纸片放入口袋中．你可以从口袋中抽取4次纸片，每次记下纸片上的数字后都将其放回口袋中如果这4个数字的和是m，就是你赢，否则就是你的朋友赢。你挑战了好几回，结果一次也没赢过，于是怒而撕破口袋，取出所有纸片，检查自己是否真的有赢的可能性。请你编写一个程序，判断当纸片上所写的数字是k1，k2，…，kn时，是否存在抽取4次和为m的方案。如果存在，输出彻；否则，输出NO.限制条件: 1≤n ≤ 50; 1 ≤ m ≤ 10^8; 1 ≤ Ki ≤ 10^8输入样例： 3 10 1 3 5 (格式-n,m, k1,k2,..kn)输出样例：YES输入样例：3 9 1 3 5 输出样例：NO*/#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, m, i, j;int kk[1000000];//开大点防止爆掉 int bs(int b)&#123; int left = 0, right = n*n-1; while(left &lt; right)&#123; int k = left+(right-left)/2; if(kk[k] == b) return 1; if( m &gt;kk[k]) left = k+1; else right = k; &#125; return 0;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; int a[n]; for(i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; &#125; for ( i=0; i &lt; n; i++) for ( j=0; j &lt; n; j++) kk[i*n + j] = a[i]+a[j];//枚举组合 sort(kk, kk+n*n); for(i = 0; i &lt; n; i++) for(j = 0; j &lt; n; j++)&#123; if( bs(m-a[i]-a[j]) )&#123; cout &lt;&lt; "YES"; return 0; &#125; &#125; cout &lt;&lt; "NO"; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二分法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之mean]]></title>
    <url>%2F2019%2F04%2F04%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bmean%2F</url>
    <content type="text"><![CDATA[mean(数组的均值) 文档 调用格式: M = mean(A)返回 A 沿大小不等于 1 的第一个数组维度的元素的均值。 如果 A 是向量，则mean(A)返回元素均值。 如果 A 为矩阵，那么 mean(A) 返回包含每列均值的行向量。 如果 A 是多维数组，则 mean(A) 沿大小不等于 1 的第一个数组维度计算，并将这些元素视为向量。此维度会变为 1，而所有其他维度的大小保持不变。 mean(a)默认的是mean(a,1)。 矩阵a是行矩阵时，mean(a)不再是mean(a,1),而转换为了mean(a,2)。 要求总平均值，可以：mean( a(:) ),下面还有几种方法 M = mean(A,&#39;all&#39;)计算 A 的所有元素的均值。 M = mean(A,dim)返回维度 dim 上的均值。例如，如果 A 为矩阵，则 mean(A,2) 是包含每一行均值的列向量。 M = mean(A,vecdim)计算向量 vecdim 所指定的维度上的均值。例如，如果 A 是矩阵，则 mean(A,[1 2])是 A 中所有元素的均值，因为矩阵的每个元素都包含在由维度 1 和 2 定义的数组切片中。 M = mean(___,outtype)使用前面语法中的任何输入参数返回指定的数据类型的均值。outtype 可以是 ‘default’、’double’ 或 ‘native’。 M = mean(___,nanflag)指定在上述任意语法的计算中包括还是忽略 NaN 值。mean(A,&#39;includenan&#39;) 会在计算中包括所有 NaN 值，而 mean(A,&#39;omitnan&#39;) 则忽略这些值。 栗子:12345678910 %创建一个矩阵并计算每列的均值A = [0 1 1; 2 3 2; 1 3 2; 4 2 2]%A = 4×3 0 1 1 2 3 2 1 3 2 4 2 2M = mean(A)%M = 1×3 1.7500 2.2500 1.7500]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>mean</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之rem]]></title>
    <url>%2F2019%2F04%2F04%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Brem%2F</url>
    <content type="text"><![CDATA[rem 调用格式:r = rem(a,b) r = rem(a,b)返回a除以b后的余数，其中a为被除数，b为除数。这个操作在概念上等于r = a - b.*fix(a./b)，它使用与mod函数不同的舍入。rem函数遵循rem(a,0)为NaN的约定。 例题: 12345a = 1:5;b = 3;r = rem(a,b)r = 1 2 0 1 2 rem(a,b)finds the remainder after division. If b &lt;&gt; 0, then rem(a,b) = a - fix(a/b)*b. If b = 0 or b = Inf or b = -Inf, then rem returns NaN.The rem function does not support complex numbers: all values must be real numbers.To find the remainder after division of polynomials, use quorem. 当正数与负数取余时，当得到的余数结果的符号希望跟除数(x)一样，用rem()函数；当得到的余数结果的符号希望跟被除数(y)一样，用mod()函数 mod(x,y)与y同号，rem(x,y)与x同号]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>rem</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab函数之rand及其相关函数]]></title>
    <url>%2F2019%2F04%2F03%2Fmatlab%E5%87%BD%E6%95%B0%E4%B9%8Brand%2F</url>
    <content type="text"><![CDATA[rand matlab中通过rand函数产生的是介于0到1(不包括1)之间的伪随机数 X = rand范围(0,1). X = rand(n)表示产生一个n×n的随机矩阵，n必须是整数,否则会报错。 X = rand(sz1,...,szN) X = rand(sz) X = rand(___,typename) X = rand(___,&#39;like&#39;,p) 可以与取整函数搭配使用 为了使每次执行rand函数时产生和之前不相同的一组伪随机数，通常需要初始化随机数种子。方法很多， 常见的一种是在写m文件时，在程序的开头写：rand(&#39;state&#39;,sum(100*clock)) 定义一个随时间变化的初值。 randi randi 均匀分布的伪随机整数 最新英文文档(推荐) randi函数产生均匀分布的伪随机整数(Uniformly distributed pseudorandom integers) X = randi(imax)返回一个介于1到imax的伪随机整数，闭区间[1,imax]. X = randi(imax,n)返回一个在[1,imax]范围内的n*n的伪随机整数矩阵 X = randi(imax,sz1,...,szN) X = randi(imax,sz) X = randi(imax,classname) X = randi(imax,n,classname) X = randi(imax,sz1,...,szN,classname) X = randi(imax,sz,classname) X = randi(imax,&#39;like&#39;,p) X = randi(imax,n,&#39;like&#39;,p) X = randi(imax,sz1,...,szN,&#39;like&#39;,p) X = randi(imax,sz,&#39;like&#39;,p) X = randi([imin,imax],___) 指定生成区间randi([1,4])，生成[1,4]的随机整数 栗子:12345678910111213%生成一个由样本区间 [-5,5] 中均匀分布的随机整数组成的 10×1 列向量。 r = randi([-5,5],10,1)r = 10×1 3 4 -4 5 1 -4 -2 1 5 5 randperm randperm 语法: p = randperm(n)返回行向量，其中包含从 1 到 n（包括二者）之间的整数随机置换。 p = randperm(n,k)返回行向量，其中包含在 1 到 n（包括二者）之间随机选择的 k 个唯一整数。 123456789101112131415161718randperm(6)可能是向量[3 2 6 4 1 5]也可能是从 1 到 6 的整数的其他一些置换，具体取决于随机数生成器的状态。对 randperm 连续调用两次通常会返回两个不同的向量：randperm(6)ans = 5 2 6 4 1 3randperm(6)ans = 4 1 6 2 3 5 randperm(6,3)可能是向量[4 2 5]也可能是从 1 到 6（包括二者）的任何三个整数的其他一些置换，具体取决于随机数生成器的状态。]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>rand及其相关函数</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab常用函数之num2str与str2num]]></title>
    <url>%2F2019%2F04%2F03%2Fmatlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B9%8Bnum2str%E4%B8%8Estr2num%2F</url>
    <content type="text"><![CDATA[num2str 调用格式: s = num2str(A) s = num2str(A,precision)precision: Maximum number of significant digits.把数组A转换成字符串形式表示，precision表示精度， 比如precision为3表示保留最多3位有效数字 s = num2str(A,formatSpec) formatspec: Format of output fields.按format指定格式进行格式化转换，通常’%11.4g’是默认的。 str2num 调用格式: x = str2num(&#39;str&#39;)str是一个ASCII字符串表示的数值， 这种调用格式把字符串转换成数值。str也可以是一个字符串矩阵， 这种情况下， 字符串矩阵被转换成一个数值矩阵。 [x, status] = str2num(&#39;str&#39;)附加的返回值status用于获取转换状态， status等于逻辑1表示转换成功， 等于0表示转换失败。 例题：1234567891011121314151617181920212223 str2num(&apos;2 4 6 8&apos;) % Separate with spaces. ans = 2 4 6 8 str2num(&apos;2,4,6,8&apos;) % Separate with commas. ans = 2 4 6 8 str2num(&apos;[2 4 6 8]&apos;) % Enclose in brackets. ans = 2 4 6 8 str2num(&apos;2; 4; 6; 8&apos;)ans = 2 4 6 8And now a 2-by-2 matrix:str2num(&apos;2 4; 6 8&apos;)ans = 2 4 6 8]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>str2num与num2str</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdownpad2使用技巧]]></title>
    <url>%2F2019%2F04%2F03%2Fmarkdownpad2%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[markdownpad2常用快捷键 Ctrl + I ： 斜体 Ctrl + B ： 粗体 Ctrl + G ： 图片 Ctrl + Q ： 引用 Ctrl + 1 ： 标题 1 Ctrl + 2 ： 标题 2 Ctrl + 3 ： 标题 3 Ctrl + K ： 代码块 Ctrl + L ： 超链接 Ctrl + T ： 时间戳 Ctrl + U ： 无序列表 Ctrl + R ： 水平标尺 F4 ： 启用水平布局 F5 ： 启用实时预览 F6 ： 在浏览器中预览 Ctrl + Shift + O ： 有序列表 ​]]></content>
      <categories>
        <category>markdown编辑器</category>
        <category>markdownpad2</category>
      </categories>
      <tags>
        <tag>markdown编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typora]]></title>
    <url>%2F2019%2F04%2F03%2Ftypora%2F</url>
    <content type="text"><![CDATA[typora简介 无论是Word中带有加粗等格式的文字，还是Excel中的表格，一旦黏贴到Typora中，都会被自动转化为对应的Markdown格式，所以你再也不用担心每次重新设置格式的麻烦了——Markdown最麻烦的表格也可以在Excel中做完再贴入生成了。 专注模式，也就是除了正在编辑的那行文字，文章上下其余的内容全部变成灰色，不吸引你的视线，不干扰你的思维。 与专注模式搭配的话，当然还是全屏模式(F11)最好啦 qwq 打字机模式（Typewriter Mode）:开启这种模式后，Typora 的光标所在行会始终保持在屏幕中间，这样你码字时眼睛可以一直正对着屏幕中间 打开/关闭源代码模式 typora默认界面是实时预览的模式,而这也是与其他Markdown软件较大的区别.切换成源代码模式可以更方便地修改内容 方法1:点击左下角的&lt;/&gt;(启用/关闭源代码模式) 方法2:Ctrl+/ 快捷键 无序列表：输入-之后输入空格 有序列表：输入数字+“.”之后输入空格 任务列表：-[空格]空格 文字 标题：ctrl+数字 表格：ctrl+t 生成目录：[TOC]按回车 选中一整行：ctrl+l 选中单词：ctrl+d 选中相同格式的文字：ctrl+e 跳转到文章开头：ctrl+home 跳转到文章结尾：ctrl+end 搜索：ctrl+f 替换：ctrl+h 引用：输入&gt;之后输入空格 代码块：ctrl+alt+f 加粗：ctrl+b 倾斜：ctrl+i 下划线：ctrl+u 删除线：alt+shift+5 插入图片：直接拖动到指定位置即可或者ctrl+shift+i 插入链接：ctrl+k ​ 参考文献：typora typora2 typora快捷键 typora界面入门]]></content>
      <categories>
        <category>markdown编辑器</category>
        <category>typora</category>
      </categories>
      <tags>
        <tag>markdown编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对matlab中diag函数的补充]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%AF%B9matlab%E4%B8%ADdiag%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[diag函数的补充 A是矩阵，那么diag(A)得到的是主对角线上的元素构成的列向量，如果A是行列向量，那么得到的是矩阵（A为对角线元素，其他是0） X = diag(v,k)其中v是一个含有n个元素的向量，该调用格式可以构造一个n+abs(k)阶的方阵X。并把v作为方阵X的第k条对角线（k大于0，表示主对角线上方的第k条对角线，k小于0表示主对角线下侧的第k条对角线，k等于0表示主对线）。 X = diag(v)等价于X = diag(v,0) v = diag(X,k)以向量形式返回矩阵X中第k条对角线上的元素。 v = diag(X)等价于v = diag(X, 0) D = diag(v) D = diag(v,k) 如果v为向量，那么当k&gt;0时，D就是v为主对角线以下第k条对角线构成的矩阵，其它元素均为0 x = diag(A) x = diag(A,k)如果A为矩阵，那么当k&gt;0时，x就是矩阵A主对角线上第k条对角线上的元素构成的列向量]]></content>
      <categories>
        <category>matlab</category>
        <category>函数</category>
        <category>diag</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab实用命令]]></title>
    <url>%2F2019%2F03%2F31%2Fmatlab%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[在命令行敲入 dbstop if error如果运行出现错误，matlab会自动停在出错的那行，并且保存所有相关变量。再也不用设断点了有没有！！！ 若要取消，用dbclear if error 现在版本在断点选项里自带]]></content>
      <categories>
        <category>matlab</category>
        <category>实用命令</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab代码练习]]></title>
    <url>%2F2019%2F03%2F30%2Fmatlab%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[S 确定函数y1=3*x+4与函数y2=x^2的交点,并将点绘制到区间[-5,5]中 1234567891011121314151617181920212223242526272829%法一clc,clear;close all;x = -5:0.01:5;y1 = 3*x+4;y2 = x.^2;plot(x,y1,x,y2,'g')hold on %如果不加这一句，画出的图像只有下面的交点t=find(abs(y2-y1)&lt;0.01);a = [];a(1) = 3*x(t(1))+4;a(2) = 3*x(t(2))+4;plot(x(t),a,'ro')x(t) %输出后可知为行向量%法二clc,clear;close all;x = -5:0.01:5;y1 = 3*x+4;y2 = x.^2;t=find(abs(y2-y1)&lt;0.01); %t是包含两个下标索引的行向量%交点横坐标是x(t(1))与x(t(2))%x(t)就是包含2个横坐标的行向量%plot画图注意维度一致a = [];a(1) = 3*x(t(1))+4;a(2) = 3*x(t(2))+4;plot(x(t),a,'ro',x,y1,x,y2,'g') 两种方法图像是一样的 随机生成三个点，判断这三点是否能构成一个三角形若能构成三角形则输出其面积。 123456789101112131415161718192021222324252627%一clc;clear;a=rand(3,2);d=squareform(pdist(a));f=@(a,b,c)sqrt((a+b+c)/2*((a+b+c)/2-a)*((a+b+c)/2-b)*((a+b+c)/2-c));s=f(d(1,2),d(1,3),d(2,3));if s==0 fprintf('这三个点不构成一个三角形')else fprintf('这三个点构成三角形的面积为：s=%d\n',s)end%画出来/法二clc,clear;close all;a = rand(3,2);d = squareform(pdist(a));if d(1,2)+d(1,3) &gt; d(2,3)&amp;d(2,3)+d(1,3) &gt; d(1,2)&amp;d(1,2)+d(2,3) &gt; d(1,3) e = d(1,2)+d(1,3)+d(2,3); s = sqrt(e*(e-d(1,2))*(e-d(1,3))*(e-d(2,3))); x = [a(:,1);a(1,1)]; y = [a(:,2);a(1,2)]; plot(x,y) fprintf('三角形面积为:s=%f\n', s )else disp('无法构成三角形')end 输入绳子的长度n，将该绳子分成三段，每段的长度为正整数，输出由该三段绳子组成的三角形个数。 1234567891011121314%暴力法 不推荐clc;clear;n=input('the length of string is ');num=0;for i1=1:n-2 %三个边长的穷举 for i2=i1:n-1-i1 i3=n-i1-i2; if i1+i2&gt;i3 &amp;&amp; i1+i3&gt;i2 &amp;&amp; i2+i3&gt;i1 &amp;&amp; i3&gt;=i2 num=num+1;%计数加一fprintf('the num is %d %d %d\n',i1,i2,i3); end endendfprintf('长度为 %d 的绳子分成三段可以组成 %d 个三角形\n',n,num); 一个不透明的袋子中放了黑白各一球（除了颜色，其他均相同）。随机从中取出一球，如果取到黑球，则将此球放入袋中，摇匀，继续取，直到取出白球才结束。问：取到白球所需次数的数学期望 123456789101112131415161718192021222324252627282930%方法一clc;clear;t=solve('1*( 1/2)+( 1+ t )*( 1/2)-t');%原理数学期望文章里有t%二%函数clc,clear;syms k;symsum(k*(1/2)^k,k,1,inf)%三clc,clear;rand('state',sum(100*clock))a = 0;for i = 1:inf j = randi(2); %生成[1, 2]的整数 if j == 2 &amp;&amp; i &gt; 20 %p避免偶然性，实验次数要多一点，所以i&gt;20%因为取出的白球1/2概率太大，实验次数无法达到那么多%所以将20次前的取出的白球与黑球，都当作白球处理，后面正常处理 break; end a = a+1;endt = 0;for k = 1:i t = (1/2)^(k)*k+t;endt 一只失明的小猫不幸掉进山洞里,山洞有三个门,一个门进去后走2h可以回到地面,从第二个门进去后走4h又回到原始出发点,不幸的是从第三个门进去后走6h还 是回到原始出发点。猫每次都是随机地选择其中一个门走。那么可怜的小猫走出山洞的时间期望是多少? 123456789101112131415161718192021222324%法一clc,clear;s=0;for i=1:10000 a=randi([1,3]); while a~=1 if a==2 s=s+4; else s=s+6; end a=randi([1,3]); end s=s+2;endfprintf('小猫走出山洞的时间期望为%d\n',s/i);%法二%设未知数期望时间为t，小猫选择第二或第三个门的情况，走完4h,6h,后又回到了原点，%接下来走出去所花费的时间就是期望时间了%t =2×( 1/3)+( 4+ t )×( 1/3)+( 6+ t )×1/3 解方程得 t =12clc;clear;t=solve('2*( 1/3)+( 4+ t )*( 1/3)+( 6+ t )*1/3-t');fprintf('小猫走出山洞的时间期望为%d\n',t); 生成一个5*5的随机矩阵A，并计算A的两条对角线之和。 123clc,clear;a = rand(5,5);b = sum(diag(a)+diag(a')) - a(3,3) 任意输入一串数字，输出这一串数字所组成的最大数字和最小数字。 12345678910clc,clear;a = input('a = ');b = num2str(a);c = length(b);d = [];for i = 1:c d(i) = str2num(b(i));endsort(d)%该题没考虑首位为0情况，注意，出题人也没设置sort(d, 'descend') 求100以内素数的和 123clc;clear;a=primes(100);sum(a) 1234567891011121314151617181920212223242526272829303132333435363738%法一clc; clear;close all;x=-3:0.01:4;y=sqrt(1-(x).^2).*(x&gt;=-1&amp;x&lt;0)+2.^(x).*(x&gt;=0&amp;x&lt;2)+(x+1).*(x&gt;=-3&amp;x&lt;-1)+4*(x&gt;=2); %注意括号!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!特别是对x的括号！多加可以防止错误发生%按我的理解，因为x的范围构成了一个矩阵(很多个横坐标)，所以对于图里面第二个函数与第三个函数，是点乘，因为要算出每一个横坐标的纵坐标，所以%用点乘使得每个元素运算，如果去掉会报错plot(x,y)clc;clear;close all;x = -3:0.01:4;y = 4*(x&gt;= 2)+2.^x.*(x &gt;= 0&amp;x &lt; 2)+sqrt(1-x.^2).*(x&gt;=-1&amp;x&lt;0)+(x+1).*(x &gt;= -3 &amp; x &lt; -1);plot(x,y)%法二，看看就行，算了，别看了，垃圾写法clc,clear;close all;y1 = 4*ones(1,21);x1 = 2:0.1:4;plot(x1,y1)hold on%quex2 = 0:0.01:2;y2 = 2.^(x2);plot(x2, y2)hold onx3 = -1:0.001:0;y3 = sqrt(1-(x3).^2);plot(x3,y3)hold onx4 = -3:0.001:-1;y4 = x4+1;plot(x4,y4) 任意给出一个矩阵，找出矩阵中大于平均元素的元素，并存放于另一个矩阵中。 1234567891011121314151617181920%法一clc;clear; a=rand(3);s=[ ];m=mean(a(:));for i=1:9 if a(i)&gt;m s=[s;a(i)]; endends%法二clc;clear; a=rand(3);b=a(:);m=mean(b);c=max(b,m);c( find(c==m) )=[ ]; %这里有关于查找数组满足条件元素其它方法，在矩阵操作补充里c 任意给出一个矩阵，求删除周围元素。 1234567891011121314151617181920212223clc;clear; m=input('m=');n=input('n=');a=rand(m,n)a( [1 end] , : )=[ ];a( : , [1 end] )=[ ];a%answera = 0.8147 0.0975 0.1576 0.1419 0.6557 0.9058 0.2785 0.9706 0.4218 0.0357 0.1270 0.5469 0.9572 0.9157 0.8491 0.9134 0.9575 0.4854 0.7922 0.9340 0.6324 0.9649 0.8003 0.9595 0.6787a = 0.2785 0.9706 0.4218 0.5469 0.9572 0.9157 0.9575 0.4854 0.7922 以最短的程序创建一个10*10的矩阵，要横着数的从1到100。 1234567891011121314151617clc;clear; a=1:100;b=reshape(a,10,10)c=b'%answerc = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 随机生成某数列，求四周元素的平均值 123456789101112131415161718192021222324252627%法一clc;clear; n=input('n=');m=input('m=');a=rand(m,n)x=[ ];for i=1:m for j=1:n if i==1 || i==m || j==1 || j==n x=[x a(i,j)]; end endendmean(x)%法二clc;clear; n=input('n=');m=input('m=');a=rand(m,n)x=[ ];b = a( [1 end] , : );x=[x;b(:)]; %注意这种方法a( [1 end] , : ) = [];c = a( : , [1 end ] );x=[x;c(:)];mean(x)]]></content>
      <categories>
        <category>matlab</category>
        <category>代码练习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab绘图]]></title>
    <url>%2F2019%2F03%2F28%2Fmatlab%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言 在求线性规划题目时，可以将函数图像相交的点求出来，作为横坐标端点即先求后画.其它题目有时可以先求后解，算一个别样的技巧吧 最好加一个close all; 线图 图形对象属性 绘图基础 可以直接在图形窗口上修改图形 如果当前不存在图形窗口，MATLAB 的绘图函数会自动 建立一个新的图形窗口；如果已存在一个图形窗口，MATLAB 的绘图函数就会在这个窗口 中进行绘图操作；如果已存在多个图形窗口，MATLAB 的绘图函数就会在当前窗口中进行 绘图操作(当前窗口通常是指后一个使用的图形窗口)。 matlab绘图是将图形每一个点标出后连接而成，因为横坐标间隔值不一定相同，所以2个图形相交y值不一定相等，找交点s=find(abs(y1-y2)&lt;0.01))其中0.01设置具体看横坐标间隔值大小，否侧可能找不到 plot函数维度必须相同，因为图形是将点连接起来，所以x与y个数维度必须相同 plot函数可以标点！画点(因为画图是画点再连接起来) 注意s是横坐标x的下标，而且是向量(多个交点，多个下标) 注意： 如果已经存在一个图形窗口，plot命令则清除当前图形，绘制新图形 可任意设定曲线颜色和线型 可给图形加坐标网线和图形加注功能 例题 解法一 12345678910111213141516clc,clear;close all;x1=[0:0.1:4];y1 = sqrt(x1);x2=[4:0.1:6]y2 = 2*ones(1,21); %注意这里如果是直接写2，因为plot画图是多个点连接，y2只有一个值，所以要创建与x2横坐标相同维度的y2x3 = [6:0.1:8];y3 = 5-x3/2;y4 = 1;plot(x1,y1);hold onplot(x2,y2);hold onplot(x3,y3);hold onplot([8:0.1:10],y4); 解法二:注意下方分段函数的表达 123456clc; clear allx=0:0.01:10;y=sqrt(x).*(x&gt;=0&amp;x&lt;4)+2*(x&gt;=4&amp;x&lt;6)+(5-x/2).*(x&gt;=6&amp;x&lt;8)+1*(x&gt;=8); %注意学习plot(x,y,'r','linewidth',2)axis([0 10 0 2.1])grid on 命令行 1.hold on: hold on retains plots in the current axes so that new plots added to the axes do not delete existing plots. New plots use the next colors and line styles based on the ColorOrder and LineStyleOrder properties of the axes. MATLAB® adjusts axes limits, tick marks, and tick labels to display the full range of data. hold on保留当前坐标轴中的绘图，这样添加到坐标轴中的新绘图就不会删除现有的绘图。新绘图使用基于坐标轴的ColorOrder和LineStyleOrder属性的下一种颜色和线条样式。MATLAB®调整坐标轴限制、刻度标记和刻度标签，以显示全部数据范围。 例题:123456x = linspace(-pi,pi);y1 = sin(x);y2 = cos(x);plot(x,y1)hold onplot(x,y2) 2.close all;关闭所有图形窗口 图形标注 有关图形标注函数的调用格式为 title(‘图形名称’) xlabel(‘x轴说明’) ylabel(‘y轴说明’) text(x, y, ‘图形说明’) %在坐标位置(x,y)处添加文字“图形说明” legend函数用于对绘制曲线所用线型、颜色或数据点标记作图例说明，放置在空白处，可以通过鼠标移动图例，将其拖放到其它位置。部分函数同样适用于三维图形，在三维图中z坐标轴说明用zlabel函数。 legend(‘图例1’, ‘图例2’, …) gca gca 表示当前坐标区或图 ax = gca 返回当前图窗的当前坐标区或图，这通常是最后创建的图窗或用鼠标点击的最后一个图窗。图形函数（例如 title）的目标为当前坐标区或图。可以使用 ax 访问和修改该坐标区或图的属性。如果该坐标区或图不存在，gca 将创建笛卡尔坐标区。 Axes属性 Axes 属性 FontSize - 字体大小 数值标量 函数 将标题、坐标轴标记、网格线及文字注释加注到图形上，这些函数为： 12345678title —— 给图形加标题xlable —— 给x轴加标注ylable —— 给y轴加标注text —— 在图形指定位置加标注gtext —— 将标注加到图形任意位置grid on(off) —— 打开、关闭坐标网格线legend —— 添加图例axis —— 控制坐标轴的刻度 还有xlim(ylim,zlim)，line, set…例题 1234567891011121314151617clc;clear;close all;t=0:0.1:10;y1=sin(t);y2=cos(t);plot(t,y1,'r',t,y2,'b--');set(gca,'FontSize',10);x=[1.7*pi;1.6*pi];y=[-0.3;0.8];s=['sin(t)';'cos(t)'];text(x,y,s);title('正弦和余弦曲线');legend('正弦','余弦')xlabel('时间t')ylabel('正弦、余弦')gridaxis square plot函数 若用一个plot函数画多个图时，横坐标维度必须一致 plot(x,y,’s’) —— 开关格式，开关量字符串s设定曲线颜色和绘图方式，如: plot(x1,y1,’y*’,x2,y2,’rO’，…) S的标准设定值如下： 12345678910111213141516171819字母 颜色 标点 线型 y 黄色 : 点线 m 粉红 ○ 圈线 c 亮蓝 × ×线 r 大红 ＋ ＋字线 g 绿色 - 实线 b 蓝色 * 星形线 w 白色 -- 虚线 k 黑色 -. 点划线 v 下三角 ^ 上三角 &lt; 左三角 &gt; 右三角 square 正方形 diamond 菱形 pentagram 五角星 hexagram 六角星 例题12345678t=0:pi/100:2*pi;y=sin(t);y1=sin(t+0.25);y2=sin(t+0.5);y3=cos(t);y4=cos(t+0.25);y5=cos(t+0.5);plot(t,[y',y1',y2',y3',y4',y5']) plot(X,Y,’S’)命令 X,Y为同维向量时，绘制以X,Y元素为横、纵坐标的曲线； X是向量，Y是有一维与X等维的矩阵时，则绘制出多根不同色彩的曲线. 曲线数等于Y矩阵的另一维数，X被作为这些曲线的共同横坐标； X是矩阵，Y是向量时，情况与上面的相同，只是曲线都以Y为共同纵坐标； X,Y为同维矩阵时，则以X、Y对应列元素为横、纵坐标分别绘制曲线，曲线条数等于矩阵的列数. plot(X1,Y1,S1,X2,Y2,S2,X3,Y3,S3,)命令 在这个格式中，每一个“三元组”(X,Y,’S’)的结构和作用与plot(X,Y,’S’)相同. 不同的三元组之间没有约束关系. plot(x,y)——x,y为长度相同的向量，存储x坐标和y坐标用于绘制二维平面上的直角坐标图，以x为横坐标，y为纵坐标的二维曲线。 多窗口绘图 figure(n) —— 创建窗口函数，n为窗口顺序号。 1234567t=0:pi/100:2*pi;y=sin(t);y1=sin(t+0.25);y2=sin(t+0.5);plot(t,y) —— 自动出现第一个窗口figure(2)plot(t,y1) —— 在第二窗口绘图figure(3)plot(t,y2) ——在第三窗口绘图 符号函数(显函数、隐函数和参数方程)画图 ezplot ezplot(‘f(x)’,[a,b]) 表示在a&lt;x&lt;b绘制显函数f=f(x)的函数图。 ezplot(&#39;f(x,y)&#39;,[xmin,xmax,ymin,ymax]) 表示在区间xmin&lt;x&lt;xmax和 ymin&lt;y&lt;ymax绘制隐函数f(x,y)=0的函数图。 ezplot(&#39; x(t) &#39;, &#39; y(t) &#39;,[tmin,tmax]) 表示在区间tmin&lt;t&lt;tmax 绘制参数方程x=x(t),y=y(t)的函数图。 ezplot函数：ezplot函数可以绘制符号函数的简易二维图形，其使用格式如下： 1）ezplot(f)命令，对于显式函数f=f(x)，在默认的范围[-pi,pi]上绘制该函数f=f(x)的图形；对于隐函数f(x,y)=0，在默认的平面区域[-2*pi&lt;x&lt;2*pi, -2*pi&lt;y&lt;2*pi]上绘制该函数f(x,y)=0的图形。 2） ezplot(x,y)命令，在默认的范围[0&lt;t&lt;2*pi]内绘制参数形式函数x=x(t)与y=y(t)的图形。 3）ezplot(f,[a,b])命令，在指定的范围[a&lt;x&lt;b,a&lt;y&lt;b]内绘制表达式为f=f(x)的显式函数图形。 4）ezplot(f,[xmin,xmax,ymin,ymax])命令，在平面矩形区域[xmin&lt;x&lt;xmax,ymin&lt;y&lt;ymax]上绘制隐函数f(x,y)=0的图形。 5）ezplot(x,y,[tmin,tmax])命令，在指定的范围[tmin&lt;t&lt;tmax]内绘制参数形式的函数x=x(t)与y=y(t)的图形。 画隐函数ezplot的调用格式： ezplot(f)—这里f为包含单个符号变量x的符号表达式，在x轴的默认范围[-2pi 2pi]内绘制f(x)的函数图 ezplot(f,xmin,xmax) — 给定区间 ezplot(f,[xmin,xmax],figure(n)) — 指定绘图窗口绘图。 plot3函数 plot3 三维绘图，plot3(X1,Y1,Z1,...)如果 X1、Y1、Z1 中的一个或多个是向量，则会绘制向量对矩阵各行或各列的图，具体取决于向量的长度是否等于矩阵的行数或列数。1234567891011121314151617%Define t as a vector of values between 0 and 10π. Define st and ct as vectors of sine and cosine values. Then plot st, ct,and tt = 0:pi/50:10*pi;st = sin(t);ct = cos(t);plot3(st,ct,t)%Create matrix X containing three rows of x-coordinates. Create matrix Y containing three rows of y-coordinates. t = 0:pi/500:pi;X(1,:) = sin(t).*cos(10*t);X(2,:) = sin(t).*cos(12*t);X(3,:) = sin(t).*cos(20*t);Y(1,:) = sin(t).*sin(10*t);Y(2,:) = sin(t).*sin(12*t);Y(3,:) = sin(t).*sin(20*t);Z = cos(t);plot3(X,Y,Z) 坐标控制 axis的用法有： axis([xmin xmax ymin ymax]) —— 用行向量中给出的值设定坐标轴的最大和最小值。 如axis ([-2 2 0 5]) axis(equal) —— 纵横坐标轴采用等长刻度 axis on(off) —— 显示和关闭坐标轴的标记、标志 axis auto —— 将坐标轴设置返回自动缺省值 axis SQUARE设置当前图形为正方形（或立方体形),axis square刻度范围不一定一样，但是一定是方形的 axis equal将横轴纵轴的定标系数设成相同值,axis equal刻度是等长的，但也不一定是方形的。 给坐标加网格线可以用grid命令来控制，grid on/off命令控制是否添加网格线，不带参数的grid命令在两种之间进行切换。 还有函数xlim(ylim,zlim)函数可以设置坐标范围 legend legend在坐标区上添加图例 部分调用格式： lgd = legend(___) 返回 Legend 对象。可使用 lgd 在创建图例后查询和设置图例属性。 legend(bkgd)（其中 bkgd 为 ‘boxoff’）删除图例背景和轮廓。bkgd 的默认值为 ‘boxon’，即显示图例背景和轮廓 legend(label1,...,labelN) 设置图例标签。以字符向量或字符串列表形式指定标签，例如 legend(&#39;Jan&#39;,&#39;Feb&#39;,&#39;Mar&#39;)。 legend(target,___) 使用 target 指定的坐标区、极坐标区或图形，而不是使用当前坐标区或图形。指定 target 作为第一个输入参数 legend(subset,___) 仅在图例中包括 subset 中列出的数据序列的项。subset 以图形对象向量的形式指定。您可以在指定标签之前或不指定其他输入参数的情况下指定 subset 创建一个包含两个子图的图窗，并返回两个 Axes 对象 ax1 和 ax2。在每个子图中对随机数据绘图。通过指定 ax1 作为 legend 的第一个输入参数，在上部子图中添加一个图例。 123456789y1 = rand(3);ax1 = subplot(2,1,1); plot(y1)y2 = rand(5);ax2 = subplot(2,1,2); plot(y2)legend(ax1,&#123;'Line 1','Line 2','Line 3'&#125;) 如果您不想将绘制的所有图形对象都包含在图例中，可以指定要包含的图形对象。绘制三个线条并返回创建的 Line 对象。创建只包含其中两条线的图例。将第一个输入参数指定为要包含的 Line 对象的向量。12345678910111213x = linspace(0,pi);y1 = cos(x);p1 = plot(x,y1);hold ony2 = cos(2*x);p2 = plot(x,y2);y3 = cos(3*x);p3 = plot(x,y3);hold offlegend([p1 p3],&#123;'First','Third'&#125;) 绘制两个线条并创建一个图例。然后为图例添加标题。1234567891011x = linspace(0,pi);y1 = cos(x);plot(x,y1)hold ony2 = cos(2*x);plot(x,y2)hold offlgd = legend('cos(x)','cos(2x)');title(lgd,'My Legend Title') 绘制两个线条并在坐标区左下角创建一个图例。然后，删除图例的背景和轮廓。1234567891011x = linspace(0,pi);y1 = cos(x);plot(x,y1)hold ony2 = cos(2*x);plot(x,y2)hold offlegend(&#123;'cos(x)','cos(2x)'&#125;,'Location','southwest')legend('boxoff') xlabel xlabel为 x 轴添加标签 调用格式: xlabel(txt) 将为 gca 命令返回的当前坐标区或图的 x 轴添加标签。重新发出 xlabel 命令会将旧标签替换为新标签。示例 xlabel(target,txt) 将向 target 指定的坐标区或图形添加标签。 xlabel(___,Name,Value) t = xlabel(___)返回用作 x 轴标签的文本对象。使用 t 可在创建标签后对其进行修改。 使用字符向量元胞数组创建多行标签。 12plot((1:10).^2)xlabel(&#123;'Population','(in thousands)'&#125;) 在 x 轴标签中包括变量值 添加带有文本和变量值的标签。使用 num2str 函数在标签中包含变量值。 123plot((1:10).^2) year = 2014;xlabel(['Population for Year ',num2str(year)]) 在轴标签中包括上标和下标，更改 x 轴标签字体大小和颜色 文档里面 为特定子绘图的 x 轴添加标签 创建带有两个子图的图窗。为顶部子绘图的 x 轴添加标签。123456ax1 = subplot(2,1,1);plot((1:10).^2)xlabel(ax1,'Population')ax2 = subplot(2,1,2);plot((1:10).^3) text text 向数据点添加文本说明 调用格式: text(x,y,txt) 使用由 txt 指定的文本，向当前坐标区中的一个或多个数据点添加文本说明。若要将文本添加到一个点，请将 x 和 y 指定为以数据单位表示的标量。若要将文本添加到多个点，请将 x 和 y 指定为长度相同的向量。 text(x,y,z,txt) 在三维坐标中定位文本。 text(ax,___)在由 ax 指定的坐标区中，而不是在当前坐标区 (gca) 中创建文本。选项 ax 可以位于前面的语法中的任何输入参数组合之前。 t = text(___) 返回一个或多个文本对象。使用 t 修改所创建的文本对象的属性。有关属性和说明的列表，请参阅 Text 属性。可以使用上述任意语法指定一个输出。 向多个数据点添加文本 绘制一个线条。将相同的文本添加到沿该线条的两个点。12345678x = linspace(-5,5);y = x.^3-12*x;plot(x,y)xt = [-2 2];yt = [16 -16];str = 'dy/dx = 0';text(xt,yt,str) 通过将 str 指定为元胞数组，向每个点添加不同文本。 12345678x = linspace(-5,5);y = x.^3-12*x;plot(x,y)xt = [-2 2];yt = [16 -16];str = &#123;'local max','local min'&#125;;text(xt,yt,str) 显示多行文本 创建一个线图，并向坐标区添加一个文本说明。通过将 str 指定为元胞数组显示多行文本。123plot(1:10)str = &#123;'A simple plot','from 1 to 10'&#125;;text(2,7,str) 创建一个线图，并向坐标区添加两个文本说明。在向坐标区添加多个文本说明时，通过指定嵌套元胞数组显示多行文本。123plot(1:10)str = &#123;&#123;'A simple plot','from 1 to 10'&#125;,'y = x'&#125;;text([2 8],[7 7],str)]]></content>
      <categories>
        <category>matlab</category>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab字符串]]></title>
    <url>%2F2019%2F03%2F27%2Fmatlab%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串 字符串是用单引号括起来的字符集合，可以像向量一样进行拼接和裁剪。 1234Eg：&gt;&gt;s1=&apos;Hello&apos;;s2=&apos;every&apos;;s3=&apos;body&apos;; s=[s1,&apos; &apos;,s2,&apos; &apos;,s3] ss=s(1:5) 字符串]]></content>
      <categories>
        <category>matlab</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab矩阵以及常用函数]]></title>
    <url>%2F2019%2F03%2F27%2Fmatlab%E7%9F%A9%E9%98%B5%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数调用 调用函数文件的一般格式为 [输出参数表]=函数名(输入参数表) 调用函数时应注意： 当调用一个函数时，输入和输出参数的顺序应与函数定义时的一致，其数目可以 按少于函数文件中所规定的输入和输出参数调用函数，但不能使用多于函数文件所规定的 输入和输出参数数目。如果输入和输出参数数目多于或少于函数文件所允许的数目，则调 用时自动返回错误信息。 当函数有一个以上输出参数时，输出参数包含在方括号内。例如，[m,n]=size(x)。 注意：[m,n]在左边表示函数的两个输出参数 m 和 n；不要把它和[m,n]在等号右边的情况混 淆，如 y=[m,n]表示数组 y 由变量 m 和 n 所组成。 矩阵 下标从1开始 矩阵里面元素可以是符号与字符（‘a’,’,’）,输入的元素维度要一样 矩阵里面的元素也可以是矩阵，但是矩阵长度维度必须与其它元素相同 生成10*10的矩阵可以如下：a = [1:10;11:20;21:....];就是运用： 对矩阵a第一行后面2个赋予其他值(灵活运用：) 1234a = [1 2 3 4 7 8 1 2 5]; a(1,2:3) = x; 对一个矩阵A赋值提取可以取出然后赋给一个小矩阵a 矩阵的下标也可以是向量。 例如 b=a(x,y)；可以得到一个矩阵 b。a 的行标来自向量 x，而列标来自向量 y。 例如，矩阵 a 有 n 列，那末 b=a(:,n:-1:1) 将得到矩阵 b，它等于矩阵 a 按列的逆序排列。 a(end:-1:end-5, 3)是最后一行到倒数第6行的所有第三个元素 删除矩阵某行某列a(i,j)=[]; 如果要将一个矩阵存储在计算机中，MATLAB 规定矩阵元素在存储器中的存放次序是 按列的先后顺序存放，即存完第 1 列后，再存第 2 列，依次类推 作为矩阵的特例，一维数组或者说向量元素是依其元素本身的先后次序进行存储的。 必须指出，不是所有高级语言都这样规定矩阵(或数组)元素的存储次序，例如 C 语言 就是按行的先后顺序来存放数组元素，即存完第 1 行后，再存第 2 行，依次类推。记住这 一点对正确使用高级语言的接口技术是十分有益的。 12345678910111213141516171819202122232425262728293031323334353637clc;clear;a=[2 5 6 9 8 86 4 5 6 65 3 54];m=a(1);for i=1:12 if a(i)&gt;m m=a(i); endend m a=[1,2,3,4,5,6,7];for i=1:7 a(i)=a(i)+1;endclc,clearA=[0.5,1.732,0.618,3.1415,1.6,0.9];for i=1:6 for j=i:6 if a(j)&lt;a(i) a(i)=a(i)+a(j); a(j)=a(i)-a(j); a(i)=a(i)-a(j); end endendclc,clearfor i=1:15 for j=1:15 if i+j==15&amp;&amp;4*i+2*j==40 fprintf(‘兔%d只,鸡%d只\n’,i,j); end endend 矩阵除法 解线性方程组时，我们需要用到矩阵的除法。 a为系数矩阵，b为结果矩阵，x为解集矩阵。 当遇到A*X=B时，两边左除A，X=A\B。 当遇到X*A=B时，两边右除A，X=B/A。 如果我们需要矩阵A与B对应元素相除，依旧点除。 矩阵旋转 对于函数rot90顺时针旋转90度，可以rot90(a,3);或者rot90(a,-1); fliplr(A)左右旋转，就是最后2个字母l，r即left,right flipud(A)上下旋转，就是最后2个字母u,d即up,down B = fliplr(A) 返回 A，围绕垂直轴按左右方向翻转其各列。 如果 A 是一个行向量，则 fliplr(A) 返回一个相同长度的向量，其元素的顺序颠倒。如果 A 是一个列向量，则 fliplr(A) 只返回 A。对于多维数组，fliplr 作用于由第一个和第二个维度构成的平面。 fliplr(A) 等效于 flip(A,2)。 reshape函数 按列优先 size函数 矩阵元素的操作 取矩阵A的第i1~i2行、第j1~j2列构成新矩阵:A(i1:i2, j1:j2) 以逆序提取矩阵A的第i1~i2行，构成新矩阵:A(i2:-1：i1，:） 以逆序提取矩阵A的第j1~j2列，构成新矩阵:A(:, j2:-1：j1） 删除A的第i1~i2行，构成新矩阵:A(i1:i2，：)=[ ] 删除A的第j1~j2列，构成新矩阵:A(：， j1:j2)=[ ] 将矩阵A和B拼接成新矩阵：[A B]；%行连接[A；B]%列连接 按照matlab中列优先提取 形如a(k)的都是单下标索引，按照列优先原则 想提取出a的2、5两个元素，并放入新矩阵中，可以使用a( [ 2 5 ] ), 2和5必须用[ ]括起来,否则像a(2 5)计算机是读不出来的。 同理，提取a( [ 1 3 5 ] )是提取第1、3、5个矩阵并放入同一行，此时也可以使用a(1:2:5)，因为冒号存在，没有[ ]计算机也知道它的意思。 如果我要把第1、3个元素放入第一行，第2、4个元素放入第二行，可以a( [ 1 3;2 4 ] )。 a( [1,2,3] )逗号,空格都用来分隔 栗子: 1234567891011121314151617181920212223242526clc,clear;close all;a = [1 2 3 4 5 6];a([1 2],[1 2]) %双下标索引a([1 2])a([1 3; 2 4])%answer%第一行与第二行和第一列与第二列相交的元素ans = 1 2 3 4ans = 1 3ans = 1 5 3 2 a(:)代表提取a矩阵所有的元素，原理是排序法则(列优先)。 a( : , : )也是提取a矩阵所有的元素，与原矩阵相同 双下标索引 若a是已知的矩阵，a( [ 1 3 ] , [ 2 4 ] )的意思是：把a第1、3行和第2、4行相交的元素，放入新矩阵中。并且位置和原来保持一致。 矩阵乘法 matlab 中.和有什么区别简单的说: *代表变量相乘，或者矩阵相乘 .* 是矩阵中对应位置变量相乘，组成新得矩阵 例如12345678910[1 2 3].*[3 4 6]=[3 8 18]但是[1 2 3] * [3 4 6]就是语法错误！另外[1 2; 3 4] .*[5 6;7 8]=[5 12;21 28][1 2; 3 4]*[5 6;7 8]=[19 22;43 50]也就是说两个同维数的矩阵既可以点乘也可以矩阵相乘，只是结果不一样而已！*表示线性代数中矩阵相乘的概念！注意，在进行数与数之间的运算时“.*”和“*”是没有区别的，都是表示普通的乘法运算。例：m = 2，n = 4，m.*n = 8， m*n = 8。在进行矩阵之间的运算时“.*”和“*”的意义就有所不同了。假设a，b表示两个矩阵，a*b表示矩阵a与矩阵b进行矩阵相乘，a.*b表示矩阵a中的元素与矩阵b中的元素按位置依次相乘，得到的结果将作为新矩阵中相同位置的元素。 函数diag 1. diag函数：sum(diag(a)+diag(a&#39;))可以求矩阵a对角线上的元素之和，不过中间的一个元素会提取2次，diag(a&#39;)可以提取副对角线的元素(先将矩阵转置） 当Random是向量时，才构成对角矩阵，当Random是m×n矩阵时，得到的是个向量。比如diag([1 3;2 4])得到向量，diag([1 3])得到2×2矩阵。 可以用来访问对角元素 当 v 是向量时，diag(v)得到以 v 的元素为主对角线上元素的对角矩阵； 当 v 是矩阵时，diag(v)得到一个列向量，其元素为矩阵 v 主对角线上的元素， diag(v,1)得到矩阵 v 对角线上移一行的元素组成的列向量，diag(v,-1)得到矩阵 v 对 角线下移一行的元素组成的列向量。 diag(a)只是diag(a,0)的简写,diag提取出来的都是列矩阵 详情查看help max MAX 函数的几种形式 (1)max(a) (2)max(a,b) (3)max(a,[],dim) (4)[C,I]=max(a) (5)[C,I]=max(a,[],dim) (1)max(a)如果 a 是一个矩阵，比如 a=[1,2,3;4,5,6] ，max(a)的意思就是找出矩阵每列的最大值， 本例中：max(a)=[4,5,6] max(a)默认的是max(a,[ ],1)。 矩阵a是行矩阵时，max(a)不再是max(a,[ ],1),而转换为了max(a,[ ],2)。 (2)max(a,b)如果 a 和 b 都是大于 1 维的矩阵，那么要求 a 和 b 的行列的维数都要相等，函数的结 果是比较 a 和 b 中每个元素的大小，比如：a=[1,2,3;4,5,6] b=[4,5,6;7,8,3]max(a,b)=[4,5,6;7,8,6]另外，如果 a 和 b 中至少有一个是常数，也是可以的。比如：a=[1,2,3;4,5,6] b=3 c=5 max(a,b)=[3,3,3;4,5,6] 相信大家看了例子都明白了函数的意思了吧max(b,c)=5 若a是矩阵，b是数字，那么max(a,b)后，自动把b转换成与a同纬度的矩阵，该矩阵中所有元素都是b，再进行max运算。 (3)max(a,[],dim)这个函数的意思是针对于 2 维矩阵的，dim 是英文字母 dimension 的缩写，意思是维数。当 dim=1 时，比较的 a 矩阵的列，也就是和 max（a）的效果是一样的；当 dim=2 时，比较的 是 a 矩阵的行。下面举个例子：a=[1,2,3;4,5,6] max(a)=max(a,[],1)=[4,5,6] 比较的第一行和第二行的值max(a,[],2)=[3,6] (4)[C,I]=max(a)C表示的是矩阵 a 每列的最大值， I 表示的是每个最大值对应的下标：下面举例说明：还是刚才那个例子：a=[1,2,3;4,5,6] [C,I]=max(a)结果显示的是 C=[4,5,6] I=[2,2,2] 返回的是最大值对应的行号。 C是a每列的最大值矩阵，跟用法一出现的新矩阵一致。I是a每列最大值出现位置对应的行数。 当然，C和I是只是新矩阵的名字，是可以换的。 如果这里有多个相同最大值时，返回的将是第一个最大值的索引。 (5)[C,I]=max(a,[],dim)同理：如果 dim=1 时，其结果和[c,i]=max(a) 是一样的。当 dim=2 时，同样上面的矩阵 a，我们运行一下：[c,i]=max(a,[],2) 结果是：c=[3,6] i=[3,3] i 返回的是矩阵 a 的列号。 文档 M = max(A) 返回数组的最大元素。 如果 A 是向量，则 max(A) 返回 A 的最大值。 如果 A 为矩阵，则 max(A) 是包含每一列的最大值的行向量。 如果 A 是多维数组，则 max(A) 沿大小不等于 1 的第一个数组维度计算，并将这些元素视为向量。此维度的大小将变为 1，而所有其他维度的大小保持不变。如果 A 是第一个维度长度为零的空数组，则 max(A) 返回与 A 大小相同的空数组。 M = max(A,[],&#39;all&#39;) 查找 A 的所有元素的最大值。(版本不一样，好像无法用) max(max(a))可以用取最大值 max(A,[],[1 2]) 计算 A 中所有元素的最大值(版本不一样) matlab中的sort函数 调用格式： B = sort(A) 如果 A 是向量，则 sort(A) 对向量元素进行排序。 如果 A 是矩阵，则 sort(A) 会将 A 的列视为向量并对每列进行排序。 如果 A 是多维数组，则 sort(A) 会沿大小不等于 1 的第一个数组维度计算，并将这些元素视为向量。 B = sort(A,dim)返回 A 沿维度 dim 的排序元素。例如，如果 A 是一个矩阵，则 sort(A,2) 对每行中的元素进行排序。 B = sort(___,direction)使用上述任何语法返回按 direction 指定的顺序显示的 A 的有序元素。’ascend’ 表示升序（默认值），’descend’ 表示降序。 排序方向必须为 ‘ascend’ 或 ‘descend’ B = sort(___,Name,Value)指定用于排序的其他参数。例如，sort(A,&#39;ComparisonMethod&#39;,&#39;abs&#39;) 按模对 A 的元素进行排序。 [B,I] = sort(___)还会为上述任意语法返回一个索引向量的集合。I 的大小与 A 的大小相同，它描述了 A 的元素沿已排序的维度在 B 中的排列情况。例如，如果 A 是一个向量，则 B = A(I)。- I是B对应的在未排序的矩阵(向量)中的下标 sort(c)从小到大 sort(c, &#39;descend&#39;)逆序排列(从大到小). 例题: 123456789101112A = [3 6 5; 7 -2 4; 1 0 -9]B = sort(A,2)A = 3×3 3 6 5 7 -2 4 1 0 -9B = 3×3 3 5 6 -2 4 7 -9 0 1 dim - 沿其运算的维度 正整数标量 沿其运算的维度，指定为正整数标量。如果未指定值，则默认值是大小不等于 1 的第一个数组维度。 假定有矩阵 A。sort(A,1) 对 A 的列元素进行排序。 sort(A,2) 对 A 的行元素进行排序。 注意如果a = 123,此时sort(a)没有作用，因为a是一个数，一个变量，不是集合！！排不了。就像对15这个数一样，sort是对2个及其以上元素排序 sort(a,1)把矩阵的每一列分别从小到大排成新的矩阵。 sort(a,2)把矩阵的每一行分别从小到大排成新的矩阵。 sort(a)默认的是sort(a,1)。 矩阵a是行矩阵时，sort(a)不再是sort(a,1),而转换为了sort(a,2)。 MATLAB判断一个数是否整数12345if x==fix(x)% x为整数%fix（x)为取整 end mod函数 b = mod(a,m)返回a除以m后的余数，其中a是被除数，m是除数。这个函数通常称为模运算，使用b = a - m.*floor(a /m)计算。mod函数遵循mod(a,0)返回a12345678910111213141516171819202122%栗子1clc,clear;a = [-4 -1 7 9];m = 3;b = mod(a,m)a%answerb = 2 2 1 0a = -4 -1 7 9%栗子2clc,clear;a = [1 2 3 4];m = 2;b = mod(a,m)c = ~mod(a,m) %转换为逻辑矩阵b = 1 0 1 0c = 0 1 0 1 常用函数 取整 fix:向零取整 ceil:向上取整 floor:向下取整 round:四舍五入 取余 rem:带符号 mod:不带符号 num2str,str2num,size,length max等函数的参数是矩阵时，是作用在矩阵各列上 find函数 注意matlab中find函数返回的是位置索引（向量，长度大于等于2说明重复出现） find()函数的基本功能是返回向量或者矩阵中不为0的元素x的位置索引。(从1开始)a = find(X) 返回前N个非零元素的位置find(A,X)与ind = find(X, k, &#39;first&#39;) 返回最后x个非零值的位置find(A,x,,&#39;last&#39;) 如果矩阵中没有该元素，返回值为一个空向量。 需要找到其中满足一定条件的元素a = find(x == 4) ，可以用一个表达式或多个表达式 文档 调用格式: k = find(X)返回一个包含数组 X 中每个非零元素的线性索引的向量。 如果 X 为向量，则 find 返回方向与 X 相同的向量。 如果 X 为多维数组（矩阵），则 find 返回由结果的线性索引组成的列向量。 如果 X 包含非零元素或为空，则 find 返回一个空数组。 k = find(X,n)返回与 X 中的非零元素对应的前 n 个索引。 k = find(X,n,direction)（其中 direction 为 ‘last’）查找与 X 中的非零元素对应的最后 n 个索引。direction 的默认值为 ‘first’，即查找与非零元素对应的前 n 个索引。 [row,col] = find(___)使用前面语法中的任何输入参数返回数组 X 中每个非零元素的行和列下标。 [row,col,v] = find(___)还返回包含 X 的非零元素的向量 v。（也就是返回你想找的值，如果不加表达式，条件默认是非零） row - 行下标，以向量的形式返回 col - 列下标，以向量的形式返回，如果 X 是多维数组且 N &gt; 2，则 col 是 X 的 N-1 尾部维度的线性索引。这会保留关系 X(row(i),col(i)) == v(i)。 find函数以列优先查找 假设要查找一个向量中小于 0 的所有元素但没有找到。find 函数将返回一个空的索引向量，表示未找到任何小于 0 的元素。 注意点以及搭配其它函数使用的小技巧 要直接查找 X 中满足条件 X &lt; 5 的元素，请使用 X(X &lt; 5)。尽量避免使用 X(find( X &lt; 5) ) 之类的函数调用，因为这种调用中对逻辑矩阵使用的 find 完全没有必要。 将 find 与 X&gt;1 之类的关系运算结合在一起执行时，必须记住关系运算的结果是由 1 和 0 组成的逻辑矩阵。例如，命令 [row,col,v] = find(X&gt;1) 会返回由 v 的逻辑值 1 (true) 组成的列向量。 假设矩阵为x，则最大值为max(max(x))。 所在位置为：[rows,cols]=find(x==max(max(x)))。蛮有用的 1234567891011121314151617clc,clear;x = [1 2 3 4 5 6];find(x &lt; 5)[rows,cols]=find(x==max(max(x)))%answerans = 1 2 4 5rows = 3cols = 2 len = length(find(X == k));是为了求得矩阵X中值为k的元素个数，等价于下面两种方法： len = length(X(X==k)); B = X==k; len=sum(sum(B));123456789101112131415161718192021clc,clear;b = [1 2 3 4 5 6 6 6];[r,c] = max(b)len1 = length(find(b == 6))len2 = length(b(b==6))a = b==6; len3=sum(sum(a))%answerr = 6 6c = 4 3len1 = 3len2 = 3len3 = 3 [row,col,v] = find(X, ...) 返回X中非零元素的一个列或行向量v，同时返回行和列的索引值。 如果X是一个逻辑表示，则v是一个逻辑矩阵。 输出向量v包含通过评估X表示得到的逻辑矩阵的非零元素。 记住，当你用find指令处理一个逻辑表达的时候，输出向量v不包含输入矩阵的非零元素的索引值。而是包含评估逻辑表达之后返回的非零值。123456789101112131415161718192021222324252627282930313233clc,clear;A= magic(4)[r,c,v]= find(A&gt;10);r cv%answerA = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1r = 1 2 4 4 1 3c = 1 2 2 3 4 4v = 1 1 1 1 1 1 栗子(有几种用法，注意一下)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132X = [1 0 2; 0 1 1; 0 0 4]%X = 3×3 1 0 2 0 1 1 0 0 4k = find(X)%k = 5×1 1 5 7 8 9%对 X 使用逻辑 not 运算符以查找零值。k2 = find(~X) %注意k2 = 4×1 2 3 4 6%在 4×4 幻方矩阵中查找前五个小于 10 的元素X = magic(4)%X = 4×4 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1k = find(X&lt;10,5) %注意可以用表达式！%k = 5×1 2 3 4 5 7%查看 X 的对应元素。X(k)%ans = 5×1 5 9 4 2 7%要查找特定的整数值，请使用 == 运算符。例如，在 1×10 的奇整数向量中查找等于 13 的元素。x = 1:2:20%x = 1×10 1 3 5 7 9 11 13 15 17 19k = find(x==13)%k = 7%要查找非整数值，请基于您的数据使用容差值。否则，由于浮点舍入误差有时会生成空矩阵。y = 0:0.1:1%y = 1×11 0 0.1000 0.2000 0.3000 0.4000 0.5000 0.6000 0.7000 0.8000 0.9000 1.0000k = find(y==0.3)%k = 1x0 empty double row vector%因为浮点数储存精度问题，跟c/c++类似k = find(abs(y-0.3) &lt; 0.001) %算法笔记也有类似%k = 4%在 4×4 矩阵中查找前 3 个大于 0 且小于 10 的元素。指定两个输出以便将行和列下标返回到这些元素。X = [18 3 1 11; 8 10 11 3; 9 14 6 1; 4 3 15 21]%X = 4×4 18 3 1 11 8 10 11 3 9 14 6 1 4 3 15 21[row,col] = find(X&gt;0 &amp; X&lt;10,3) %注意注意%row = 3×1 2 3 4%col = 3×1 1 1 1%第一个实例是 X(2,1)，即 8。%在 3×3 矩阵中查找非零元素。指定三个输出以返回行下标、列下标和元素值。X = [3 2 0; -5 0 7; 0 0 1]%X = 3×3 3 2 0 -5 0 7 0 0 1[row,col,v] = find(X)%row = 5×1 1 2 1 2 3%col = 5×1 1 1 2 3 3%v = 5×1 3 -5 2 7 1]]></content>
      <categories>
        <category>matlab</category>
        <category>矩阵以及常用函数</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab代码练习2018]]></title>
    <url>%2F2019%2F03%2F27%2Fmatlab%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A02018%2F</url>
    <content type="text"><![CDATA[A题 编程将输入的一个n位整数按由小到大的顺序输出。如输入78945，则输出45789。 123456789101112131415161718192021222324252627282930313233343536373839404142434445clc,clear;a = input('please input a number：');aa = num2str(a);b = length(aa);c = zeros(1,b);result = 0;for i=1:b d = mod(a,10); c(i) = d; a = (a-mod(a,10))/10;endc = sort(c);for j=1:b result = c(j) + result*10;endfprintf('The answer is :%d\n',result)%法二clc,clear;a = input('please input a number：');c=[];result = 0;b=0;while a&gt;0 d = mod(a,10); c = [c,d]; a = (a-mod(a,10))/10; b=b+1;endc = sort(c);for j=1:b result = c(j) + result*10;endfprintf('The answer is :%d\n',result)%法三clc,clear;a = input('a = ');b = num2str(a);c = length(b);d = [];for i = 1:c d(i) = str2num(b(i));endsort(d) 在同一坐标系中作出以下式子表示的图形x^2+y^2=1,y=x^2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 法一 clc,clear; close all; syms x f1 = 'x^2+y^2-1'; f2 = 'y-x^2'; ezplot(f1, [-1 1] , [-1 1]); hold on ezplot(f2, [-1 1] , [-1 1]); %法二 clc,clear; close all; x=-1:0.01:1; for i=1:length(x) y1(i)=sqrt(1-x(i)^2); y2(i)=-sqrt(1-x(i)^2); y3(i)=x(i)^2; end plot(x,y1,'b',x,y2,'b',x,y3,'b') %法三 clc,clear; close all; x=-1:0.01:1; y1=sqrt(1-x.^2); y2=-sqrt(1-x.^2); y3=x.^2; plot(x,y1,'b',x,y2,'b',x,y3,'b') ``` # C题- 第4题```matlab% 4、三对新人参加婚礼，其中新郎为A、B、C，新娘为X、Y、Z，某人不知道他们谁和谁结婚，于是分别问了其中的三位，得到如下回答：% A:我将和X结婚；% X:我将和C结婚；% C:我将和Z结婚。% 已知他们三人都在说谎，请编程找出谁将和谁结婚。（20分）%X-B C-Y A-Z%设A B C于其结婚对象分别设为1 2 3。clc,clear;A=1;B=2;C=3;for i=1:3 for j=1:3 for z=1:3 if i~=A&amp;&amp;i~=C&amp;&amp;z~=C&amp;&amp;i~=j&amp;&amp;i~=z&amp;&amp;j~=z X = i; Y = j; Z = z; break end end end endD=[X Y Z];d=['X' 'Y' 'Z'];m=find(D==A);n=find(D==B);v=find(D==C);fprintf('与A结婚的是%s\n',d(m))fprintf('与B结婚的是%s\n',d(n))fprintf('与C结婚的是%s\n',d(v)) 第五题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748% a = [17,8,11,22,3,27,4; % 41,3,19,5,13,11,7; % 8,14,21,18,14,16,23; % 31,22,4,25,9,15,17; % 13,24,21,6,17,22,31; % 11,2,34,15,22,4,13; % 16,3,7,19,13,27,21;]; % （1）求这个矩阵四周元素的均值，并将它们删除。（10分） % （2）重复（1）的操作直到只剩下一个元素。（20分） %第二问 %% %先保存函数再调用主函数 function b=myfunction(a) [m,n]=size(a); b=a(2:m-1,2:n-1); end %% %主函数 clc,clear; a = [17,8,11,22,3,27,4; 41,3,19,5,13,11,7; 8,14,21,18,14,16,23; 31,22,4,25,9,15,17; 13,24,21,6,17,22,31; 11,2,34,15,22,4,13; 16,3,7,19,13,27,21;]; c=length(a); while c~=1 a=myfunction(a); c=length(a); end fprintf('the answer is %d\n',a) %法二 clc,clear; a = [17,8,11,22,3,27,4; 41,3,19,5,13,11,7; 8,14,21,18,14,16,23; 31,22,4,25,9,15,17; 13,24,21,6,17,22,31; 11,2,34,15,22,4,13; 16,3,7,19,13,27,21;]; c=length(a); while c~=1 [m,n]=size(a); a=a(2:m-1,2:n-1); c=length(a); end fprintf('the answer is %d\n',a)]]></content>
      <categories>
        <category>matlab</category>
        <category>代码练习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo特殊字符]]></title>
    <url>%2F2019%2F03%2F22%2Fhexo%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[因为特殊字符，报了一下错误1234FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 5, Column 29] 从宇宙大爆发开始找错误，不过还好没浪费多少时间.记忆深刻，写个blog冷静一下 特殊字符 hexo特殊字符尽量减少使用，可能在转义时发生错误！如： 2个大括号连在一起！！！！！！！！！！！！！或者中括号！！]]></content>
      <categories>
        <category>blog</category>
        <category>特殊字符</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[二维数组 二维数组的初始化分为两种，一种是顺序初始化，一种是按行初始化 所谓按顺序初始化就是先从左向右再由上而下地初始化，即第一行所有元素都初始化好以后再对第二行初始化。而按行初始化则是用一对大括号来表示每一行，跳过前一行没有初始化的元素，在行内从左向右地进行初始化。 int array1[3][2]={4,2,5,6}; 顺序初始化 int array2[3][2]={ {4,2},{5},{6} }; 按行初始化 对于没有初始化的元素，则都是一个不确定的值。 内存是依靠地址来确定内存中的唯一一个存储单元的，即只有一个参数。所以在内存中，所有的数据都是像一维数组那样顺序存储的。 在内存中，先将二维数组的第一行按顺序存储，接着就是第二行的数据，然后是第三行的数据……右图（图7.4）所示的就是一个二维数组在内存中的存储情况。 在某些情况下，不能使用二维数组，或者难以制造一个二维数组。二维数组在内存中的存储情况和一维数组是相同的，所以我们只好用一个一维数组来代替它了。一个二维数组元素a[x][y]在一维数组b中，是： a[x][y]=b[x*列数+y] (未检查)主函数中没有初始化的元素一般为随机值，那个如果有初始化列表的话，后面默认还是零吗，对于二维数组来应该是的，在局部函数中，只要数组（一维或二维）带有任何的（即使是不完全的）初始化列表，数组就不会再是处于脏数据的状态，而是把其他未初始化的位置全部初始化为0. 但是在全局变量或static静态变量时，就不管有没有初始化列表，全部默认初始化为0. 一维数组 静态数组int array[100] = {0};定义了数组array，并将数组元素全部初始化为0； 静态数组int array[100] = {1};//定义了数组array，并将数组第一个元素初始化为1，后面99个元素初始化为0； 静态数组int array[100] = {4,5}; 定义数组array，并初始化前两个元素为4,5，后面剩余元素初始化为0； 动态数组int *p_array = new int[100]; delete []p_array; 分配了长度为100的数组array，并全部初始化为0； 动态数组int *p_array = new int[100]{3,5}; delete []p_array; 前两个元素初始化为3和5，后面的原始初始化为0]]></content>
      <categories>
        <category>c++</category>
        <category>基础知识</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dfs与bfs]]></title>
    <url>%2F2019%2F03%2F20%2Fdfs%E4%B8%8Ebfs%2F</url>
    <content type="text"><![CDATA[dfs模板 DFS的重要点在于状态回溯 判出口（终点、越界）-&gt; 剪枝-&gt;扩展-&gt;标记-&gt;递归-&gt;还原1234567891011121314151617181920212223void dfs()//参数用来表示状态 &#123; if(到达终点状态)&#123; ...//根据题意添加 return; &#125; if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式)&#123; if(扩展方式所达到状态合法)&#123; 修改操作;//根据题意来添加 标记； //标记可以再开一个另外的数组进行标记 dfs（）； (还原标记)； //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 &#125; &#125; &#125; 小技巧 如何获得下一个方向的坐标（此处定义一个方向数组）。 123456789101112int next[4][2]=&#123; &#123;0, 1&#125;//向右走 &#123;1, 0&#125;//向下走 &#123;0, -1&#125;//向左走 &#123;-1, 0&#125;//向上走 &#125;; next[i][0]; //x方向 next[i][1]; //y方向 int dir[4][2]= &#123;0,1,1,0,0,-1,-1,0&#125;; dir[i][0]; //x方向 dir[i][1]; //y方向 通过这个方向数组，使用循环就可以方便地得到下一步的坐标。 1234567891011121314151617181920212223int map[6][6];//地图；bool temp[6][6];//走过的标记；int dx[4]=&#123;0,0,1,-1&#125;;//打表；int dy[4]=&#123;-1,1,0,0&#125;;//打表；void walk(int x,int y)&#123;//定义walk if(x==fx&amp;&amp;y==fy)//fx表示结束x坐标，fy表示结束y坐标； &#123; total++;//总数增加； return;//返回，继续搜索； &#125; else&#123; for(int i=0;i&lt;=3;i++)//0——3是左，右，下，上四个方向； &#123; if(temp[x+dx[i]][y+dy[i]]==0&amp;&amp;map[x+dx[i]][y+dy[i]]==1)//判断没有走过和没有障碍； &#123; temp[x][y]=1;//走过的地方打上标记； walk(x+dx[i],y+dy[i]);//同i!!!! temp[x][y]=0;//还原状态； &#125; &#125; &#125;&#125; 就在地图map数组上打标记（自己走过的路）比较简单，走过的路和障碍可能引起混淆 用方向-1.0.1等表示方向的数字作为for循环解决搜索方向问题可能更好 题目 典型题一：123456789101112131415161718年秋第13周任务-地主分财产时间限制：2秒 内存限制：128兆55 次提交 1 次通过题目描述 一位老财主在临终之前想把自己的财产-一箱金条分给四个儿子，为了不引起兄弟之间的矛盾，他想把这箱金条平均分给四个儿子，但是麻烦的是，这箱金条有长有短(但是粗细一样且质地均匀)，现在他想知道这箱金条能不能均分成四份（不能将金条裁断），这对于他来说太难了。那么，你能解决这个问题吗？输入第一行输入一个整数m&lt;1000, 表示测试用例个数，以下的行是m个测试用例.每个测试用例的第一个数是金条根数n(4 &lt;= n &lt;= 20)，表示金条的根数,接下来的n个整数p1,p2,...,pn，pi为每一根金条的长度,0 &lt;= pi &lt;= 10000。输出输出m行，每一行对应每个测试用例，如果这些金条能够均分，则输出"YES",否则输出"NO".样例输入26 2 3 5 5 1 45 12 30 40 20 50样例输出YESNO 典型题二:1234567891011121314151617181920212223242526272818年秋第13周任务-交友大作战时间限制：1秒 内存限制：128兆14 次提交 7 次通过题目描述 Crw出生在魔仙堡，里面住着很多善良美丽的小魔仙，同时也住着一些想破坏魔仙堡的黑魔仙，Crw很想和善良的小魔仙们交朋友，有一天他决定从家出发出门去看看，于是他偷偷从家里找到一份魔仙堡的地图。地图上标注了一些魔仙的禁地和一些城堡。而且会标注出哪些住的是善良的小魔仙，哪些住的是邪恶的黑魔仙。现在我们Crw每天会到一个城堡中做客并和住在城堡里的所有小魔仙成为朋友，并且下一天能够到相邻的城堡中做客，但是他不能走到黑魔仙的城堡。同时不能走进魔仙堡的禁地。我们知道Crw想和尽可能多的小魔仙成为朋友，那么你能帮他求出他最多能和多少个小魔仙成为朋友吗？输入输入数据有多行，每行输入两个整数n和m，分别代表魔仙堡的地图的长和宽。接下来输入的是一个m x n的矩阵代表魔仙堡的地图。其中‘@’代表Crw的家，数字‘1-9’代表该处城堡里住着对应数字的小魔仙，‘#’代表城堡里住着的是黑魔仙，‘*’代表该处是魔仙堡的禁地。最后用0 0结束输入。输出结果输出一个数字，代表Crw最多能交到朋友的数量。样例输入5 3@12*3456**7#8#911 91#1111111111#1#######11#1#11111#11#1#1###1#11#1#11@#1#11#1#####1#11#1111111#11#########1111111111110 0样例输出3358 典序例题三:1234567891011121314151617第14周任务-dfs&amp;bfs训练(一)时间限制：1秒 内存限制：128兆54 次提交 8 次通过题目描述没时间编故事了，直接做题吧！问题很简单，现在有两个数n和m，我们有三种操作-1，+1，*2。问：最少需要操作多少次能把n变成m。（0&lt;=n,m&lt;=1000000）输入输入数据有多组，每行输入两个整数n和m输出每行输出一个数字代表最少操作次数样例输入5 17样例输出4题目分析：本题分析和思路参照我上周在群里发的周任务提示。通常我们在广搜中需要用到的队列，我们都用c++stl中现有的队列，并且需要引入头文件#include&lt;queue&gt;定义方式如下：queue&lt;datetype&gt; queue_name; 四1234567891011121314151617181920第14周任务-dfs&amp;bfs训练(二)时间限制：3秒 内存限制：128兆21 次提交 7 次通过题目描述我们来做一个经典问题：n皇后问题N皇后问题是指在一个N*N的棋盘上，放置N个皇后： 1、每行至多一个 2、每列至多一个 3、对角线方位上，不能有其他皇后问题是最多有多少种放置方案。输入每行输入一个正整数n，代表需要放置的皇后个数。输出每行输出一个整数，代表最大放置方案数样例输入8样例输出92题目分析：本题分析参照周任务提示，需要注意这里标记数组的用法，节约了遍历检查的时间开销。 地图123456789101112131415161718192021222324252627282930313233343536第14周任务-dfs&amp;bfs训练(三)时间限制：1秒 内存限制：128兆30 次提交 4 次通过Crw家住在魔仙堡我们都已经知道了，他喜欢和小魔仙交朋友我们也知道了。那么现在他膨胀了，他觉得魔仙堡的小姐姐已经满足不了他了，所以他决定出去看看。我们之前知道的魔仙堡有一张地图，标明了魔仙堡的地理情况，但实际上魔仙堡存在很多维度，每一个维度都是平行而且大小相同的，我们不光能在一同平面内移动，还能在上下空间中传送，不同维度的空间坐标是完全一一对应的，因此只能传送到相邻维度空间中相同的坐标处。现在我们知道魔仙堡的出口就在某一维的空间之中，但是Crw很迫切，每一秒他能向前后左右上下六个方向移动一个坐标，他想知道他最快多少秒就能走出魔仙堡。那么请你来帮他解决这个问题吧。输入有多组数据，每组数据第一行有三个正整数k，n，m。k代表魔仙堡的维度，n和m代表魔仙堡每个维度是一个n x m大小的平面。接下来输入k个n x m的矩阵，每个矩阵用一个空行隔开，代表每个平面的地图。其中‘S’代表Crw的家，‘E’代表魔仙堡的出口，‘.’代表可以移动的空地，‘#’代表不能移动到的危险位置。最后用三个0代表停止输入。输出每组数据输出一个数字，代表Crw最快逃离魔仙堡的时间。如果无法找到出口则输出-1。样例输入3 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0样例输出11-1题目分析：简单三维地图的搜索 人参果1234567891011121314151617181920212223第14周任务-dfs&amp;bfs训练(四)时间限制：1秒 内存限制：128兆7 次提交 1 次通过题目描述传说在三大有一颗神奇的人参果树，一年结一次果，它总共n个节点，第一个节点是他的树根，其他节点都在树的上端。除了根节点，每个节点i(i&gt;1)下面都连接有一个pi( pi &lt; i )节点，这颗树很神奇，每年到了结果的时候，每个节点会同时结下一个人参果。然后成熟了开始掉落，但他不会像牛顿的苹果树那样自由掉落，而是每一秒钟下滚到它的连接着的下一个靠近树根的节点。直到滚到树根为止。但是我们知道牛x的东西都是脾气很大的，如果我们在同一节点同时滚落了多个人参果，那么他们会两两消亡。所以我们的问题是最后我们在根节点处能收到多少个人参果。输入第一行输入一个正整数n，代表树总共的节点个数（1&lt;=n&lt;=100000）。第二行输入n-1个数pi（2&lt;=i&lt;=n）,分别代表第i个节点连接的是第pi个节点，即人参果滚落的下一个节点。输出输出一个数字代表最后在根节点能够收到的人参果个数。样例输入51 2 2 2样例输出3提示比如样例中有5个节点，根节点是1号，下面四个数字分别代表2号节点连接的是1号，3,4,5号节点连接的都是2号。最后能过收获1号节点的一个人参果，然后下一秒2号节点的人参果掉落到1号再次收获一个，同时，3,4,5号节点的人参果同时滚落到2号会抵消掉2个，剩下一个最后滚落到1号节点被收获，所以结果是3个问题分析：本题和本周周任务中涉及到的二叉树有些联系，本题也可以模拟成一个树，但不是一颗二叉树，而是一个普通的树，每个节点连接着零个或多个子节点，每个节点上结一个果实。同时向下滚落。如果我们用树的遍历的方式去暴力模拟每一种情况，看最后剩余的果实个数肯定会超时。所以我们需要找规律，很明显我们发现无论有多少个节点，每一层最多剩下一个或零个果实。我们把根节点当做第一层，也就是深度为1，与根节点直接相连的节点为第二层，依次类推，每一层节点的个数为偶数时，则所有的果实都相互抵消，节点个数为奇数则剩余一个。因此我们用dfs搜索每一层（深度相同）的节点个数，并统计下来。最后求出每层剩余果实之和即为最后根节点剩余果实数目。注意：这里我用到vector，同样是c++stl当中的一种数据结构，我们通常在算法当中常用到vector来表示树和图这些数据结构。这里也可以用结构体替代，后面会向大家介绍c++stl中一些常用的数据结构的用法。]]></content>
      <categories>
        <category>算法</category>
        <category>dfs与bfs</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab基本操作]]></title>
    <url>%2F2019%2F03%2F17%2Fmatlab%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[matlab语句 MATLAB语句的一般形式为：变量 = 表达式说明： 1.若变量和“=”省略，则名为ans的变量自动建立； 2.如果你输入了一个语句并以回车结束，则在工作区中显示计算的结果； 3.如果语句以分号“；”结束，MATLAB只进行计算，不显示计算的结果； 4.如果一个变大时太长，可以用续行号 … 将其延续到下一行。此外，一行中可以写几个语句，他们之间要用逗号或分号分开。 matlabz中变量 对于变量，MATLAB不需要任何类型的说明或维数语句。当输入一个新变量名时MATLAB自动建立面变量并为其分配内存空间。 MATLAB有几个特殊的量 1.Pi圆周率π 2.Eps最小浮点数 3.Inf正无穷大，特指1/0 4.NaN不定值，特指0/0 5.i，j虚数单位 6.自然对数 MATLAB中变量的命名规则是： 变量名必须是不含空格的单个词； 变量名区分大小写； 变量名最多不超过19个字符； 变量名必须以字母打头，之后可以是 任意字母、数字或下划线，变量名中，不允许使用标点符号. matalab中Π默认为3.1416（应该） 数据显示默认为四位，但只是matlab对数据的显示方式，其实不管显示的有效位数是多少，都不影响实际的计算结果，也不会有多大的累计误差。有效位数是4或8位，其计算结果的误差是一样的。 matlab运算符 A*B A与B相乘 A.*B A与B相应元素相乘（A、B为同纬度的矩阵） A/B A与B相除（A、B为数值或矩阵） 注意跟c/c++中不同，matlab中除法后可为小数，不一定就是整数 A./B A与B相应元素相除（A、B为同纬度的矩阵 A^BA的B次幂（A、B为数值） A.^BA的每个元素的B次幂（A、B为同纬度的矩阵） 幂方在矩阵之间只能点乘。 符号 分号 ; 表示分隔不想显示计算结果的各语句；矩阵行与行的分隔符 续行号 … 长命令行需分行时连接下行用 逗号 ， 表示分隔欲显示计算结果的各语句；变量分隔符；矩阵一行中各元素间的分隔符 matlab中用~代替！matlab输入 函数： a=input(‘please input a number：’); b=input(‘请输入一个字符串:’,’s’); c=input(‘请输入一个矩阵:’); 赋值：a=3;A=4;(变量赋予数值) ` a=A;(变量赋予变量)` ` a=‘a’;(变量赋予字符串)` ` a=zeros(m,n);a=ones(m,n);(变量赋予矩阵)` matlab输出 不加分号：a=3 a=b a=‘a’ a=zeros(m,n) 函数1：fprintf()` fprintf(fid,format,A)` fid：输出的位置，如果缺省，则输出在命令窗口 format：输出内容的类型（类型包括：%d:整数 %e:实数 %s:字符串 %f:浮点数） A：输入内容的变量名 fprintf(&#39;&#39;)是必须写的，真正输出的语句在单引号中间。 屏幕输出简单的方法是直接写出欲输出的变量或数组名，后面不加分号。此外，可 以采用 disp 语句，其调用格式为 disp(x)。 函数二：disp() disp(‘A’); disp(‘numstr(12)’) ;%%numstr()是将其他类型的变量转化成字符串的形式 disp(zeros(m,n)); 123456clc,clear;result = 0;for i=3:2:101 result = result + i;enddisp(result) MATLAB的每条命令后，若为逗号或无标点符号， 则显示命令的结果；若命令后为分号，则禁止显示结果. “%” 后面所有文字为注释. “…”表示续行. mat文件 mat文件是matlab的数据存储的标准格式。mat文件是标准的二进制文件,还可以ASCII码形式保存和加载，在MATLAB中打开显示类似于单行EXCEL表格。 MATLAB是解释型语言，就是说MATLAB命令行中敲入的命令在当前MATLAB进程中被解释运行。但是，每次执行一个任务时敲入长长的命令序列是很烦人的。有两种方法可以使MATLAB的力量得到扩展——脚本和函数。这两种方法都用像emacs一样的文本编辑器中编写的m文件（因为扩展名是.m所以这样命名，m文件还称点m文件）。m文件的好处在于它可以保存命令，还可以轻易地修改命令而无需重新敲入整个命令行。 所谓mat文件，就是由matlab语言编写的可在matlab语言环境下运行的程序源代码文件。Matlab语言的m文件可分为命令式和函数式两种形式。M文件可在matlab程序编辑器里编写，也可在其他文本编辑器中编写，并以”.m”为拓展名保存。 循环for循环 for 循环允许一组命令以固定的和预定的次数重复。for 循环的一般形式是 123for 循环控制变量=表达式 1:表达式 2:表达式 3 语句 end 表达式 1 的值为循环控制变量的初值；表达式 2 的值为步长，每执行循环体一次，循 环控制变量的值将增加步长大小。步长可以为负值，当步长为 1 时，表达式 2 可省略；表 达式 3 为循环控制变量的终值，当循环控制变量的值大于终值时循环结束。在 for 循环中， 循环体内不能出现对循环控制变量的重新设置，否则将会出错；for 循环允许嵌套使用。 initval:endvalincrements the index variable from initval to endval by 1, and repeats execution of program statements until index is greater than endval. 当条件为i == endval时，会执行一遍循环体再结束循环，与c++/c不同 使用 for 循环语句值得注意的是 for循环不能用循环内重新给循环变量赋值来终止 12345678 x=0;for n=1:4 x =x+1 n=5;end - for 循环的循环变量= [表达式 1:表达式 2:表达式 3]，其实为一行向量，例如： `[1:2:10]=[ 0 2 4 6 8 10]`，它还可以是数组，其更一般的形式为 `for 循环控制变量 = 数组表达式 语句 end ` - 【例 6.5】 用 for 循环求行向量[-2,5,3,6,-2]各元素之和。 1234567891011121314151617181920 a=[-2,5,3,6,-2]; s=0;k=0;for n=a n %显示每一次循环变量的值 k=k+1; %记录循环次数 s=s+n; %计算行向量 a 各元素之和 end k,s %显示总的循环次数和计算结果运行结果为 n = -2 n = 5 n = 3 n = 6 n = -2 k = 5 s = 10 可以看出，总循环次数为 5，第 i 次循环时循环变量的值为 a(i)，计算结果为行向量 a 各元素之和。 - 当有一个等效的数组方法来解给定的问题时，应避免用 for 循环。 - 【例 6.9】 比较下面两段程序的执行情况。 1234567891011 (a) for n=1:10 x(n)=sin(n*pi/10); end x (b) n=1:10; x=sin(n*pi/10) 两段程序的运行结果相同，均为 x = 0.3090 0.5878 0.8090 0.9511 1.0000 0.9511 0.8090 0.5878 0.3090 0.0000 但后者执行更快，更直观、简便。 为了得到更快的速度，在 for 循环(while 循环)被执行之前，应预先分配数组。如例 6.9(a)，在 for 循环内每执行一次命令，变量 x 的大小增加 1，迫使 MATLAB 每进行一次循 环都要花费时间对 x 分配更多的内存。为了省去这个步骤，可以在例 6.9(a)程序的首行加入：x=zeros(1,10); %为 x 分配内存单元 while循环 其一般形式为 123456789101112131415161718192021222324252627282930313233 while 关系表达式 语句 end ``` - 注意：for 循环的循环变量为 m1× m 2×…× m n 维数组，循环次数在一开始就由数组确定为 m2×…× m n，所以在循环体内并不能通过改变循环控制变量的值终止循环；而 while 循环是先执行循环体内的语句，再判断循环的条件是否成立，在循环体内可以通过 改变循环控制变量的值终止循环。# 判断- try 语句 - try 语句是 MATLAB 特有的语句，其一般结构是 ``` try 语句 1 catch 语句 2 end``` - elseif与else if不同，前者嵌套if语句时不用end，后者要与else if对应的end- elseif:不需要end结束- else if:需要end结束- if, elseif, else if expression statements elseif expression statements else statements end `]]></content>
      <categories>
        <category>matlab</category>
        <category>基础</category>
        <category>基本操作</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快排及其优化]]></title>
    <url>%2F2019%2F03%2F15%2F%E5%BF%AB%E6%8E%92%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[快排 写快排以 a[1] 为基准点太易被卡，可以用 a[(L+r)/2]. STL 的快排算法的实现其实加入了小数组时冒泡，可能慢的时候用堆排等等优化]]></content>
      <categories>
        <category>算法</category>
        <category>快排及其优化</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学秘密]]></title>
    <url>%2F2019%2F03%2F15%2F%E6%95%B0%E5%AD%A6%E7%A7%98%E5%AF%86%2F</url>
    <content type="text"><![CDATA[最大公约数 在解有关最大公约数、最小公倍数的问题时，常用到以下结论 如果两个自然数是互质数，那么它们的最大公约数是1，最小公倍数是这两个数的乘积。 例如8和9，它们是互质数，所以（8，9）=1，[8，9]=72。 2）如果两个自然数中，较大数是较小数的倍数，那么较小数就是这两个数的最大公约数，较大数就是这两个数的最小公倍数。 例如18与3，18÷3=6，所以（18，3）=3，[18，3]=18。 （3）两个整数分别除以它们的最大公约数，所得的商是互质数。 例如8和14分别除以它们的最大公约数2，所得的商分别为4和7，那么4和7是互质数。 （4）两个自然数的最大公约数与它们的最小公倍数的乘积等于这两个数的乘积。 例如12和16，（12，16）=4，[12，16]=48，有4×48=12×16，即（12，16）× [12，16]=12×16。 （5）GCD(a,b) is the smallest positive linear combination of a and b. a与b的最大公约数是最小的a与b的正线性组合,即对于方程xa+yb=c来说,若x,a,y,b都为整数,那么c的最小正根为gcd(a,b).]]></content>
      <categories>
        <category>数学基础知识</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[merge函数]]></title>
    <url>%2F2019%2F03%2F13%2Fmerge%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[merge函数 merge函数的作用是：将两个有序的序列合并为一个有序的序列。 合并操作会合并两个有相同顺序的序列中的元素，可以是两个升序序列，也可以是两个降序序列。结果会产生一个包含来自这两个输入序列的元素副本的序列，并且排序方式和原始序列相同 merge() 算法会合并两个序列并将结果保存到第三个序列中，它使用 &lt; 运算符来比较元素。图 1 表明合并操作被运用到 these 和 those 容器的内容上，结果序列保存在 both 容器中。 merge() 算法需要 5 个参数。其中前两个指定第一个输入序列的迭代器，在这个示例中是 these，后面两个迭代器指定第二个输入序列，在这个示例中是 those，最后一个参数是一个指定合并元素存放位置的迭代器，即 both 容器。用来指定输入序列的迭代器只需要是最低层次的迭代器，用来保存合并结果的迭代器需要是一个输出迭代器。 当需要使用不同于 &lt; 运算符的其他比较运算时，可以提供一个函数对象用来作为第 6 个参数。 merge() 算法并没有关于被合并序列容器的信息，所以它们不能创建元素，只能用提供的作为第 5 个参数的迭代器来保存元素。因而在这个示例中，目的序列中的元素必须是已经存在的。在图 1 中，通过以两个输入容器元素个数之和为指定的元素个数创建一个 both 容器来保证此要求。创建的结果序列可以放在任何位置，甚至可以放在一个源序列容器中，但源序列和目的序列不能重叠；如果它们重叠了，结果是未定义的，但可以肯定的是效果肯定不好。当然，可以用一个插入迭代器来指定目的位置，元素会被自动创建。 返回值指向最后复制元素后一元素的迭代器。merge() 算法返回的迭代器指向合并序列末尾的后一个位置，所以可以通过这个函数调用使用的第 5 个参数加上这个函数返回的迭代器来确定合并序列的范围。 源码1.123456template&lt; class InputIt1, class InputIt2, class OutputIt, class Compare&gt;constexpr OutputIt merge( InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp ); 12345678910111213141516171819202122template&lt;class InputIt1, class InputIt2, class OutputIt&gt;OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first)&#123; for (; first1 != last1; ++d_first) &#123; if (first2 == last2) &#123; return std::copy(first1, last1, d_first); &#125; if (*first2 &lt; *first1) &#123; *d_first = *first2; ++first2; &#125; else &#123; *d_first = *first1; ++first1; &#125; &#125; return std::copy(first2, last2, d_first);&#125; 2. 12345678template&lt; class InputIt1, class InputIt2, class OutputIt &gt;constexpr OutputIt merge( InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first ); 1234567891011121314151617181920212223template&lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt;OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp)&#123; for (; first1 != last1; ++d_first) &#123; if (first2 == last2) &#123; return std::copy(first1, last1, d_first); &#125; if (comp(*first2, *first1)) &#123; *d_first = *first2; ++first2; &#125; else &#123; *d_first = *first1; ++first1; &#125; &#125; return std::copy(first2, last2, d_first);&#125; 归并二个已排序范围 [first1, last1) 和 [first2, last2) 到始于 d_first 的一个已排序范围中。 用 operator&lt; 比较元素。 用给定的二元比较函数 comp 比较元素。 first1, last1 要归并的元素的第一范围 first2, last2 要归并到元素的第二范围 d_first 目标范围的起始 类型要求-InputIt1, InputIt2 必须满足 LegacyInputIterator 的要求。-ForwardIt1, ForwardIt2, ForwardIt3 必须满足 LegacyForwardIterator 的要求。-OutputIt 必须满足 LegacyOutputIterator 的要求。 vector合并 merge第五个参数即用来存储的第三个vector大小必须预先确定，虽然用vec.begin();可以指向首地址，但是无存储空间 自己代码 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt; using namespace std;int main()&#123; vector&lt;int&gt; a, b; vector&lt;int&gt; c(100); int n, m, i = 0, j[100]; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; j[i], a.push_back(j[i]); i = 0; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++) cin &gt;&gt; j[i], b.push_back(j[i]); merge(a.begin(), a.end(), b.begin(), b.end(), c.begin()); for(i = 0; i &lt; a.size()+b.size(); i++) cout &lt;&lt; c[i] &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
        <category>merge</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dev的秘密]]></title>
    <url>%2F2019%2F03%2F11%2FDev%E7%9A%84%E7%A7%98%E5%AF%86%2F</url>
    <content type="text"><![CDATA[dev快捷键 在工具-&gt;快捷键设置 中可以设置自己习惯使用的快捷键，下面给出几种常用的快捷键，均为系统默认的。 【Ctrl+w】查看变量 【Ctrl+.】注释 【Ctrl+M】取消注释 按下Ctrl+Shift+A，会看到DEV帮你整理好了代码。 Ctrl + shift + 方向键上或下会选中光标当前所在的行，然后将这个行进行上移或下移，移动操作不会覆盖上下相邻的行，只是将位置进行对调。（eclipse则是在嵌套的方法之间做跳转，VS2013没有效果） debug时添加查看不用输入，只要左键选中变量，然后点击添加即可（偶然发现，惊喜不已） 或者直接鼠标左键双击选中 调试的时候换行如果是endl会无法继续进行，此时换行应使用”\n” endl的作用为Insert newline and flush. Its behavior is equivalent to calling os.put(‘\n’) (or os.put(os.widen(‘\n’)) for character types other than char), and then os.flush(). Inserts a newline character into the output sequence os and flushes it as if by calling os.put(os.widen(‘\n’)) followed by os.flush(). 代码补全功能(智能提示) Dev-C++具有代码补全功能，它可以根据程序上下提示所有可能的指令，从而提高编程效率。 开启方法：工具-&gt;编辑器选项 在 “浏览类” 下的“代码补全”面板中勾选“允许代码补全”，并设置延时时间。在你设定的延时时间后，编辑器会自动激活代码补全功能。此外，在编辑器中按【Ctrl+空格】可以随时激活代码补全功能。另：当不确定一对括号的作用范围时，可以按【Ctrl+Shift+空格】 -wall -wall 可以在编译时显示最多警告信息，帮助大家查错 打开方式：工具 –&gt; 编译选项 –&gt; 代码生成优化 –&gt; 代码警告 –&gt; 显示最多警告信息 –&gt; 改为Yes debug与release Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。 使用Dev-C++查看vector数组中的变量值 可以通过调试的时候添加查看：比如说有一个长度为3的vector v，如果想要查看v[0]的值，就在添加查看中写 *(&amp;v[0]) 好像先要在dev编译器里面引入c++11标准，-std=c++11 如果想要查看整个数组的值，就可以写*(&amp;v[0])@3 @后面的数字表示想要查看的长度，这里vector的长度是3所以可以写3就能看到所有的值 通过鼠标查看变量 把鼠标划过代码中想查看的变量就可以在左边调试一栏中查询该变量的当前值。 点击菜单栏中的工具[T]，选择环境选项[v] 找到【浏览Debug变量】，选中【查看鼠标指向的变量】，然后点击下方的确定即可。]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器]]></title>
    <url>%2F2019%2F03%2F11%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在STL定义的容器中，string，vector与deque提供了随机访问迭代器，list、set、multiset、map、multimap提供了双向迭代器。 能进行算术运算的迭代器只有随即访问迭代器，要求容器元素存储在连续内存空间里，vector，string，deque的迭代器是有加减法的，但是map，set，multimap,multiset的迭代器是没有加减法的，list也不可以,map等的迭代器不支持加减操作，仅有++itr，–itr这些操作来进行选择 Bidirectional迭代器：是在前向迭代器的基础上，多了单步向后遍历的能力。也就是–iter,iter–。 Random Access迭代器：在双向迭代器基础上，具有直接访问各数据元素的能力。随机迭代器增加了“迭代器算术运算”： 所有迭代器都应该实现自增算符：iter++,++iter STL 中的容器适配器有 stack、queue、priority_queue 三种。它们都是在顺序容器的基础上实现的，屏蔽了顺序容器的一部分功能，突出或增加了另外一些功能。容器适配器是没有迭代器的，因此 STL 中的各种排序、查找、变序等算法都不适用于容器适配器。]]></content>
      <categories>
        <category>stl</category>
        <category>迭代器</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string]]></title>
    <url>%2F2019%2F03%2F10%2Fstring%2F</url>
    <content type="text"><![CDATA[string12345678string a, b;.....a = a + b;//将a+b前后连接，对于string来说有些符号重载定义// ‘ + ’暂且理解为前后连接，所以前后不同，结果不同//string作为容器，可以和字符串、字符相加，也可以和string相加//连接的话 s += a; 这个是把往后面连接，s = a + s;这是是把字符串a连接到s的前面//具体原因不知道//待续 string是类，与c中字符串不一样,string a =&quot;hello&quot;+&quot;world&quot;;错误，因为两个字符串都不是string类 string 的末尾没有&#39;\0&#39;字符，所以length()返回的是字符串的真实长度，而不是长度 +1。 string 字符串的起始下标仍是从 0 开始。 有了 string 类，我们可以使用+或+=运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的 strcat()、strcpy()、malloc() 等函数来拼接字符串了，再也不用担心空间不够会溢出了。 用+来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个字符数组，或者是一个 string 字符串和一个单独的字符。 string a;变量 a 只是定义但没有初始化，编译器会将默认值赋给 a，默认值是” “，也即空字符串。 std::string 不可以与null相比较，可以与” “比较，判空a.empty()函数，a.length() == 0 使用C语言中的 fopen() 函数打开文件，必须将 string 字符串转换为C风格的字符串。输入用scanf1234567string a;a.resize(100); //需要预先分配空间//scanf是标准输入流，没有缓存区，需要预先分配空间，而cin是输入流，它使用了缓冲区。如果要使用scanf读入字符串，那就一定要事先为它申请足够的内存空间scanf("%s", &amp;a[0]);// 输入数据中，超出指定个数的部分会被自动裁去。printf("%s\n", a.c_str());return 0; 标题没想好 printf只能输出C语言内置的数据，而string不是内置的，只是一个扩展的类，这样肯定是链接错误的。 12345678910//printf输出string类型应如此操作！#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void main()&#123;string s="qqq";printf("%s", s.c_str()); //不推荐//或者cout&lt;&lt;a；&#125; c_str该函数能够将 string 字符串转换为C风格的字符串，并返回该字符串的 const 指针(const char*),可读不可改的指向字符数组的指针，不需要手动释放或删除这个指针 c_str()：生成一个const char*指针，指向以空字符终止的数组。这个数组的数据是临时的，当有一个改变这些数据的成员函数被调用后，其中的数据就会失效。因此要么现用先转换，要么把它的数据复制到用户自己可以管理的内存中。看下例： 12345678910111213141516171819const char* c;string s="1234";c = s.c_str(); cout&lt;&lt;c&lt;&lt;endl; //输出：1234s="abcd";cout&lt;&lt;c&lt;&lt;endl; //输出：abcd//const char* c; //①//char* c; //②//char c[20]; char* c=new char[20];string s="1234";//c = s.c_str(); strcpy(c,s.c_str());cout&lt;&lt;c&lt;&lt;endl; //输出：1234s="abcd";cout&lt;&lt;c&lt;&lt;endl; //输出：1234//注意：不能再像上面一样①所示了，const还怎么向里面写入值啊；也不能②所示，使用了未初始化的局部变量“c”，运行会出错的 。 在C语言中只有char 和 const char，为了使用起来方便，string提供了三个函数满足其要求： const charT* c_str() const const charT* data() const size_type copy(charT* buf, size_type n, size_type pos = 0) 其中： c_str 直接返回一个以/0结尾的字符串。 大小为size()+1. data 直接以数组方式返回string的内容，其大小为size()的返回值，结尾并没有/0字符。 copy 把string的内容拷贝到buf空间中。 string的c_str()函数是用来得到C语言风格的字符串，其返回的指针不能修改其空间。而且在下一次使用时重新调用获得新的指针。 string的data()函数返回的字符串指针不会以’/0’结束，千万不可忽视。 一定要使用strcpy()函数 等来操作方法c_str()返回的指针。c_str()返回的是字符串的首地址,返回值类型是const char *的.如果要使用它并对其进行赋值操作,必须要使用strcpy函数.c_str()返回的是一个临时指针，不能对其进行操作。123char c[20];string s="1234";strcpy(c,s.c_str()); std::to_string()123456789string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val); to_string(1+2+4+7+14) string类型转换int类型12345std::string str;int i = atoi(str.c_str());std::string str;int i = std::stoi(str); stoi,stol,stoll等函数，表面简写原意string to … 函数find函数 查找字符串a是否包含子串b,不是用strA.find(strB) &gt; 0而是strA.find(strB) != string:npos 也最好不要用strA.fine(strB) &lt; strA.length(),因为查找失败返回string::npos，npos是-1或很大的值 rfind() 函数 rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则反向查找，rfind()是从指定位置起反向查找，直到串首，失败返回string::npos。12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s1 = "first second third"; string s2 = "second"; int index = s1.rfind(s2,6); if(index &lt; s1.length()) cout&lt;&lt;"Found at index : "&lt;&lt; index &lt;&lt;endl; else cout&lt;&lt;"Not found"&lt;&lt;endl; return 0;&#125; find_first_of() 函数 返回s2中任意字符 在s1 中第一次出现的下标位置 find_first_of()在源串中从位置pos起往后查找，只要在源串中遇到一个字符，该字符与目标串中任意一个字符相同，就停止查找，返回该字符在源串中的位置；若匹配失败，返回npos 如果str1中含有str2中的任何字符，则就会查找成功，而find则不同 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s1 = "first second second third"; string s2 = "asecond"; int index = s1.find_first_of(s2); if(index &lt; s1.length()) cout&lt;&lt;"Found at index : "&lt;&lt; index &lt;&lt;endl; else cout&lt;&lt;"Not found"&lt;&lt;endl; return 0;&#125;运行结果：Found at index : 3 查找s 中flag 出现的所有位置。 12345678910flag="a";position=0;int i=1;while( (position=s.find_first_of(flag,position) )!=string::npos)&#123; //position=s.find_first_of(flag,position); cout&lt;&lt;"position "&lt;&lt;i&lt;&lt;" : "&lt;&lt;position&lt;&lt;endl; position++; i++;&#125; find_last_of() 该函数与find_first_of()函数相似，只不过查找顺序是从指定位置向前， find_first_not_of() 在源串中从位置pos开始往后查找，只要在源串遇到一个字符，该字符与目标串中的任意一个字符都不相同，就停止查找，返回该字符在源串中的位置；若遍历完整个源串，都找不到满 足条件的字符，则返回npos。 find_last_not_of() find_last_not_of()与find_first_not_of()相似，只不过查找顺序是从指定位置向前 assgin() 将字符串2从第m个字符开始的n个字符赋值给字符串1:字符串1.assign(字符串2, m, n);12345string s1 = "I'm ";string s2 = "1234Juruo1234";s1.assign(s2, 4, 5);cout &lt;&lt; s1;//输出结果:Juruo append() 将字符串2接到字符串1尾部:字符串1.append(字符串2);字符不可以`c++将字符串2从第m个字符开始的n个字符接到字符串1尾部：字符串1.append(字符串2, m, n); string s1 = “I’m “;string s2 = “1234Juruo1234”;s1.append(s2, 4, 5);cout &lt;&lt; s1;//输出结果：I’m Juruo`]]></content>
      <categories>
        <category>stl</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度算法]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言:由于计算机运算是有模运算,数据范围的表示有一定限制,如整型int(C++中int 与long相同)表达范围是(-2^31~2^31-1),unsigned long(无符号整数)是(0~2^32-1),都约为几十亿.如果采用实数型,则能保存最大的double只能提供15~16位的有效数字,即只能精确表达数百万亿的数.因此,在计算位数超过十几位的数时,不能采用现有类型,只能自己编程计算. 由于数计算时可能要进位,因此为了方便,将数由低位到高位依次存在数组下标对应由低到高位置上,另外,我们申请数组大小时,一般考虑了最大的情况,在很多情况下,表示有富余,即高位有很多0,可能造成无效的运算和判断,因此,我们一般将数组的第0个下标对应位置来存储该数的位数.如数:3485(三千四百八十五)，表达在数组a[10]上情况是: 下标 0 1 2 3 4 5 6 7 8 9内容 4 5 8 4 3 0 0 0 0 0 说明：位数 个位 十位 百位 千位 倒序存储 面对高精度类型的题我们只需要像竖式一样从低位到高位计算，最后进行处理 注：高精度计算时一般用正数，对于负数，通过处理符号位的修正，在程序实现上用一个变量来存储符号位，用另一个数组存差的绝对值，置符号位：判断被减数是否大于减数：大则将符号位置为空；小则将符号位置为“- ”，交换减数与被减数； memset可用fill代替 在以后的学习中为了加快计算速度,也可用数组的一个元素表示数的多位数字(该内容可以进一步优化一个链接) 以下的方法的有明显的缺点： （1）浪费空间：一个整型变量（-32768~32767）只存放一位（0~9）； （2）浪费时间：一次加减只处理一位； 针对以上问题，如下优化：一个数组元素存放四位数；（integer的最大范围是32767，5位的话可能导致出界）将标准数组改为紧缩数组 高精度数的存储 １．如对数采用的字符串输入 123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=100;//最多100位int main()&#123; int a[N+1],i; string s1; cin&gt;&gt;s1;//数s1 memset(a,0,sizeof(a)); //数组清0 a[0]=s1.length(); //位数 for(i=1;i&lt;=a[0];i++) a[i]=s1[a[0]-i]-'0';//将字符转为数字并倒序存储． return 0;&#125; 2.直接读入 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int N=100;//最多100位int main()&#123; int a[N+1],i,s,key; cin&gt;&gt;key;//数key memset(a,0,sizeof(a)); //数组清0 i=0;//第0位 while(key) //当key大于0 &#123; a[++i]=key%10;//取第i位的数 key=key/10; &#125; a[0]=i; //共i位数 return 0;&#125; 3.直接初始化(用a[]存储) 初始化为0: memset(a,0,sizeof(a)); 初始化为1: memset(a,0,sizeof(a));a[0]=1;a[1]=1; 以下程序都只写函数，不写完整程序，所有高精度数存储都满足上述约定。(序号为1的) 高精度数的比较1.123456789101112131415161718int compare(int a[],int b[]) //比较a和b的大小关系，若a&gt;b则为1，a&lt;b则为-1,a=b则为0&#123; int i; if (a[0]&gt;b[0]) return 1;//a的位数大于b则a比b大 if (a[0]&lt;b[0]) return -1;//a的位数小于b则a比b小 for(i=a[0];i&gt;0;i--) //从高位到低位比较 &#123; if (a[i]&gt;b[i]) return 1; if (a[i]&lt;b[i]) return -1; &#125; return 0;//各位都相等则两数相等。&#125; 2.clear内联函数中if语句不可以删掉，如果2个输入都为0，在执行玩第一个语句后，全被删除，为空，所以if语句是输入全为0的情况！123456789101112131415161718 //清除前缀0，如果结果是空字符串则设为0 inline void clear(string&amp; a)&#123; while(a.length()&gt;0 &amp;&amp; a[0]=='0') a.erase(0, 1); if(a == "") a = "0";//如果a&gt;=b则返回真（如果包含前缀零会被消除） bool isBigger(string a, string b)&#123; clear(a); clear(b); if(a.length() &gt; b.length()) return true; if(a.length()==b.length() &amp;&amp; a&gt;=b) return true; return false; &#125; 高精度数的加法1.12345678910111213141516int plus(int a[],int b[]) //计算a=a+b&#123; int i,k; k=a[0]&gt;b[0]?a[0]:b[0]; //k是a和b中位数最大的一个的位数 for(i=1;i&lt;=k;i++) &#123; a[i+1]+=(a[i]+b[i])/10; //若有进位，则先进位 a[i]=(a[i]+b[i])%10; &#125; //计算当前位数字,注意：这条语句与上一条不能交换。 if(a[k+1]&gt;0) a[0]=k+1; //修正新的a的位数（a+b最多只能的一个进位） else a[0]=k; return 0;&#125; 2.注意一定要补0，否侧无法进位！！！1234567891011121314151617181920212223//两个高精度正整数加法 a+b string stringAddString(string a, string b)&#123; //1、对位，将两个数补零直到其具有相同长度 while(a.length() &lt; b.length()) a = '0' + a; while(a.length() &gt; b.length()) b = '0' + b; //2、补零，在开头再加一个0以便进位 a = '0' + a; b = '0' + b; //3、从低位开始相加，注意进位 for(int i=a.length()-1; i&gt;=0; i--)&#123; a[i] = a[i] + b[i] - '0'; if(a[i] &gt; '9')&#123; a[i] = a[i] - 10; a[i-1] += 1; &#125; &#125; clear(a); return a; &#125; 高精度数的减法1.12345678910111213141516171819202122232425262728293031323334353637383940414243int gminus(int a[],int b[]);//计算a=a-b，返加符号位0:正数 1:负数&#123; int flag,i flag=compare(a,b); //调用比较函数判断大小 if (falg==0)//相等 &#123; memset(a,0,sizeof(a)); return 0; &#125; //若a=b，则a=0,也可在return前加一句a[0]=1,表示是 1位数0 if(flag==1) //大于 &#123; for(i=1;i&lt;=a[0];i++) &#123; if(a[i]&lt;b[i]) &#123; a[i+1]--; a[i]+=10; &#125; //若不够减则向上借一位 a[i]=a[i]-b[i]; &#125; while(a[a[0]]==0) a[0]--; //修正a的位数 return 0; &#125; else if (flag==-1)//小于 则用a=b-a,返回-1 &#123; for(i=1;i&lt;=b[0];i++) &#123; if(b[i]&lt;a[i]) &#123; b[i+1]--; b[i]+=10; &#125; //若不够减则向上借一位 a[i]=b[i]-a[i]; &#125; a[0]=b[0]; while(a[a[0]]==0) a[0]--; //修正a的位数 return -1; &#125;&#125; 2.两个高精度正整数减法 a-b1234567891011121314151617181920212223242526272829303132333435 string stringSubString(string a, string b)&#123; bool aBigger = true; //1、对位，将两个数补零直到其具有相同长度 while(a.length() &lt; b.length()) a = '0' + a; while(a.length() &gt; b.length()) b = '0' + b; //2、推测结果正负值，调整为前大后小 if(a &lt; b) &#123; aBigger = false; string buf = b; b = a; a = buf; &#125; //3、从低位开始相减，注意借位,注意不用函数string是往后插入，然后从0开始，所以i=a.length()-1; for(int i=a.length()-1; i&gt;=0; i--)&#123; if(a[i] &gt;= b[i])&#123; a[i] = a[i] - (b[i] - '0'); &#125;else&#123; a[i] = a[i] + 10; a[i-1] -= 1; a[i] = a[i] - (b[i] - '0'); &#125; &#125;//4.字符就是int，字符型运算时是用ASCII码运算，//所以a[i] - b[i]为ASCII相减，此时不为数字字符，所以加上'0' //保证a[i]为数字字符（string)!!!!!!!!!!! clear(a); if(!aBigger) a = '-' + a;//string中因为'-'放在前面，所以输出时在前面，前后连接 return a; &#125; 高精度乘法1(高精度乘单精度数，单精度数是指通常的整型数)1.12345678910111213141516171819202122232425262728int multi1(int a[],long key) //a=a*key,key是单精度数 &#123; int i,k; if (key==0) &#123; memset(a,0,sizeof(a)); a[0]=1; return 0; &#125; //单独处理key=0 for(i=1;i&lt;=a[0];i++) a[i]=a[i]*key;//先每位乘起来 for(i=1;i&lt;=a[0];i++) &#123; a[i+1]+=a[i]/10; a[i]%=10; &#125; //进位 //注意上一语句退出时i=a[0]+1 while(a[i]&gt;0) &#123; a[i+1]=a[i]/10; a[i]=a[i]%10; i++; a[0]++; &#125; //继续处理超过原a[0]位数的进位,修正a的位数 return 0;&#125; 2. 待续 高精度除以低精度 算法：按照从高位到低位的顺序，逐位相除。在除到第j位时，该位在接受了来自第j+1位的余数后与除数相除，如果最高位为零，则商的长度减一 1.123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#define N 500main()&#123; int a[N] = &#123;0&#125;, c[N] = &#123;0&#125;; int i, k, d, b; char a1[N]; printf("Input 除数:"); scanf("%d", &amp;b); printf("Input 被除数:"); scanf("%s", a1); k = strlen(a1); for(i = 0; i &lt; k; i++) a[i] = a1[k - i - 1] - '0'; d = 0; for(i = k - 1; i &gt;= 0 ; i--) &#123; d = d * 10 + a[i]; c[i] = d / b; d = d % b; &#125; while(c[k - 1] == 0 &amp;&amp; k &gt; 1) k--; printf("商="); for(i = k - 1; i &gt;= 0; i--) printf("%d", c[i]); printf("\n余数=%d", d); &#125; 2. 待续 #]]></content>
      <categories>
        <category>算法</category>
        <category>高精度算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++find函数]]></title>
    <url>%2F2019%2F03%2F09%2Fc-find%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[find函数 find用在容器中更加普遍，而algorithm中其实find函数只是一种 C++find函数原型： 123456789101112template&lt;class InputIterator, class T&gt; InputIterator find (InputIterator first, InputIterator last, const T&amp; val)&#123; while (first!=last) &#123; if (*first==val) return first; ++first; &#125; return last;&#125;如果没找到对应的关键元素，会返回end(),最后一个元素的后一位。 其中，find()算法的前两个参数都是某个容器的迭代器，用于指定查找的起始位置和终止位置；第三个参数就是要查找的内容，它的数据类型跟容器中数据的类型相同。这里需要注意的是，find()算法会利用“==”操作符将这里的目标内容跟容器中的数据元素进行相等比较，以确定某个元素是否符合条件，所以，这里的数据类型必须支持“==”操作符进行相等比较。对于基本数据类型而言，它们已经天然支持无需我们操心，如果是自定义的数据类型，则需要重载“==”操作符以支持相等比较。 各个容器自己实现的成员函数 vector没有实现find函数，除此之外，常见容器都实现了自己的find函数，如set，map，string String是这一种顺序存储结构，其find函数返回的是下标索引。set,map,multiset,multimap都不是顺序索引的数据结构，所以返回的是迭代器。 为什么返回的不是索引下标？这是因为索引下标是在数组这种连续存储的数据结构里面常见的，是一种顺序索引；而很多数据结构的存储并非连续的，不能实现顺序索引，为了兼顾所有的数据结构，所以返回的仅仅是指针或是迭代器。如果元素不在 对于返回迭代器的查找，通过判断find（a.begin(),a.end(),value）==a.end()，来判断元素是否存在 对于string，通过a.find(val)==string::npos判断 std::map::find返回值指向键等于 key 的元素的迭代器。若找不到这种元素，则返回尾后（见 end() ）迭代器。]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog表格]]></title>
    <url>%2F2019%2F03%2F09%2Fblog%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[表格 a b c d |、-、:之间的多余空格会被忽略，不影响布局。默认标题栏居中对齐，内容居左对齐。 -:表示内容和标题栏居右对齐 :-表示内容和标题栏居左对齐 :-:表示内容和标题栏居中对齐。 内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略，-的数量至少有一个。]]></content>
      <categories>
        <category>blog</category>
        <category>表格</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector简介]]></title>
    <url>%2F2019%2F03%2F09%2Fvector%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[cpp vector vector的底层数据结构是动态数组内存分配 标准库的实现者使用了这样的内存分配策略：以最小的代价连续存储元素。为了使vector容器实现快速的内存分配，其实际分配的容量要比当前所需的空间多一些(预留空间)，vector容器预留了这些额外的存储区用于存放添加的新元素，于是不必为每个新元素进行一次内存分配。当继续向容器中加入元素导致备用空间被用光（超过了容量 capacity），此时再加入元素时vector的内存管理机制便会扩充容量至两倍，如果两倍容量仍不足，就扩张至足够大的容量。容量扩张必须经历“重新配置、元素移动、释放原空间”这个浩大的工程。 按照《STL源码剖析》中提供的vector源码，vector的内存配置原则为： 如果vector原大小为0，则配置1，也即一个元素的大小。 如果原大小不为0，则配置原大小的两倍。 当然，vector的每种实现都可以自由地选择自己的内存分配策略，分配多少内存取决于其实现方式，不同的库采用不同的分配策略。 迭代器失效问题 vector管理的是连续的内存空间，在容器中插入（或删除）元素时，插入（或删除）点后面的所有元素都需要向后（或向前）移动一个位置，指向发生移动的元素的迭代器都失效。 随着元素的插入，原来分配的连续内存空间已经不够且无法在原地拓展新的内存空间，整个容器会被copy到另外一块内存上，此时指向原来容器元素的所有迭代器通通失效。 删除元素后，指向被删除元素的迭代器失效，这是显而易见的。 访问 使用的vector下标必须小于vector.size();如果开始定义vector未指定大小，用数组下标输入不可以，因为vector中无相应元素，没相应内存空间 初始化大小 vector v(n,i)形式，v包含n 个值为 i 的元素 v(int n)将容器初始化为有 n 个元素 vector()无参构造函数，将容器初始化为空 如果想知道vector是否为空，可以使用empty（），空返回true，否则返回false。]]></content>
      <categories>
        <category>stl</category>
        <category>vector</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[list列表]]></title>
    <url>%2F2019%2F03%2F08%2Flist%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[cppreference list头文件 #include ＜list＞ 底层数据结构 list同样是一个模板类，它底层数据结构为双向循环链表。因此，它支持任意位置常数时间的插入/删除操作，不支持快速随机访问。 双向链表的每个元素中都有一个指针指向后一个元素，也有一个指针指向前一个元素 内存分配策略 list的空间配置策略，自然是像我们普通双向链表那样，有多少元素申请多少内存。它不像vactor那样需要预留空间供新元素的分配，也不会因找不到连续的空间而引起整个容器的内存迁移。 迭代器失效问题 list 有一个重要性质：插入操作（insert）与接合操作（splice）都不会造成原有的list迭代器失效。这在vector是不成立的，因为vactor的插入可能引起空间的重新配置，导致原来的迭代器全部失效。list的迭代器失效，只会出现在删除的时候，指向删除元素的那个迭代器在删除后失效。通常来说，forward_list在使用灵活度上比不上list，因为它只能单向迭代元素，且提供的接口没有list多。然而，在内存的使用上，它是比list占优势的。当对内存的要求占首要位置时，应该选择forward_list。 构造函数 list&lt;int&gt; c;空链表 list&lt;int&gt; c1(3); 建一个含三个默认值是0的元素的链表 list&lt;int&gt; c2(5,2); 建一个含五个元素的链表，值都是2 list&lt;int&gt; c4(c2); 建一个c2的copy链表 list&lt;int&gt; c5(c1.begin(),c1.end()); c5含c1一个区域的元素[_First, _Last)。 list 容器不支持根据下标随机存取元素 list 的成员函数 front() 和 back()，可以各自返回第一个和最后一个元素的引用。在空 list 中调用它们中的任意一个，结果是未知的，因此不要这样使用。可以通过迭代器的自增或自减来访问 list 的内部元素。 List常用操作函数list 的特点 (1) 不使用连续的内存空间这样可以随意地进行动态操作； (2) 可以在内部任何位置快速地插入或删除，当然也可以在两端进push 和pop 。 (3) 不能进行内部的随机访问，即不支持[ ] 操作符和vector.at() ； (4) 相对于verctor 占用更多的内存。 有自身的sort函数 STL 中的算法 sort 可以用来对 vector 和 deque ，string排序，它需要随机访问迭代器的支持。因为 list 不支持随机访问迭代器，所以不能用算法 sort 对 list 容器排序。因此，list 容器引入了 sort 成员函数以完成排序。 注意std::sort 要求随机访问迭代器且不能用于 list 。此函数与 std::sort 的区别在于，它不要求 list 的元素类型可交换，保留所有迭代器的值，并进行稳定排序。]]></content>
      <categories>
        <category>stl</category>
        <category>list</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reverse反转函数]]></title>
    <url>%2F2019%2F03%2F08%2Freverse%E5%8F%8D%E8%BD%AC%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[reverse函数 reverse函数可以反转一个容器中的内容，包含在&lt;algorithm&gt;库中。 参数：first、last first和last是双向迭代器类型，reverse函数反转的范围是[first,last)，所以包括first指向的元素，不包括last指向的元素。 reverse(v.begin(),v.end());反向排列从头到尾部的元素 reverse函数没有返回值。 复杂度 循环交换首尾元素。因此复杂度是线性的，并且循环半个数组长度。]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vector大小（size）和容量（capacity）]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%85%B3%E4%BA%8Evector%E5%A4%A7%E5%B0%8F%EF%BC%88size%EF%BC%89%E5%92%8C%E5%AE%B9%E9%87%8F%EF%BC%88capacity%EF%BC%89%2F</url>
    <content type="text"><![CDATA[vector 在Vector容器中有以下几个关于大小的函数 size()返回容器的大小，目前存在的元素数 empty()判断容器是否为空 max_size()返回容器最大的可以存储的元素 capacity()返回容器当前能够容纳的元素数量capacity 一般大于size的原因是为了避免 每次增加数据时都要重新分配内存，所以一般会 生成一个较大的空间，以便随后的数据插入。 Vector的容量之所以重要，有以下两个原因： - 1. 容器的大小一旦超过capacity的大小，vector会重新配置内部的存储器，导致和vector元素相关的所有reference、pointers、iterator都会失效。 - 2.内存的重新配置会很耗时间。 size 是当前 vector 容器真实占用的大小，也就是容器当前拥有多少个容器。 因为是实时的大小，所以在对容器进行操作后size大小会变化，特别注意在循环用size作循环条件时，如果在循环语句中对容器进行了操作，那么size会不断发生变化 capacity 是指在发生 realloc 前能允许的最大元素数，即预分配的内存空间。 在 STL 中，拥有 capacity 属性的容器只有 vector 和 string 避免内存重新配置的方法 方法一：Reserve()保留适当容量在创建容器后，第一时间为容器分配足够大的空间，避免重新分配内存。 vec.reverse(n); 方法二：利用构造函数创建出足够空间 该方法是创建容器时，利用构造函数初始化的出足够的空间， vector&lt;int&gt; v(n); 但是要注意，如果容器中reserve的容量太大，而实际中根本不需要那么多，或者元素插入完成后，以后就不会再进行插入操作了，那么多出来的这部分空间就是过剩空间，而对于过剩空间，我们可以通过“交换技术”成功缩小空间，交换技巧的变体可以用于清除容器和减少它的容量到你的实现提供的最小值。 Vector内存扩展方式 更多可去 stl介绍 vector内存成长方式可归结以下三步曲:（1）另觅更大空间；（2）将原数据复制过去；（3）释放原空间三部曲。 对于vector和string来说，当它们的需要更多空间时，就会自动增加空间，而每次增加空间的容量会导致很大的开销，首先必须分配新的内存块，它有容器目前容量的几倍（在大部分实现中，vector和string的容量每次变为2倍），然后把所有元素从容器的旧内存拷贝到它的新内存，接着销毁旧内存中的对象，最后回收旧内存。 每次重新分配空间，所有指向vector或string中的迭代器、指针和引用都会失效，这意味着简单地把一个元素插入vector或string的动作也可能需要更新其他使用了指向vector或string中的迭代器、指针或引用的数据结构而膨胀。]]></content>
      <categories>
        <category>stl</category>
        <category>vector</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头文件]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%A4%B4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[#include STL定义运算函数（代替运算符） #include&lt;bits/stdc++.h&gt; 编译器GCC 4.8支持的万能头文件，基本包含所有头文件]]></content>
      <categories>
        <category>头文件</category>
        <category>functioinal</category>
      </categories>
      <tags>
        <tag>头文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pair容器]]></title>
    <url>%2F2019%2F03%2F08%2Fpair%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[pair pair类型的使用相当的繁琐，如果定义多个相同的pair类型对象，可以使用typedef简化声明：typedef pair&lt;string,string&gt; Author; 除了构造函数，标准库还定义了一个make_pair函数，由传递给它的两个实参生成一个新的pair对象 123456789101112 pair&lt;string, string&gt; next_auth; string first,last; while(cin&gt;&gt;first&gt;&gt;last) &#123; next_auth=make_pair(first,last); ...&#125; 等价的更复杂的操作:next_auth=pair&lt;string,string&gt;(first,last);]]></content>
      <categories>
        <category>stl</category>
        <category>pair</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort函数]]></title>
    <url>%2F2019%2F03%2F08%2Fsort%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言 排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。 STL容器的排序，支持随机访问的容器vector,deque,string没有sort成员，可调用std::sort排序；list排序调用自带的list::sort。 注意std::sort 要求随机访问迭代器且不能用于 list 。此函数与 std::sort 的区别在于，它不要求 list 的元素类型可交换，保留所有迭代器的值，并进行稳定排序。 sort函数有以下特征： 要求输入一个范围[first, last) 随机迭代器，能用此算法的容器是支持随机访问的容器：vector, deque, string。 对于list容器，list自带一个sort成员函数list::sort()。它和算法函数中的sort差不多，但是list::sort是基于指针的方式排序，也就是说，所有的数据移动和比较都是此用指针的方式实现，因此排序后的迭代器一直保持有效（vector中sort后的迭代器会失效)。 sort函数 默认的为升序 第三参数——比较函数。比较函数是一个自己定义的函数，返回值是bool型(一般)，它规定了什么样的关系 排序的数据类型不局限于整数，只要是定义了小于运算的类型都可以，比如字符串类string。 如果是没有定义小于运算的数据类型，或者想改变排序的顺序，就要用到第三参数——比较函数。 vector&lt;int&gt; v; sort(v.begin(), v.end(), greater&lt;int&gt;()); sort(a, a+n, cmp); 对数组进行排序,其头文件为algorithm.h，形式为sort（数组名，数组名+数组长度），默认为升序，复杂度为nlog（n）； 加#include&lt;functional&gt;因为用了greater&lt;int&gt;() sort(begin, end, less&lt;数据类型&gt;（）)，升序； sort(begin, end, greater&lt;数据类型&gt;（）)，降序； sort（数组名，数组名+数组长度，less&lt;数组数据类型&gt;()）,升序； sort(数组名，数组名+数组长度，greater&lt;数组数据类型&gt;（）)，降序。]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[计算机领域中，这个字典序就不仅仅用来比较英文单词了，而是比较任意字符串。对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。如strcmp函数的原理 strcmp()函数有许多变体，它们的基本功能是相同的，都是比较两个字符串，但其它地方稍有差别。下表列出了C语言提供的与strcmp()函数类似的一些函数： 123456789----------------------------------------------------------------- 函 数 名 作 用----------------------------------------------------------------- strcmp() 对两个字符串进行大小写敏感的比较 strcmpi() 对两个字符串进行大小写不敏感的比较 stricmp() 同strcmpi() strncmp() 对两个字符串的一部分进行大小写敏感的比较 strnicmp() 对两个字符串的一部分进行大小写不敏感的比较-----------------------------------------------------------------]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stl代码练习]]></title>
    <url>%2F2019%2F03%2F08%2Fstl%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[learn_stl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#define MAX_SIZE 10000using namespace std;int n;typedef struct node&#123; string name; //string暂时可以当成一种结构体变量,专门用来定义字符串,name的长度可以由name.length()获得 int grade;&#125;Student;vector&lt;int&gt; vec;list&lt;int&gt; link_list;deque&lt;int&gt; dq;stack&lt;int&gt; Stack;queue&lt;int&gt; que;priority_queue&lt;int&gt; q;set&lt;int&gt; s;map&lt;string,int&gt; stu;void fun_1(int a[]);void fun_2(int a[]);void fun_3(int a[]);void fun_4(int a[]);void fun_5(int a[]);void fun_6(int a[]);void fun_7(Student a[]);int main()&#123; int a[MAX_SIZE]; Student student[MAX_SIZE]; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; student[i].name &gt;&gt; student[i].grade;//只用于map /*1.用vector存入数组中所有的数据并升序排序,然后删去最大元素 */for(int i = 0; i &lt; n; i++) vec.push_back(a[i]);sort(vec.begin(), vec.end());vec.pop_back();for(int i = 0; i &lt; vec.size(); i++) cout &lt;&lt; vec[i] &lt;&lt; endl;/*2. 用list存入数组中所有的元素并升序排序。删除其中最小的节点并再插入一个最大的节点 */ for(int i = 0; i &lt; n; i++) link_list.push_back(a[i]);link_list.sort();link_list.erase(link_list.begin());link_list.insert(link_list.begin(), *(--link_list.end())); for(list&lt;int&gt;::iterator itt = link_list.begin(); itt != link_list.end(); itt++) cout &lt;&lt; *itt &lt;&lt; endl; /*3.用deque存入数组中所有的数据，在头尾端插入一个和队头队尾相同的元素。 将deque中的数据用另一个vector存储起来排序后再放回deque中 */ for(int i = 0; i &lt; n; i++) dq.push_back(a[i]);dq.push_back(a[n-1]), dq.push_front(a[0]);vector&lt;int&gt; haha;for(int i = 0; i &lt; n; i++) haha.push_back(a[i]);sort(haha.begin(), haha.end());dq.clear();deque&lt;int&gt; dq(haha.begin(), haha.end());for(deque&lt;int&gt;:: iterator ittt = dq.begin(); ittt != dq.end(); ittt++) cout &lt;&lt; *ittt &lt;&lt; endl;/*4.将数组中的元素依次存入stack中，然后依次存入queue中实现数组元素的reverse */ for(int i = 0; i &lt; n; i++) Stack.push(a[i]);for(int i = n-1; i &gt;= 0; i--)&#123; que.push(Stack.top()); Stack.pop(); &#125; for(int i = n - 1; i &gt;= 0; i--) cout &lt;&lt; que.front() &lt;&lt; endl; /*5.不借助其他的函数和变量，利用priority_queue实现数组的升序排序 */ priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q; for(int i = 0; i &lt; n; i++) q.push(a[i]);for(int i = 0; i &lt; n; i++) cout &lt;&lt; q.top() &lt;&lt; endl;/*6.将数组中的元素全部存入set中，并输入一个元素，在set中查找它，找到则删除它 */for(int i = 0; i &lt; n; i++) s.insert(a[i]);int j;scanf("%d", &amp;j);set&lt;int&gt;::iterator itt;itt = s.find(j);if(itt != s.end()) s.erase(itt);for(itt = s.begin(); itt != s.end(); itt++) cout &lt;&lt; *itt &lt;&lt; endl;/*7.将学生的姓名和成绩全部存入map中，并根据学生成绩降序排序。(不能修改给定map的两个参数的顺序) */ //第一种 int cmp(pair &lt;string, int&gt; a, pair&lt;string, int&gt; b);pair&lt;string, int&gt; pa;for(int i = 0; i &lt; n; i++) pa = make_pair(student[i].name, student[i].grade);for(int i = 0; i &lt; n; i++) stu.insert(pair&lt;string, int&gt;(student[i].name, student[i].grade));vector&lt;pair&lt;string, int&gt; &gt; baba(stu.begin(), stu.end() );sort(baba.begin(), baba.end(), cmp);for(int i = 0; i &lt; baba.size(); i++) cout &lt;&lt; baba[i].first &lt;&lt; " " &lt;&lt; baba[i].second &lt;&lt; endl;//第二种(就是直接用make_pair插入以及sort函数直接用greater逆序排列) for(int i = 0; i &lt; n; i++) stu.insert(make_pair(student[i].name, student[i].grade)); vector&lt;pair&lt;string, int&gt; &gt; yeye(stu.begin(), stu.end() );sort(yeye.begin(), yeye.end(), greater&lt;pair&lt;string, int&gt; &gt;());for(int i = 0; i &lt; n; i++) cout &lt;&lt; yeye[i].first &lt;&lt; " " &lt;&lt; yeye[i].second &lt;&lt; endl;//分割线 return 0;&#125; bool cmp(pair &lt;string, int&gt; a, pair&lt;string, int&gt; b) &#123; return a.second &gt; b.second; &#125;]]></content>
      <categories>
        <category>stl</category>
        <category>代码练习</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stl介绍]]></title>
    <url>%2F2019%2F03%2F08%2Fstl%2F</url>
    <content type="text"><![CDATA[注意，STL头文件没有扩展名.h STL中默认是采用小于号来排序的 stl很好的介绍（原链接） c++手册 1.容器概论 容器，置物之所也。像桶可装水，碗可盛汤，C++的容器，可以存储对象。容器有多种，用来处理不同的元素操作诉求。按照元素存储到容器中以及访问方式的差异，容器分为顺序容器与关联容器。 顺序容器也称为序列式容器。序列式容器按元素插入的顺序存储元素，这些元素可以进行排序，但未必是有序的。C++本身内置了一个序列式容器array（数组），STL另外提供了vector,list,forward_list,deque,stack,queue,priority-queue，string等等序列式容器。 所有的容器都是基于模板实现的，因为容器必须保证能装得下各种各样的类型。其中，stack，queue都是基于deque来实现的，priority-queue基于heap来实现，从技术上来说它们属于容器适配器（adapter）。其中array与forward_list是C++11添加的新容器类型。 2.序列式容器（顺序容器） 向量(vector) 连续存储的元素&lt;vector&gt; 列表(list) 由节点组成的双向链表，每个结点包含着一个元素&lt;list&gt; 双端队列(deque) 连续存储的指向不同元素的指针所组成的数组&lt;deque&gt; 3.适配器容器 栈(stack) 后进先出的值的排列 &lt;stack&gt; 队列(queue) 先进先出的值的排列&lt;queue&gt; 优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 &lt;queue&gt; 4.关联式容器 关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。 集合(set) 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序&lt;set&gt; 多重集合(multiset) 允许存在两个次序相等的元素的集合&lt;set&gt; 映射(map) 由{键，值}对组成的集合，以某种作用于键对上的谓词排列 &lt;map&gt; 多重映射(multimap) 允许键对有相等的次序的映射&lt;map&gt; 5.容器适配器 stack，也称为栈，是一种先进后出的数据结构。STL中的statck是一种容器适配器。所谓的容器适配器，是以某种容器作为底部容器，在底部容器之上修改接口，形成另一种风貌。stack默认以双端队列deque作为底部容器。stack没有提供迭代器，通过push/pop接口对栈顶元素进行操作。 queue，也称为队列，是一种先进先出的数据结构，它同样也是一种容器适配器。它的底部容器默认为deque。同样，queue也没有提供迭代器，通过push向队尾压入元素，pop从队首弹出元素。 priority-queue，优先队列，是一种拥有权值观念的队列，例如在以整数大小作为衡量的权值定义下，priority-queue总是弹出最大的数。priority-queue的底部数据结构默认是max-heap，大顶堆。 6.基础总结 注意： “尾部可高效插入/删除元素”，意味着在除了尾部之外的其他位置插入/删除元素是较低效的。 “顺序访问”意味着要访问某一个元素，必须遍历其他元素。 迭代器失效意味着指针、引用在同样的情况下也会失效。 所有容器都有以下两个成员函数： int size()：返回容器对象中元素的个数。 bool empty()：判断容器对象是否为空。 顺序容器和关联容器还有以下成员函数： begin()：返回指向容器中第一个元素的迭代器。 end()：返回指向容器中最后一个元素后面的位置的迭代器。 rbegin()：返回指向容器中最后一个元素的反向迭代器。 rend()：返回指向容器中第一个元素前面的位置的反向迭代器。 erase(…)：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。 clear()：从容器中删除所有元素。 如果一个容器是空的，则 begin() 和 end() 的返回值相等，rbegin() 和 rend() 的返回值也相等。 顺序容器还有以下常用成员函数： front()：返回容器中第一个元素的引用。 back()：返回容器中最后一个元素的引用。 push_back()：在容器末尾增加新元素。 pop_back()：删除容器末尾的元素。 insert(…)：插入一个或多个元素。该函数参数较复杂，此处省略。 stl注意点 size 是当前容器真实占用的大小，也就是容器当前拥有多少个容器。 因为是实时的大小，所以在对容器进行操作后size大小会变化，特别注意在循环用size作循环条件时，如果在循环语句中对容器进行了操作，那么size会不断发生变化 对容器进行读取，删除，弹出等操作时一定要先判空，如对stack.top()使用时必须先判空，否侧可能程序不会报错但无法运行 如果需要对deque进行排序的话，最好是先复制到vector中，然后再进行排序，最后在把元素拷贝回来，这样效率会提高一点。]]></content>
      <categories>
        <category>stl</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++map容器]]></title>
    <url>%2F2019%2F03%2F08%2Fc-map%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[STL是一个统一的整体，map的很多用法都和STL中其它的东西结合在一起 map中由于它内部有序，由红黑树保证，因此很多函数执行的时间复杂度都是log2N的，如果用map函数可以实现的功能，而STL Algorithm也可以完成该功能，建议用map自带函数，效率高一些。 sort算法有个限制，利用sort算法只能对序列容器进行排序，就是线性的（如vector，list，deque）。map是一个集合容器，它里面存储的元素是pair，但是它不是线性存储的（像红黑树），所以利用sort不能直接和map结合进行排序。 operator()重载必须是常成员函数，因为常对象只能调用常成员函数 STL中默认是采用小于号来排序的 键和值的数据类型是不相同的，这与set不同。set中的key和value是Key类型的，而map中的key和value是一个pair结构中的两个分量 stl-map greater &lt;int&gt; &gt;最右边的两个&gt;之间要有空格，否则 Dev C++ 会将它们当作右移运算符，导致编译出错对map的排序 key值排序 按照Key值自动进行了排序 上面的按key值排序有个缺点：即当插入的有多个相等的值时，由于key的唯一性，会只保留一个。 map的定义12template &lt; class Key, class T, class Compare = less&lt;Key&gt;, class Allocator = allocator&lt;pair&lt;const Key,T&gt; &gt; &gt; class map; 它有四个参数，其中我们比较熟悉的有两个: Key 和 Value。第四个是 Allocator，用来定义存储分配模型的 现在重点看下第三个参数： class Compare = less&lt;Key&gt;这也是一个class类型的，而且提供了默认值 less&lt;Key&gt;。 less是stl里面的一个函数对象，那么什么是函数对象呢？所谓的函数对象：即调用操作符的类，其对象常称为函数对象（function object），它们是行为类似函数的对象。表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个 类，其实质是对operator()操作符的重载。 less的实现： 1234template &lt;class T&gt; struct less : binary_function &lt;T,T,bool&gt; &#123; bool operator() (const T&amp; x, const T&amp; y) const &#123;return x&lt;y;&#125;&#125;; 是一个带模板的struct，里面仅仅对()运算符进行了重载，实现很简单，但用起来很方便，这就是函数对象的优点所在。stl中还为四则运算等常见运算定义了这样的函数对象，与less相对的还有greater map这里指定less作为其默认比较函数(对象)，所以我们通常如果不自己指定Compare，map中键值对就会按照Key的less顺序进行组织存储 可以在定义map的时候，指定它的第三个参数Compare，比如我们把默认的less指定为greater：要加#include &lt;functional&gt; map&lt;string, int, greater&lt;string&gt; &gt; name_score_map; 只要我们自己写一个函数对象，实现想要的逻辑，定义map的时候把Compare指定为我们自己编写的这个就ok啦。 12345struct CmpByKeyLength &#123; bool operator()(const string&amp; k1, const string&amp; k2) const &#123; return k1.length() &lt; k2.length(); &#125;&#125;; map&lt;string, int, CmpByKeyLength&gt; name_score_map; 按照value排序 思路1：可以考虑将value作为key值进行自动排序。 思路2：可以把map中的key值和value值分别转存到一个pair类型的vector中，在对vector按照一定的规则排序即可。这样的方法对值一样的情况也能够使用。 123456typedef pair&lt;string, int&gt; PAIR;map&lt;string, int&gt; name_score_map;name_score_map.insert(make_pair("Bing", 99));name_score_map.insert(make_pair("Albert", 86));vector&lt;PAIR&gt; name_score_vec(name_score_map.begin(), name_score_map.end());sort(name_score_vec.begin(), name_score_vec.end(), cmp); map的构造 在 C++ 中通过 insert() 方法向集合中插入一个新的映射，参数是一个 pair 类型的结构。pair&lt;int,char&gt;(1,’a’)定义了一个整数 1 和字符 a 的 pair。我们向映射中加入新映射对的时候就是通过 pair 来实现的。如果插入的 key 之前已经有 value，不会用插入的新的 value 替代原来的 value，也就是插入无效，但并不会报错。 如果插入语句没有生效，那么这就涉及到我们怎么知道 insert 语句是否插入成功的问题了，可以通过 pair 来获得是否插入成功，程序如下： 12pair&lt;map&lt;int, string&gt;::iterator, bool&gt; insert_pair;insert_pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, "student_one")); 我们通过 pair 的第二个变量来知道是否插入成功，它的第一个变量返回的是一个 map 迭代器，如果插入成功的话，insert_pair.second应该是 true，否则为 false。 用数组方式就不同了，它可以覆盖以前该关键字对应的值 是否已经有映射了。需要用到 count() 函数进行判断或者find std::map::count size_type count( const Key&amp; key ) const; template&lt; class K &gt; size_type count( const K&amp; x ) const; 返回拥有关键比较等价于指定参数的元素数，因为此容器不允许重复故为 1 或 0。 1) 返回拥有关键 key 的元素数。 2) 返回拥有关键比较等价于值 x 的元素数。此重载仅若有限定 id Compare::is_transparent合法且指代一个类型才参与重载决议。这允许调用此函数而不构造 Key 的实例。 参数 key 要计量元素数的关键值 x 要与关键比较的替用值 返回值拥有比较等价于 key 或 x 的关键的元素数，对于 (1) 为 1 或 0。 mapStudent.insert(pair&lt;int, string&gt;(2, &quot;student_two&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); mapStudent[1] = &quot;student_one&quot;; 总结： 对key 排序的话，直接使用greater&lt;string&gt;在map定义的时候就。而要对value排序，则是使用函数对象，先将map转换为vector，调用sort函数中传入一个函数对象，则可以实现对value 的排序。还有一点是pair 只重载了&amp;lt;，则stl 则不能使用 == 运算符。]]></content>
      <categories>
        <category>stl</category>
        <category>map</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bool类型]]></title>
    <url>%2F2019%2F03%2F08%2Fbool%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[千万不要让编译器决定你的默认值，永远初始化 变量未初始化的默认值要看变量的存储类型，也可能与编译器有关，跟其它因素 bool类型 c++中有bool类型 bool可用于定义函数类型为布尔型，函数里可以有 return TRUE; return FALSE 之类的语句。 初始化 为了安全起见， 最好初始化为false. bool值一定要初始化 在GCC编译器下各个类型的全局变量的默认值： 表示数字的变量类型默认值都为0 bool型默认值为false string型默认值为空字符串 char 型比较特殊。char类型默认值为’\0’， 即字符串结束标志，其整数值为0。如果用printf(“%d”)输出时值为 0， 但用printf(“%c”),或cout 输出时显示为”a”， char型数组默认值为空字符串，其中的每个元素与单个char类型相同，所以用puts() 和printf(“%s”)输出都是空字符串。]]></content>
      <categories>
        <category>c++</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换]]></title>
    <url>%2F2019%2F03%2F06%2F%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[类型转换 进行不同数据的强制转换其实就是数据占用字节扩充或者截断。 将数据由值域较宽类型强制转换到值域较窄类型时，有可能出现数据信息丢失。 char 型数据在机器里通过 ASCII 码存储，也就是用一个整数存储的。 当执行一个运算时（如这里的a&gt;b），如果它的一个运算数是有符号的而另一个数是无符号的，那么C语言会隐式地将有符号 参数强制类型为无符号数，并假设这两个数都是非负的，来执行这个运算]]></content>
      <categories>
        <category>数据类型</category>
        <category>类型转换</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码块高亮]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BB%A3%E7%A0%81%E5%9D%97%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[主题自带样式 代码块高亮 这里指的是1234```[language] [title] [url] [link-text]代码 [language] 是代码语言的名称，用来设置代码块颜色高亮，非必须； [title] 是顶部左边的说明，非必须； [url] 是顶部右边的超链接地址，非必须； [link text] 如它的字面意思，超链接的名称，非必须。 亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数筛选法]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数学原理 一个数 n 如果是合数，那么它的所有的因子不超过sqrt(n)–n的开方 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数 质数大于等于2 不能被它本身和1以外的数整除 素数筛选法 素数是数学中一个很重要的数，很多算法中都需要用到素数相关的性质，因此传统的暴力循环求素数的效率显得十分低效，这里我们有两种高效求1~n以内的素数的方法。需要大家掌握，特别是欧拉筛法里面用到一点数学性质，大家可自行百度欧拉筛法掌握具体的原理，以后的出现的算法中还会出现。 欧拉筛法-时间复杂度（n) 回顾经典的Eratosthenes筛法，它可能对同一个质数筛去多次。那么如果用某种方法使得每个合数只被筛去一次就变成是线性的了。不妨规定每个合数只用其最小的一个质因数去筛，这便是欧拉筛了。 最简单的素数筛法是这样的：10000000内的素数，用这个筛选法可以大大的降低时间复杂度 1.开一个大的bool型数组prime[]，大小就是n+1就可以了.先把所有的下标为奇数的标为true,下标为偶数的标为false. 2.然后：1234567for( i=3; i&lt;=sqrt(n); i+=2 )&#123; if(prime) for( j=i+i; j&lt;=n; j+=i ) prime[j]=false;&#125; 3.最后输出bool数组中的值为true的单元的下标，就是所求的n以内的素数了。 原理很简单，就是当i是质(素)数的时候，i的所有的倍数必然是合数。如果i已经被判断不是质数了，那么再找到i后面的质数来把这个质数的倍数筛掉。 原理 No.1使用 合数=最大因数(除1和本身外)最小质因数 的原理来筛，每个数只会被筛一次对于每个数i，令它是某数的最大因数，然后从小到大地找&lt;=i的素数j，则ij是合数直到找到某个j使得i%j == 0,因为再往后的话，j’&gt; i的某个因子，我们能交换j’和i的这个因子，所以i不是ij’的最大因数（或者说ij’的最小质因数是刚才的那个j），再往后做没有意义 No.2回顾经典的Eratosthenes筛法，它可能对同一个质数筛去多次。那么如果用某种方法使得每个合数只被筛去一次就变成是线性的了。不妨规定每个合数只用其最小的一个质因数去筛，这便是欧拉筛了。 No.3线性筛有两个地方与一般筛不同: 1.两层循环的顺序不同（一般筛是第一维prime[i] 第二维j，欧拉筛是第一维i 第二位prime[j]） 2.一行神奇的代码： if(i%prime[j]==0)break; prime[]数组中的素数是递增的,当i能整除prime[j]，那么iprime[j+1]这个合数肯定被prime[j]乘以某个数筛掉。 因为i中含有prime[j],prime[j]比prime[j+1]小，即 `i=kprime[j]，那么iprime[j+1]=(kprime[j])prime [j+1]=k’prime[j]，接下去的素数同理。所以不用筛下去了。因此，在满足i%prime[j]==0`这个条件之前以及第一次 满足改条件时,prime[j]必定是prime[j]*i的最小因子。 No.4 证明分两部分。首先证每个合数都会被筛到（正确性），其次证每个合数只会被筛到一次（复杂度）。每个合数都会被筛到设有一合数 （为质数）则一定会在 时被筛去（此时 ），因为对于小于 的质数，一定不会被 整除每个合数都只会被筛到一次与上面一样，还是设有一合数 （ 为质数）倘若存在一个质因子 也筛去了，那么此时 。o，此时在内层循环中已经早早地break掉了，因为 。o，此时还没加进质数表QwQ（顺便一提：这种情况只有可能在 时发生） 代码：12345678910111213void euler_sieve(int n) &#123; totPrimes = 0; memset(flag, 0, sizeof(flag)); for (int i = 2; i &lt;= n; i++) &#123; if (!flag[i]) primes[totPrimes++] = i; for (int j = 0; i * primes[j] &lt;= n; j++) &#123; flag[i*primes[j]] = true; if (i % primes[j] == 0) break; &#125; &#125; &#125; j &lt; totPrimes为何不加？ o当 为质数时，内层循环会在最后一个质数（也就是 自己）终止。o当 为合数时，内层循环会在它的第一个质因数终止。当然加了也没有问题 埃拉特斯特尼筛法，时间复杂度（nlogn）]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%88%86%E6%B2%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分治法 这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……可使用分治法求解的一些经典问题 （1）二分搜索（2）大整数乘法（3）Strassen矩阵乘法（4）棋盘覆盖（5）合并排序（6）快速排序（7）线性时间选择（8）最接近点对问题（9）循环赛日程表（10）汉诺塔 -]]></content>
      <categories>
        <category>算法</category>
        <category>分治法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出]]></title>
    <url>%2F2019%2F03%2F05%2Fc-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[续行符 宏定义只能在一行内完成 字符串多行书写有两种规则：在字符串换行处加一个反斜杠\，下一行前不能有空格或者Tab键；使用双引号。 代码中的“\”是 C 语言中的续行符语法，表示续行符的下一行与续行符所在的代码是同一行,因为宏定义关键字“#define”只是对当前行有效，所以使用续行符来连接 应用续行符的时候要注意，在“\”后面不能有任何字符(包括注释、空格)，只能直接回车。在要强制换行的地方输入反斜杠然后回车 c语言中还有一种拆分字符串的方法，那就是将其写个多个相邻的字符串。这些字符串之间用0个或者多个空白、制作符以及换行符隔开。 printf(&quot;Programming&quot; &quot; in c&quot; &quot; is fun&quot;\n);//Programing in c is fun 1234567printf( &quot; ********\n&quot; &quot; ************\n&quot; &quot; ####....#.\n&quot; &quot; #..###.....##....\n&quot; ); 输入输出 gets()函数并不读取换行符’\n’,它会吧换行符替换成空字符’\0’,作为c语言字符串结束的标志.此时换行符已经没了！！ gets在C99标准中，已经不再建议使用gets()函数，而在C11中更是直接抛弃了这个函数,gets函数没有限制读入的个数，这很可能会导致程序向未知的内存空间写入数据，而导致程序出错。 fgets函数中第二个参数限制了读取的个数，这也解决了gets函数存在的问题，但要注意fgets函数只会读取n-1个字符（如果遇到换行符会更少），并在最后添加字符串结束标志，而且，fgets也会将换行符读入。char *fgets(char *buf, int bufsize, FILE *stream)；注意一下第二个参数bufsize，这个参数就限制了读取的字符的个数，这就可以解决gets()函数的缺陷。我们知道fgets() 函数主要用于读取文件，如果要读取键盘，则stream参数应该为stdin，需要注意的是，如果bufsize设置为n，那么fgets()函数最多读取n-1个字符，之所以用“最多”这个词是因为，如果在之前遇到了换行符，fgets函数也会返回。还有一点就是，fgets()函数会读取换行符（这一点和gets函数不同），当读取结束后，fgets函数会为buf在末尾添加一个空字符作为字符串的结束. scanf函数要实现修改变量值的功能，传地址就相当于传指针（指向一个内存位置）！printf只是对变量值执行输出功能，不涉及改变！ 输入输出返回值 scanf为函数，printf为函数(输入与输出函数)：返回值：scanf 函数的返回值反映的是按照指定的格式符正确读入的数据的个数。如果输入数据与指定格式不符，则会产生输入错误。遇到输入错误，scanf函数会立即终止，返回已经成功读取的数据的个数。所以通过scanf函数的返回值和指定输入数据的个数（由格式符决定）的比较，可以判断数据输入是否成功。 scanf 函数是有返回值的，它的返回值可以分成三种情况 正整数，表示正确输入参数的个数。例如执行 scanf(“%d %d”, &amp;a, &amp;b); 如果用户输入&quot;3 4&quot;，可以正确输入，返回2（正确输入了两个变量）； 如果用户输入&quot;3,4&quot;，可以正确输入a，无法输入b，返回1（正确输入了一个变量）。 0，表示用户的输入不匹配，无法正确输入任何值。如上例，用户如果输入”,3 4”，返回0。如果它没有读取任何项目（当它期望一个数字而你键入的却是了一个非数字的字符或者字符串就会发生这种情况），scanf()返回值0。当它检测到“文件结尾”（end of file）时，它就返回EOF(EOF是文件stdio.h中定义的特殊值-1) EOF，这是在stdio.h里面定义的常量（通常值为-1），表示输入流已经结束(scanf遇到格式不对返回EOF或结束时)(EOF == end of file) ~是按位取反,scanf的返回值是输入值的个数,如果没有输入值就是返回-1,-1按位取反结果是0,while(~scanf(“%d”, &amp;n))就是当没有输入的时候退出循环 printf的返回值是输出的字符数，例如，printf(&quot;1234&quot;)的返回值是4，而printf(&quot;1234\n&quot;)的返回值是5。不知道有木有这样写的习惯while (~scanf(&quot;....&quot;))。这里出现了~这个符号，这个是位运算取反的意思。因为~(n)=-(n+1)。所以这里scanf的返回值为-1时~(-1)=0才退出循环。这就是这样写的意思。 c++输入输出 cout在输出很大的数时,会用科学计数法输出,若不想如此输出，可将原来输出数double类型与float类型改为int类型，或者如下. cout&lt;&lt;std::fixed&lt;&lt; a &lt;&lt;endl; printf(&quot;%.0lf&quot;, a); 当数字过大时可能数字有变化或丢失(自测) fixed后面还可以加格式控制符控制位数，setprecision(n)——设置输出浮点数的精度，配合fixed设定，指的是小数位数，设置setprecision(0)即指输出不带小数位的int值。 还有其它方法！！！ &gt;&gt;运算符返回左边的流对象，也就是说 cin&gt;&gt;val 返回 cin，于是 while(cin&gt;&gt;val) 就等于是 while(cin) cin与scanf scanf是标准输入流，没有缓存区，需要预先分配空间，而cin是输入流，它使用了缓冲区。如果要使用scanf读入字符串，那就一定要事先为它申请足够的内存空间 getline函数C++中有两个getline函数 1.一个是在string头文件中，定义的是一个全局的函数,函数声明是 istream&amp; getline ( istream &amp;is , string &amp;str , char delim );istream&amp; getline ( istream&amp; is, string&amp; str); is 进行读入操作的输入流 str 存储读入的内容 delim 终结符 对于第一个函数delim是可以由用户自己定义的终结符；对于第二个函数delim默认为 ‘\n’（换行符）。 在遇到终结符delim后，delim会被丢弃，不存入str中。在下次读入操作时，将在delim的下个字符开始读入。 这个getline是个全局函数，而不是istream/iostream的成员函数getline。 2. 另一个则是istream的成员函数，函数声明是 istream&amp; getline (char* s, streamsize n ) istream&amp; getline (char* s, streamsize n, char delim ); 注意这个getline是将读取的字符串存储在char数组中而不可以将该参数声明为string类型，因为C++编译器无法执行此默认转换。！ 输入过程中达到n个数或者提前遇到delim，或者文件结束，输入结束 下面看看就行，待续 1、getline读取换行符 并且将换行符替换成’\0’，并且会丢弃换行符，对于getline函数，在函数遇到和结束定界符相等的字符时函数结束，同时函数抽出定界符，此种情况下该定界符既不被放回输入流，也不被放入要生成的字符串 2、cin会把换行符留在输入队列中 3、cin.getline读取换行符并替换成’\0’，并且不会主动丢弃换行符，会把它留在输入队列中 c++cout123456789cout &lt;&lt; "a - b = " &lt;&lt; stringSubString(a, b) &lt;&lt; endl &lt;&lt; "a * b = " &lt;&lt; stringMultString(a, b) &lt;&lt; endl &lt;&lt; "a / b = " &lt;&lt; stringDivString(a, b) &lt;&lt; endl &lt;&lt; "a % b = " &lt;&lt; stringModString(a, b) &lt;&lt; endl &lt;&lt; "gcd(a, b) = " &lt;&lt; stringGcd(a, b) &lt;&lt; endl &lt;&lt; "lcm(a, b) = " &lt;&lt; stringLcm(a, b) &lt;&lt; endl; 输出结果 如果遇到 #INF / inf，就检查是否发生了运算结果溢出除零，而遇到 #IND / nan，就检查是否发生了非法的运算。 nan意思未not a number inf: infinite,无限大输出补零 printfprintf(&quot;0m%d&quot;); cout 输出前面补零,头文件#include &lt;iomanip&gt;, cout &lt;&lt; setw(3) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; a &lt;&lt; endl;默认右对齐(数字在右边) setfill(&#39;c&#39;)c为补充的字符，cout &lt;&lt; setiosflags(ios::left) &lt;&lt; setfill(&#39;#&#39;) &lt;&lt; setw(5) &lt;&lt; 123 &lt;&lt; endl;右端补齐#，123## cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; a &lt;&lt; endl;控制小数点后精度，小数点后四舍五入，无则补零]]></content>
      <categories>
        <category>输入输出</category>
      </categories>
      <tags>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2F2019%2F03%2F04%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原地址 luogu 二分法(折半查找) 将所给关键词和指定有序集合中间数进行比较,如果比较相等则返回结果,如果不相等,则按照所给出的结果,将集合减半后继续查找 二分法是减治法的思想 二分法：(low+high)/2,如果故意卡数据即low与high很大的话,会越界.所以可以为(high - low)/2+low; 有三种: 优化(先确定范围) 插值查找 这里的插值查找法,是对二分法的一种改进.此法和二分法一样对数据要求有序且尽量分布均匀 对于二分法有: mid = (low + high)/2;不难得到 mid = low + 1/2*(high-low);试想,对于在字典中进行查找时,对于’you’或’and’来说,我们通常的处理方法肯定不是从中间开始进行查找,而是根据所给出的值,大致确定范围后再来进行查找.这里的大致范围是通过,所查找的value值在所查集合中所大概处于的位置,定位到后进行比较故有如下公式:key = low + ((value - a[low])/(a[high]-a[low]))*（high-low); 伪代码: 123456789int insertseek(int value,int map[]) int low,high,key; low = 0; high = n -1 ; while(low&lt;=high) key = low + ((value - low)/(high-low))*（high -low); if(key == value) return key; else if(key &lt; value) low = key; else high = key; 例题1234567891011121314151617181920212223242526五：第12周任务-分巧克力时间限制：1秒 内存限制：128兆48 次提交 4 次通过题目描述开学那天有n位计科的新生到ZXF做客。ZXF拿出了珍藏的巧克力招待学弟学妹们。ZXF一共有k块巧克力，其中第i块是Hi * Wi的方格组成的长方形。ZXF需要从这 k 块巧克力中切出n块巧克力分给新生们。为了公平起见，切出的巧克力需要满足：1.形状是正方形，边长是整数2.大小相同例：一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。当然学弟学妹们都希望得到的巧克力尽可能大，你能帮ZXF计算出最大的边长是多少么？输入输入在第一行给出两个正整数k和n（0&lt;=n，k&lt;=1000）。以下k行每行包含两个整数Hi和Wi。(0 &lt;= Hi, Wi &lt;= 1000000) 输入保证每位新生至少能获得一块1x1的巧克力。输出输出切出的正方形巧克力最大可能的边长。样例输入2 106 55 6样例输出2标程：简单的二分搜索暂时可以模仿我这种模板来写，check函数单独分开来写会让代码的思路更加清晰。二分的主体基本不变，都是改变上下界往两边搜索。另外我代码中出现的头文件是一个万能头文件，基本包含了C/C++当中的我们写算法中需要用到的头文件。目前大部分oj都支持，但是也有部分oj和比赛不支持。（比赛慎用！）]]></content>
      <categories>
        <category>算法</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c与c++常用函数]]></title>
    <url>%2F2019%2F03%2F04%2Fc%E4%B8%8Ec-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[常用函数 max, min, fill, memset, sort, swap 字符串函数 字符串比较函数strcmp因为原理是两个字符串一个个比较，所以可以比较字符是否相同！！！！！ 一般形式：strcmp(字符串1，字符串2) 返回值： 当s1&lt;s2时，返回值&lt;0 当s1=s2时，返回值=0 当s1&gt;s2时，返回值&gt;0 如果把序号按字符串存储，则会可以通过strcmp比较序号是否相同。(有用) Strlen函数如果没有遇到’\0’，会一直计算下去，字符串二维数组不可以用strlen，因为二维数组每一行相当于一个字符串一维数组，每一行都有’\0’！ c++标准库里字符串相关函数的声明，凡是不修改内容的地方一律声明为const char *, strlen(const char *),strcmp(const char *, const char *),strcpy(char *, const char *)第一个参数会被修改 strcpy函数 原型声明：char *strcpy(char* dest, const char *src); 功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间 说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。 返回指向dest的指针。对于出现异常的情况ANSI-C99标准并未定义，故由实现者决定返回值，通常为NULL。 tolower函数 定义函数：int tolower(int c); 函数说明：若参数 c 为大写字母则将该对应的小写字母返回。 返回值：返回转换后的小写字母，若不须转换则将参数c 值返回。tolower(s[i]); #include &lt;cctype&gt; fill函数 在头文件&lt;algorithm&gt;里面 按照单元赋值，将一个区间的元素都赋同一个值fill(arr, arr + n, 要填入的内容);vector也可以：fill(v.begin(), v.end(), 要填入的内容); fill 和fill_n函数是C++ Primer第十二章泛型算法部分内容，并把它们称为生成和变异算法，也就是说这两个函数只能对输入范围内已存在的元素进行操作。如果试图对空容器进行fill_n操作，会导致严重的运行错误，所以在对元素进行写入操作时要检查目标的大小是否足以存储要写入的元素。 fill的内部实现就是一个for循环 1234567template&lt; class ForwardIt, class T &gt;void fill(ForwardIt first, ForwardIt last, const T&amp; value)&#123; for (; first != last; ++first) &#123; *first = value; &#125;&#125; 对二维数组 动态分配二维数组是指的new或者malloc申请内存memset函数 1.memeset函数只能对连续的内存空间初始化。两次用malloc函数或new在堆上分的内存可能会不连续，因此错误。 2.如果是直接声明的多维数组如int a[5][5]，其内存肯定是连续的，此时统一memset没问题(动态声明的二维数组不一定内存连续) 123int P[100][100];memset(P, 0, sizeof(P) ) ;//这种直接定义的，可以memeset初始化 memset函数的初始化只能对一维数组或者直接定义的而巍峨数组，对于动态分配的二维数组，对于每一行，是连续分配的； 然而对于各行之间，却不一定是连续分配的，容易出错 fill函数 二维数组初始化(推荐)12345678int mp[20][20];fill(mp[0], mp[0]+20*20, 5);//给二维数初始化for(int i = 0; i &lt; 20; i++)&#123; for(int j = 0; j &lt; 20; j++) cout &lt;&lt; mp[i][j] &lt;&lt; " "; cout &lt;&lt; endl;&#125; 与memset()函数的区别： memset的初始化速度比循环要快很多 fill和for循环事件是一样的 fill的源码就是for循环实现的 两者都可以用来对数组填充，memset是对按照字节来填充的，所以一般用来填充char型数组，也经常用于填充int型的全0或全-1操作。 fill是按照单元来填充的，所以可以填充一个区间的任意值。 fill_n函数 在头文件&lt;algorithm&gt;里。 fill_n(vec.begin, cnt, val);从当前起始点开始，将之后的cnt个元素赋值为val。 注意：不能在没有元素的空容器上调用fill_n()函数 memset函数 在头文件&lt;cstring&gt;里面 memset的作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法 Memset函数:可以本身就是为字符数组设计的源代码：unsigned int 有一个特性就是如果将其赋值或者当作字节来使用的话，编译器将会截取低八位作为一个字节使用。 1234567 void *(memset)(void *s, int c, size_t n)&#123; const unsigned char uc = c; unsigned char *su; for (su = s; 0 &lt; n; ++su, --n) *su = uc; return (s);&#125; 源码说明对于数组参数是按照字符数组的形式进行赋值的。也就是c的值每次赋值给一个字节，而不是4个字节，c的类型是int类型，4个字节，但只会赋值最低位的一个字节的内容。 对于非单字节数据类型只能初始化为0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值0的结果都是0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果。 对于变量：当结构体类型中包含指针时，在使用memset初始化时需要小心。struct sample_strcut stTest;用memset就非常方便：memset(&amp;stTest,0,sizeof(struct sample_struct));原因是memset初始化的时候是按字节一个一个填充的，int有四个字节，于是填充成0000 0001 0000 0001 0000 00001 0000 0001，这样得出数组中的每个元素的值就是16843009了。赋值时0与\0效果一样。 可以用于清空数组内元素与赋,memset函数一般用来填充char型数组,也经常用于填充int型的全0或全-1.不可用其它值，除非高低字节相同.- 123#define INF 0x3f3f3f3fint num[N];memset(num, INF, sizeof(num)); 这样得到的数组里面的每一个元素数值都是INF看一下INF的二进制表示：00111111001111110011111100111111可以看出低8位是00111111，也就是实际赋值时是用00111111来填充一个int类型，结果正好也是00111111001111110011111100111111于是就成功用memset进行了赋值。 初始化与赋值 memset()的深刻内涵：用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化 例如：memset(a,&#39;\0&#39;,sizeof(a) ); 对字符串数组 123char a[5];memset(a, '1', 5);// 数组a 是字符型的，字符型占据内存大小是1Byte，而 memset 函数也是以字节为单位进行赋值的 对bool型数组赋值： 1234const int N = 11;bool arr[N];memset(&amp;arr, 1, sizeof(bool) * N);//bool类型就是1或0. 对结构体 12345678910111213141516171819202122232425262728//有一个结构体Some x，可以这样清零：memset(&amp;x, 0, sizeof(Some));//如果是一个结构体的数组Some x[10]，可以这样：memset(x, 0, sizeof(Some)*10);//memset可以方便的清空一个结构类型的变量或数组。如：struct sample_struct&#123; char csName[16]; int iSeq; int iType;&#125;;//对于变量struct sample_strcut stTest;//一般情况下，清空stTest的方法：stTest.csName[0]=&#123;'\0'&#125;;stTest.iSeq=0;stTest.iType=0;//如果用memset的话非常方便：memset(&amp;stTest, 0, sizeof(struct sample_struct));//如果是数组：struct sample_struct TEST[10];memset(TEST, 0, sizeof(struct sample_struct)*10）；//另外：如果结构体中有数组的话还是需要对数组单独进行初始化处理的 INF小知识 0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。 最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。所以在通常的场合下，const int INF = 0x3f3f3f3f;真的是一个非常棒的选择。 因为在某些编译器分配空间时,内存中默认值并不为0,所以先用memset函数赋初值0. 转换函数atoi()函数 用来将字符串转换成整数(int)：int atoi (const char * str); 【返回值】返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。 atoi() 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;\0&#39;)才结束转换，并将结果返回。 Enter a number: 233cyuyan The value entered is 233. atol函数 定义函数：long atol(const char *nptr); 函数说明： atol()会扫描参数nptr字符串，跳过前面的空格字符(就是忽略掉字符串左空格的意思)，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回。 返回值：返回转换后的长整型数。如果传入的字符串为空，或者字符串包含的内容非阿拉伯数字序列，则函数返回默认值0。与stoi区别 stoi用于string类 stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！而atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界； atof函数 定义函数 double atof(const char *nptr); 函数说明 atof()会扫描参数nptr字符串，跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;\0&#39;)才结束转换，并将结果返回。参数nptr字符串可包含正负号、小数点或E(e)来表示指数部分，如123.456或123e-2。 返回值:函数返回转换后的双精度浮点数，如果没有执行有效的转换，则返回零（0.0）。 范例：12345678910#include&lt;stdlib.h&gt;int main()&#123; char*a="-100.23"; char*b="200e-2"; double c; c=atof(a)+atof(b); printf(“c=%.2lf\n”,c); return 0;&#125; memcpy void *memcpy(void*dest, const void *src, size_t n); 用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度： 123char a[100], b[50];memcpy(b, a, sizeof(b) ); //注意如用sizeof(a)，会造成b的内存地址溢出 说明 source和destin所指内存区域不能重叠，函数返回指向destin的指针。 与strcpy相比，memcpy并不是遇到’\0’就结束，而是一定会拷贝完n个字节。]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基础 二进制不能表示所有的小数，他只是选一个离需表示值的最近的一个数进行储存而已。 首先，在计算机中所有数据都是用一个一个的二进制位（0或1）存储的，单位称为：位（bit）；然后，每8位二进制数（比如01010001）代表一个字节(byte)大小，即1字节=8位；再然后，C语言每个数据类型都是有固定字节大小的，比如char类型是一个字节即8位，而int类型的大小与具体计算机cpu的机器字长有关，如果是16位cpu，int类型就是2字节=16位大小，如果是32位cpu，int类型就是4字节=32位大小；最后，每个数据类型的取值范围就是由其字节大小决定的，如char类型的取值范围是-2^7 ~ 2^7-1（涉及到二进制数与十进制数之间的转换方面的知识，此处不再讲，详情可查阅相关进制换算资料）。 数据类型，指针字节大小与编译器有关，指针还与其它因素有关（笔记本上）数据类型 输出有e时,可能是输出变量类型float,double的问题，可改为int其它类型试试 int类型不会出现浮点数,不要用int型存计算结果的浮点数 short的取值范围为-32768~32767（-2的15次方到2的15次方-1） int的取值范围为（-2147483648~2147483647）（-2的31次方到2的31次方-1） 1234567891011121314151617符号属性 长度属性 基本型 所占位数 取值范围 输入符举例 输出符举例无 无 char 8 -2^7 ～ 2^7-1 %c %c、%d、%u signed 无 char 8 -2^7 ～ 2^7-1 %c %c、%d、%u unsigned 无 char 8 0 ～ 2^8-1 %c %c、%d、%u [signed] short [int] 16 -2^15 ～2^15-1 %hd %hd unsigned short [int] 16 0 ～2^16-1 %hu、%ho、%hx %hu、%ho、%hx[signed] 无 int 32 -2^31 ～ 2^31-1 %d %d Unsigned 无 [int] 32 0 ～ 2^32-1 %u、%o、%x %u、%o、%x[signed] long [int] 32 -2^31 ～ 2^31-1 %ld %ldunsigned long [int] 32 0 ～ 2^32-1 %lu、%lo、%lx %lu、%lo、%lx[signed] longlong [int] 64 -2^63 ～ 2^63-1 %I64d %I64dunsigned longlong [int] 64 -2^63 ～ 2^63-1 %I64d %I64d unsigned longlong [int] 640 ～ 2^64-1 %I64u、%I64o、%I64x %I64u、%I64o、%I64x无 无 float 32 +/-3.40282e+038 %f、%e、%g %f、%e、%g 无 无 double 64 +/-1.79769e+308 %lf、%le、%lg %f、%e、%g 无 long double 96 +/- 1.79769e+308 %Lf、%Le、%Lg %Lf、%Le、%Lg 将char/signed char转换为int时，会对最高符号位1进行扩展，从而造成运算问题。所以,如果要处理的数据中存在字节值大于127的情况，使用unsigned char较为妥当。程序中若涉及位运算，也应该使用unsigned型变量。 c中规定除法相除必须是整数，但表达式存在自动转换，若两个数字都为int，将其中一个数字强制类型转换为浮点数，即可保留小数 数组范围 函数内申请的变量，数组，是在栈（stack）中申请的一段连续的空间。栈的默认大小为2M或1M，开的比较小。 全局变量，全局数组，静态数组（static）则是开在全局区（静态区）（static）。大小为G单位，所以能够开的很大。 如int num[900][900]; 计算公式：900 900sizeof(int)/1024 = 3164KB=3MB &gt; 2MB所以溢出 而malloc、new出的空间，则是开在堆（heap）的一段不连续的空间。理论上则是硬盘大小。]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作4]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C4%2F</url>
    <content type="text"><![CDATA[图片插入 将markdown需要用的图片放到git仓库中，发布到github上 访问图片,点 download 按钮，页面打开后,在地址栏可以复制图片地址，或者在Download按钮上直接右键 “复制链接地址” TOC数字块👇1. 左边为效果2. 左边为效果]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作3]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C3%2F</url>
    <content type="text"><![CDATA[反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 文字增加背景色块 在你需要编辑的文章地方。放置如下代码： 站点配置文件 主题配置文件 站点配置文件 主题配置文件 主题自带样式FontAwesome(以下图标必须在网页上方点击全部显示才能显示即受保护的内容) fa-lg fa-2x fa-3x fa-4x fa-5x note标签 在主题配置文件_config.yml里有一个关于这个的配置,需要提前设置. default primary success info warning danger danger no-icon]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作2]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C2%2F</url>
    <content type="text"><![CDATA[Front-matter description是文章的描述,在每篇文章标题下方显示，也可以用表情😄 有date,tags,categories,comments,password(要配置),keywords,updated layout页面布局，默认为post,有draft(草稿)和page 符号 : 为英文符号,格式很重要,不管是主题配置文件还是站点配置文件中空格,不空格都有要求 permalink若站点配置文件下的 permalink 配置了 title 则可以替换文章 URL 里面的 title（文章标题） 还有photos,link,image,sticky(后面2个要配置) 若创建文章时标题错误,可在编辑md文件时通过titile修改,文件重命名没用 格式一定要正确,有时可能没识别出来,要重新输入]]></content>
      <categories>
        <category>blog</category>
        <category>文章模板</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作]]></title>
    <url>%2F2019%2F02%2F28%2Fblog%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[hexo博客写作 若layout为draft,那么静态页面不会渲染生成。 符号-、1.和文本之间要保留一个字符的空格. 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。如果不空格,标题无法显示。 引用符号&gt; 和文本之间要保留一个字符的空格 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。例如：一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 Markdwon 文档写完一段回车后务必再回车一次空一行！ 需要引用代码时，如果引用的语句只有一段，不分行，可以用符号` 将语句包起来。 如果引用的语句为多行，可以将`置于这段代码的首行和末行， markdown快速键入 mdi + tab键：插入图片mdl + tab键: 插入链接mdc + tab键：插入代码mdh1 + tab键：插入一级标题，2就是二级标题…… 引用 在引用内再次引用的话，只需要敲下回车然后加两个大于号「&gt;&gt;」就好了，如果想要在引用内的引用继续引用的话（喘口气先）那就加三个大于号「&gt;&gt;&gt;」。例如： 有一天小美睡不着，她就缠着小最给她讲故事，于是小最就给她讲了一个故事： 很久以前有只小美睡不着，要小最给她讲故事，小最就给她讲了下面这个故事： 很久以前有只小美睡不着，要小最给她讲故事，小最就给她讲了下面这个故事： ……]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
