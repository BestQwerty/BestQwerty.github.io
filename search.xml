<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[matlab实用命令]]></title>
    <url>%2F2019%2F03%2F31%2Fmatlab%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[在命令行敲入 dbstop if error如果运行出现错误，matlab会自动停在出错的那行，并且保存所有相关变量。再也不用设断点了有没有！！！ 若要取消，用dbclear if error 现在版本在断点选项里自带]]></content>
      <categories>
        <category>matlab</category>
        <category>实用命令</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五周周总结]]></title>
    <url>%2F2019%2F03%2F30%2F%E7%AC%AC%E4%BA%94%E5%91%A8%E5%91%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>五日三省吾身</category>
        <category>周总结</category>
      </categories>
      <tags>
        <tag>吾日三省吾身</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab代码练习]]></title>
    <url>%2F2019%2F03%2F30%2Fmatlab%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[S]]></content>
      <categories>
        <category>matlab</category>
        <category>代码练习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构栈]]></title>
    <url>%2F2019%2F03%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[c++stackk]]></title>
    <url>%2F2019%2F03%2F30%2Fc-stackk%2F</url>
    <content type="text"><![CDATA[基本操作 出栈，如例：s.pop();注意，出栈操作只是删除栈顶元素，并不返回该元素]]></content>
      <categories>
        <category>stl</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab绘图]]></title>
    <url>%2F2019%2F03%2F28%2Fmatlab%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[绘图基础 可以直接在图形窗口上修改图形 如果当前不存在图形窗口，MATLAB 的绘图函数会自动 建立一个新的图形窗口；如果已存在一个图形窗口，MATLAB 的绘图函数就会在这个窗口 中进行绘图操作；如果已存在多个图形窗口，MATLAB 的绘图函数就会在当前窗口中进行 绘图操作(当前窗口通常是指后一个使用的图形窗口)。 matlab绘图是将图形每一个点标出后连接而成，因为横坐标间隔值不一定相同，所以2个图形相交y值不一定相等，找交点s=find(abs(y1-y2)&lt;0.01))其中0.01设置具体看横坐标间隔值大小，否侧可能找不到 plot函数维度必须相同，因为图形是将点连接起来，所以x与y个数维度必须相同 plot函数可以标点！画点(因为画图是画点再连接起来) 注意： 如果已经存在一个图形窗口，plot命令则清除当前图形，绘制新图形 可任意设定曲线颜色和线型 可给图形加坐标网线和图形加注功能 12345678910111213141516171819202122232425 clc,clear; close all; x1=[0:0.1:4]; y1 = sqrt(x1); x2=[4:0.1:6] y2 = 2*ones(1,21); %注意这里如果是直接写2，因为plot画图是多个点连接，y2只有一个值，所以要创建与x2横坐标相同维度的y2 x3 = [6:0.1:8]; y3 = 5-x3/2; y4 = 1; plot(x1,y1); hold on plot(x2,y2); hold on plot(x3,y3); hold on plot([8:0.1:10],y4);``` ## 命令行- &lt;span id=&quot;inline-toc&quot;&gt;1.&lt;/span&gt;hold on: hold on retains plots in the current axes so that new plots added to the axes do not delete existing plots. New plots use the next colors and line styles based on the ColorOrder and LineStyleOrder properties of the axes. MATLAB® adjusts axes limits, tick marks, and tick labels to display the full range of data. - hold on保留当前坐标轴中的绘图，这样添加到坐标轴中的新绘图就不会删除现有的绘图。新绘图使用基于坐标轴的ColorOrder和LineStyleOrder属性的下一种颜色和线条样式。MATLAB®调整坐标轴限制、刻度标记和刻度标签，以显示全部数据范围。 - x = linspace(-pi,pi); y1 = sin(x); y2 = cos(x); plot(x,y1) hold on plot(x,y2) 12345678910111213141516171819- &lt;span id=&quot;inline-toc&quot;&gt;2.&lt;/span&gt;`close all;`关闭所有图形窗口# 图形标注- 有关图形标注函数的调用格式为 - `title(‘图形名称’)` - `xlabel(‘x轴说明’)` - `ylabel(‘y轴说明’)` - `text(x, y, ‘图形说明’)` %在坐标位置(x,y)处添加文字“图形说明” - `legend(‘图例1’, ‘图例2’, …)` - legend函数用于对绘制曲线所用线型、颜色或数据点标记作图例说明，放置在空白处，可以通过鼠标移动图例，将其拖放到其它位置。部分函数同样适用于三维图形，在三维图中z坐标轴说明用zlabel函数。 # 函数- 将标题、坐标轴标记、网格线及文字注释加注到图形上，这些函数为： title —— 给图形加标题 xlable —— 给x轴加标注 ylable —— 给y轴加标注 text —— 在图形指定位置加标注 gtext —— 将标注加到图形任意位置 grid on(off) —— 打开、关闭坐标网格线 legend —— 添加图例 axis —— 控制坐标轴的刻度 1- clc;clear; t=0:0.1:10; y1=sin(t); y2=cos(t); plot(t,y1,&apos;r&apos;,t,y2,&apos;b--&apos;); x=[1.7*pi;1.6*pi]; y=[-0.3;0.8]; s=[&apos;sin(t)&apos;;&apos;cos(t)&apos;]; text(x,y,s); title(&apos;正弦和余弦曲线&apos;); legend(&apos;正弦&apos;,&apos;余弦&apos;) xlabel(&apos;时间t&apos;) ylabel(&apos;正弦、余弦&apos;) grid axis square 123456789101112131415- ![](https://raw.githubusercontent.com/ctguljj/ctguljj.github.io/master/images/plot绘图.png)# find函数# plot函数- 若用一个plot函数画多个图时，横坐标维度必须一致- `plot(x,y,’s’)` —— 开关格式，开关量字符串s设定曲线颜色和绘图方式，如: `plot(x1,y1,’y*’,x2,y2,’rO’，…)` - S的标准设定值如下： 字母 颜色 标点 线型 y 黄色 · 点线 m 粉红 ○ 圈线 c 亮蓝 × ×线 r 大红 ＋ ＋字线 g 绿色 － 实线 b 蓝色 * 星形线 w 白色 ： 虚线 k 黑色 －· (--) 点划线 v 下三角 ^ 上三角 &lt; 左三角 &gt; 右三角 square 正方形 diamond 菱形 pentagram 五角星 hexagram 六角星 12345678910``` t=0:pi/100:2*pi; y=sin(t); y1=sin(t+0.25); y2=sin(t+0.5); y3=cos(t); y4=cos(t+0.25); y5=cos(t+0.5); plot(t,[y&apos;,y1&apos;,y2&apos;,y3&apos;,y4&apos;,y5&apos;]) plot(X,Y,’S’)命令 X,Y为同维向量时，绘制以X,Y元素为横、纵坐标的曲线； X是向量，Y是有一维与X等维的矩阵时，则绘制出多根不同色彩的曲线. 曲线数等于Y矩阵的另一维数，X被作为这些曲线的共同横坐标； X是矩阵，Y是向量时，情况与上面的相同，只是曲线都以Y为共同纵坐标； X,Y为同维矩阵时，则以X、Y对应列元素为横、纵坐标分别绘制曲线，曲线条数等于矩阵的列数. plot(X1,Y1,S1,X2,Y2,S2,X3,Y3,S3,)命令 在这个格式中，每一个“三元组”(X,Y,’S’)的结构和作用与plot(X,Y,’S’)相同. 不同的三元组之间没有约束关系. plot(x,y)——x,y为长度相同的向量，存储x坐标和y坐标用于绘制二维平面上的直角坐标图，以x为横坐标，y为纵坐标的二维曲线。 多窗口绘图 figure(n) —— 创建窗口函数，n为窗口顺序号。 12345678t=0:pi/100:2*pi;y=sin(t);y1=sin(t+0.25);y2=sin(t+0.5);plot(t,y) —— 自动出现第一个窗口figure(2)plot(t,y1) —— 在第二窗口绘图figure(3)plot(t,y2) ——在第三窗口绘图 符号函数(显函数、隐函数和参数方程)画图 ezplot ezplot(‘f(x)’,[a,b]) 表示在a&lt;x&lt;b绘制显函数f=f(x)的函数图。 ezplot(&#39;f(x,y)&#39;,[xmin,xmax,ymin,ymax]) 表示在区间xmin&lt;x&lt;xmax和 ymin&lt;y&lt;ymax绘制隐函数f(x,y)=0的函数图。 ezplot(&#39; x(t) &#39;, &#39; y(t) &#39;,[tmin,tmax]) 表示在区间tmin&lt;t&lt;tmax 绘制参数方程x=x(t),y=y(t)的函数图。 ezplot函数：ezplot函数可以绘制符号函数的简易二维图形，其使用格式如下： 1）ezplot(f)命令，对于显式函数f=f(x)，在默认的范围[-pi,pi]上绘制该函数f=f(x)的图形；对于隐函数f(x,y)=0，在默认的平面区域[-2*pi&lt;x&lt;2*pi, -2*pi&lt;y&lt;2*pi]上绘制该函数f(x,y)=0的图形。 2） ezplot(x,y)命令，在默认的范围[0&lt;t&lt;2*pi]内绘制参数形式函数x=x(t)与y=y(t)的图形。 3）ezplot(f,[a,b])命令，在指定的范围[a&lt;x&lt;b,a&lt;y&lt;b]内绘制表达式为f=f(x)的显式函数图形。 4）ezplot(f,[xmin,xmax,ymin,ymax])命令，在平面矩形区域[xmin&lt;x&lt;xmax,ymin&lt;y&lt;ymax]上绘制隐函数f(x,y)=0的图形。 5）ezplot(x,y,[tmin,tmax])命令，在指定的范围[tmin&lt;t&lt;tmax]内绘制参数形式的函数x=x(t)与y=y(t)的图形。 画隐函数ezplot的调用格式： ezplot(f)—这里f为包含单个符号变量x的符号表达式，在x轴的默认范围[-2pi 2pi]内绘制f(x)的函数图 ezplot(f,xmin,xmax) — 给定区间 ezplot(f,[xmin,xmax],figure(n)) — 指定绘图窗口绘图。 坐标控制 axis的用法有： axis([xmin xmax ymin ymax]) —— 用行向量中给出的值设定坐标轴的最大和最小值。 如axis ([-2 2 0 5]) axis(equal) —— 纵横坐标轴采用等长刻度 axis on(off) —— 显示和关闭坐标轴的标记、标志 axis auto —— 将坐标轴设置返回自动缺省值 axis SQUARE设置当前图形为正方形（或立方体形),axis square刻度范围不一定一样，但是一定是方形的 axis equal将横轴纵轴的定标系数设成相同值,axis equal刻度是等长的，但也不一定是方形的。 给坐标加网格线可以用grid命令来控制，grid on/off命令控制是否添加网格线，不带参数的grid命令在两种之间进行切换。]]></content>
      <categories>
        <category>matlab</category>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab字符串]]></title>
    <url>%2F2019%2F03%2F27%2Fmatlab%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串 字符串是用单引号括起来的字符集合，可以像向量一样进行拼接和裁剪。 1234Eg：&gt;&gt;s1=&apos;Hello&apos;;s2=&apos;every&apos;;s3=&apos;body&apos;; s=[s1,&apos; &apos;,s2,&apos; &apos;,s3] ss=s(1:5)]]></content>
      <categories>
        <category>matlab</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab矩阵以及常用函数]]></title>
    <url>%2F2019%2F03%2F27%2Fmatlab%E7%9F%A9%E9%98%B5%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数调用` 调用函数文件的一般格式为 [输出参数表]=函数名(输入参数表) 调用函数时应注意： 当调用一个函数时，输入和输出参数的顺序应与函数定义时的一致，其数目可以 按少于函数文件中所规定的输入和输出参数调用函数，但不能使用多于函数文件所规定的 输入和输出参数数目。如果输入和输出参数数目多于或少于函数文件所允许的数目，则调 用时自动返回错误信息。 当函数有一个以上输出参数时，输出参数包含在方括号内。例如，[m,n]=size(x)。 注意：[m,n]在左边表示函数的两个输出参数 m 和 n；不要把它和[m,n]在等号右边的情况混 淆，如 y=[m,n]表示数组 y 由变量 m 和 n 所组成。 矩阵 矩阵里面元素可以是符号与字符（‘a’,’,’）,输入的元素维度要一样 矩阵里面的元素也可以是矩阵，但是矩阵长度维度必须与其它元素相同 - 生成10*10的矩阵可以如下：`a = [1:10;11:20;21:....];` - 对矩阵a第一行后面2个赋予其他值(灵活运用：) 123456 a = [1 2 3 4 7 8 1 2 5]; a(1,2:3) = x; - 对一个矩阵A赋值提取可以取出然后赋给一个小矩阵a 矩阵的下标也可以是向量。 例如 b=a(x,y)；可以得到一个矩阵 b。a 的行标来自向量 x，而列标来自向量 y。 例如，矩阵 a 有 n 列，那末 b=a(:,n:-1:1) 将得到矩阵 b，它等于矩阵 a 按列的逆序排列。 a(end:-1:end-5, 3)是最后一行到倒数第6行的所有第三个元素 删除矩阵某行某列a(i,j)=[]; 如果要将一个矩阵存储在计算机中，MATLAB 规定矩阵元素在存储器中的存放次序是 按列的先后顺序存放，即存完第 1 列后，再存第 2 列，依次类推 作为矩阵的特例，一维数组或者说向量元素是依其元素本身的先后次序进行存储的。 必须指出，不是所有高级语言都这样规定矩阵(或数组)元素的存储次序，例如 C 语言 就是按行的先后顺序来存放数组元素，即存完第 1 行后，再存第 2 行，依次类推。记住这 一点对正确使用高级语言的接口技术是十分有益的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 clc; clear; a=[2 5 6 9 8 86 4 5 6 65 3 54]; m=a(1); for i=1:12 if a(i)&gt;m m=a(i); end end m a=[1,2,3,4,5,6,7]; for i=1:7 a(i)=a(i)+1; end clc,clear A=[0.5,1.732,0.618,3.1415,1.6,0.9]; for i=1:6 for j=i:6 if a(j)&lt;a(i) a(i)=a(i)+a(j); a(j)=a(i)-a(j); a(i)=a(i)-a(j); end end endclc,clearfor i=1:15 for j=1:15 if i+j==15&amp;&amp;4*i+2*j==40 fprintf(‘兔%d只,鸡%d只\n’,i,j); end endend 矩阵除法 矩阵旋转 对于函数rot90顺时针旋转90度，可以rot90(a,3);或者rot90(a,-1); reshape函数 size函数 函数diag 1. diag函数：sum(diag(a)+diag(a&#39;))可以求矩阵a对角线上的元素之和，不过中间的一个元素会提取2次，diag(a’)可以提取副对角线的元素(先将矩阵转置） 当Random是向量时，才构成对角矩阵，当Random是m×n矩阵时，得到的是个向量。比如diag([1 3;2 4])得到向量，diag([1 3])得到2×2矩阵。 可以用来访问对角元素max MAX 函数的几种形式 (1)max(a) (2)max(a,b) (3)max(a,[],dim) (4)[C,I]=max(a) (5)[C,I]=max(a,[],dim) (1)max(a)如果 a 是一个矩阵，比如 a=[1,2,3;4,5,6] ，max(a)的意思就是找出矩阵每列的最大值， 本例中：max(a)=[4,5,6] (2)max(a,b)如果 a 和 b 都是大于 1 维的矩阵，那么要求 a 和 b 的行列的维数都要相等，函数的结 果是比较 a 和 b 中每个元素的大小，比如：a=[1,2,3;4,5,6] b=[4,5,6;7,8,3]max(a,b)=[4,5,6;7,8,6]另外，如果 a 和 b 中至少有一个是常数，也是可以的。比如：a=[1,2,3;4,5,6] b=3 c=5max(a,b)=[3,3,3;4,5,6]相信大家看了例子都明白了函数的意思了吧max(b,c)=5 ` (3)max(a,[],dim)这个函数的意思是针对于 2 维矩阵的，dim 是英文字母 dimension 的缩写，意思是维数。当 dim=1 时，比较的 a 矩阵的列，也就是和 max（a）的效果是一样的；当 dim2 时，比较的 是 a 矩阵的行。下面举个例子：a=[1,2,3;4,5,6] max(a)=max(a,[],1)=[4,5,6] 比较的第一行和第二行的值max(a,[],2)=[3,6] (4)[C,I]=max(a)C表示的是矩阵 a 每列的最大值， I 表示的是每个最大值对应的下标：下面举例说明：还是刚才那个例子：a=[1,2,3;4,5,6] [C,I]=max(a)结果显示的是 C=[4,5,6] I=[2,2,2] 返回的是最大值对应的行号。 (5)[C,I]=max(a,[],dim)同理：如果 dim=1 时，其结果和[c,i]=max(a) 是一样的。当 dim=2 时，同样上面的矩阵 a，我们运行一下：[c,i]=max(a,[],2) 结果是：c=[3,6] i=[3,3] i 返回的是矩阵 a 的列号。 matlab中的sort函数 sort(c)从小到大 sort(c, &#39;descend&#39;)逆序排列(从大到小). MATLAB判断一个数是否整数12345if x==fix(x)% x为整数%fix（x)为取整 end mod函数 b = mod(a,m)返回a除以m后的余数，其中a是被除数，m是除数。这个函数通常称为模运算，使用b = a - m.*floor(a /m)计算。mod函数遵循mod(a,0)返回a 常用函数 取整 fix:向零取整 ceil:向上取整 floor:向下取整 round:四舍五入 取余 rem:带符号 mod:不带符号 匿名函数 格式：函数句柄变量=@（匿名函数输入参数）匿名函数表达式123456789EG:f1=@(x,y)x^2+y^2;f1(3,4)ans = 25 自定义函数1234567891011121314151617181920212223242526272829303132一：function 输出形参表=函数名（输入形参表）注释（对这个函数的解释说明）函数体语句EndEG:圆的周长和面积function [s,c]=circle(r)%求圆的周长和面积c=2*pi*r;s=pi*r^2;End[s,c]=circle(3)%保存好函数文件，在命令行窗口或另一个脚本里调用二:function 函数名注释（对这个函数的解释说明）函数体语句endEG:最强代号function CTGUMCMaxis off; %关闭坐标轴%Menubar是菜单条 none就是不显示图上方的菜单条set(gcf,&apos;menubar&apos;,&apos;none&apos;,&apos;toolbar&apos;,&apos;none&apos;,&apos;unit&apos;, &apos;normalized&apos;, &apos;position&apos;, [0,0,1,1]);for k=1:377 h=text(rand, rand, ... [&apos;\fontsize&#123;&apos;,num2str(unifrnd(5,77)),&apos;&#125; CTGU MCM&apos;],... &apos;color&apos;,rand(1,3),&apos;Rotation&apos;,360*rand); pause(0.2);end squareform与pdistfind函数 find()函数的基本功能是返回向量或者矩阵中不为0的元素x的位置索引。(从1开始)a = find(X) 返回前N个非零元素的位置find(A,X)与ind = find(X, k, &#39;first&#39;) 返回最后x个非零值的位置find(A,x,,’last’) 需要找到其中满足一定条件的元素a = find(x == 4)]]></content>
      <categories>
        <category>matlab</category>
        <category>矩阵以及常用函数</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab代码练习17]]></title>
    <url>%2F2019%2F03%2F27%2Fmatlab%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A017%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[matlab代码练习2018]]></title>
    <url>%2F2019%2F03%2F27%2Fmatlab%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A02018%2F</url>
    <content type="text"><![CDATA[A题 编程将输入的一个n位整数按由小到大的顺序输出。如输入78945，则输出45789。 12345678910111213141516171819 clc,clear;a = input(&apos;please input a number：&apos;);aa = num2str(a);b = length(aa);c = zeros(1,b);result = 0;for i=1:b d = mod(a,10); c(i) = d; a = (a-mod(a,10))/10;endc = sort(c);for j=1:b result = c(j) + result*10;endfprintf(&apos;The answer is :%d\n&apos;,result) 在同一坐标系中作出以下式子表示的图形x^2+y^2=1,y=x^2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 法一 clc,clear; syms x f1 = &apos;x^2+y^2-1&apos;; f2 = &apos;y-x^2&apos;; ezplot(f1, [-1 1] , [-1 1]); hold on ezplot(f2, [-1 1] , [-1 1]); %法二 clc,clear; x=-1:0.01:1; for i=1:length(x) y1(i)=sqrt(1-x(i)^2); y2(i)=-sqrt(1-x(i)^2); y3(i)=x(i)^2; end plot(x,y1,&apos;b&apos;,x,y2,&apos;b&apos;,x,y3,&apos;b&apos;) %法三 clc,clear; x=-1:0.01:1; y1=sqrt(1-x.^2); y2=-sqrt(1-x.^2); y3=x.^2; plot(x,y1,&apos;b&apos;,x,y2,&apos;b&apos;,x,y3,&apos;b&apos;) ``` # C题- 第4题 % 4、三对新人参加婚礼，其中新郎为A、B、C，新娘为X、Y、Z，某人不知道他们谁和谁结婚，于是分别问了其中的三位，得到如下回答： % A:我将和X结婚； % X:我将和C结婚； % C:我将和Z结婚。 % 已知他们三人都在说谎，请编程找出谁将和谁结婚。（20分） %X-B C-Y A-Z %设A B C于其结婚对象分别设为1 2 3。 clc,clear; A=1;B=2;C=3; for i=1:3 for j=1:3 for z=1:3 if i~=A&amp;&amp;i~=C&amp;&amp;z~=C&amp;&amp;i~=j&amp;&amp;i~=z&amp;&amp;j~=z X = i; Y = j; Z = z; break end end end end D=[X Y Z];d=[&apos;X&apos; &apos;Y&apos; &apos;Z&apos;]; m=find(D==A); n=find(D==B); v=find(D==C); fprintf(&apos;与A结婚的是%s\n&apos;,d(m)) fprintf(&apos;与B结婚的是%s\n&apos;,d(n)) fprintf(&apos;与C结婚的是%s\n&apos;,d(v)) 12- 第五题 % a = [17,8,11,22,3,27,4; % 41,3,19,5,13,11,7; % 8,14,21,18,14,16,23; % 31,22,4,25,9,15,17; % 13,24,21,6,17,22,31; % 11,2,34,15,22,4,13; % 16,3,7,19,13,27,21;]; % （1）求这个矩阵四周元素的均值，并将它们删除。（10分） % （2）重复（1）的操作直到只剩下一个元素。（20分） %第二问 %% %先保存函数再调用主函数 function b=myfunction(a) [m,n]=size(a); b=a(2:m-1,2:n-1); end %% %主函数 clc,clear; a = [17,8,11,22,3,27,4; 41,3,19,5,13,11,7; 8,14,21,18,14,16,23; 31,22,4,25,9,15,17; 13,24,21,6,17,22,31; 11,2,34,15,22,4,13; 16,3,7,19,13,27,21;]; c=length(a); while c~=1 a=myfunction(a); c=length(a); end fprintf(&apos;the answer is %d\n&apos;,a) %法二 clc,clear; a = [17,8,11,22,3,27,4; 41,3,19,5,13,11,7; 8,14,21,18,14,16,23; 31,22,4,25,9,15,17; 13,24,21,6,17,22,31; 11,2,34,15,22,4,13; 16,3,7,19,13,27,21;]; c=length(a); while c~=1 [m,n]=size(a); a=a(2:m-1,2:n-1); c=length(a); end fprintf(&apos;the answer is %d\n&apos;,a) `]]></content>
      <categories>
        <category>matlab</category>
        <category>代码练习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈代码练习]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%A0%88%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[链表c练习]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%93%BE%E8%A1%A8c%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hexo特殊字符]]></title>
    <url>%2F2019%2F03%2F22%2Fhexo%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[因为特殊字符，报了一下错误1234FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 5, Column 29] 从宇宙大爆发开始找错误，不过还好没浪费多少时间.记忆深刻，写个blog冷静一下 特殊字符 hexo特殊字符尽量减少使用，可能在转义时发生错误！如： 2个大括号连在一起！！！！！！！！！！！！！或者中括号！！]]></content>
      <categories>
        <category>blog</category>
        <category>特殊字符</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[二维数组 二维数组的初始化分为两种，一种是顺序初始化，一种是按行初始化 所谓按顺序初始化就是先从左向右再由上而下地初始化，即第一行所有元素都初始化好以后再对第二行初始化。而按行初始化则是用一对大括号来表示每一行，跳过前一行没有初始化的元素，在行内从左向右地进行初始化。 int array1[3][2]={4,2,5,6}; 顺序初始化 int array2[3][2]={ {4,2},{5},{6} }; 按行初始化 对于没有初始化的元素，则都是一个不确定的值。 内存是依靠地址来确定内存中的唯一一个存储单元的，即只有一个参数。所以在内存中，所有的数据都是像一维数组那样顺序存储的。 在内存中，先将二维数组的第一行按顺序存储，接着就是第二行的数据，然后是第三行的数据……右图（图7.4）所示的就是一个二维数组在内存中的存储情况。 在某些情况下，不能使用二维数组，或者难以制造一个二维数组。二维数组在内存中的存储情况和一维数组是相同的，所以我们只好用一个一维数组来代替它了。一个二维数组元素a[x][y]在一维数组b中，是： a[x][y]=b[x*列数+y]]]></content>
      <categories>
        <category>c++</category>
        <category>基础知识</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bfs的神奇]]></title>
    <url>%2F2019%2F03%2F20%2Fbfs%E7%9A%84%E7%A5%9E%E5%A5%87%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[dfs的奥妙]]></title>
    <url>%2F2019%2F03%2F20%2Fdfss%E7%9A%84%E5%A5%A5%E5%A6%99%2F</url>
    <content type="text"><![CDATA[dfs模板 DFS的重要点在于状态回溯 判出口（终点、越界）-&gt; 剪枝-&gt;扩展-&gt;标记-&gt;递归-&gt;还原 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void dfs()//参数用来表示状态 &#123; if(到达终点状态) &#123; ...//根据题意添加 return; &#125; if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式) &#123; if(扩展方式所达到状态合法) &#123; 修改操作;//根据题意来添加 标记； //标记可以再开一个另外的数组进行标记 dfs（）； (还原标记)； //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 &#125; &#125; &#125; 小技巧 如何获得下一个方向的坐标（此处定义一个方向数组）。 12345678910111213141516171819 int next[4][2]=&#123; &#123;0, 1&#125;//向右走 &#123;1, 0&#125;//向下走 &#123;0, -1&#125;//向左走 &#123;-1, 0&#125;//向上走 &#125;;next[i][0]; //x方向next[i][1]; //y方向int dir[4][2]= &#123;0,1,1,0,0,-1,-1,0&#125;;dir[i][0]; //x方向dir[i][1]; //y方向 - 通过这个方向数组，使用循环就可以方便地得到下一步的坐标。 1234567891011121314151617181920212223242526272829 int map[6][6];//地图； bool temp[6][6];//走过的标记； int dx[4]=&#123;0,0,1,-1&#125;;//打表； int dy[4]=&#123;-1,1,0,0&#125;;//打表； void walk(int x,int y)//定义walk；&#123; if(x==fx&amp;&amp;y==fy)//fx表示结束x坐标，fy表示结束y坐标； &#123; total++;//总数增加； return;//返回，继续搜索； &#125; else &#123; for(int i=0;i&lt;=3;i++)//0——3是左，右，下，上四个方向； &#123; if(temp[x+dx[i]][y+dy[i]]==0&amp;&amp;map[x+dx[i]][y+dy[i]]==1)//判断没有走过和没有障碍； &#123; temp[x][y]=1;//走过的地方打上标记； walk(x+dx[i],y+dy[i]);//同i!!!! temp[x][y]=0;//还原状态； &#125; &#125; &#125;&#125; - 就在地图map数组上打标记（自己走过的路）比较简单，走过的路和障碍可能引起混淆]]></content>
      <categories>
        <category>算法</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab基本操作]]></title>
    <url>%2F2019%2F03%2F17%2Fmatlab%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[matlab语句 MATLAB语句的一般形式为：变量 = 表达式说明： 1.若变量和“=”省略，则名为ans的变量自动建立； 2.如果你输入了一个语句并以回车结束，则在工作区中显示计算的结果； 3.如果语句以分号“；”结束，MATLAB只进行计算，不显示计算的结果； 4.如果一个变大时太长，可以用续行号 … 将其延续到下一行。此外，一行中可以写几个语句，他们之间要用逗号或分号分开。 matlabz中变量 对于变量，MATLAB不需要任何类型的说明或维数语句。当输入一个新变量名时MATLAB自动建立面变量并为其分配内存空间。 MATLAB有几个特殊的量 1.Pi圆周率π 2.Eps最小浮点数 3.Inf正无穷大，特指1/0 4.NaN不定值，特指0/0 5.i，j虚数单位 6.自然对数 MATLAB中变量的命名规则是： 变量名必须是不含空格的单个词； 变量名区分大小写； 变量名最多不超过19个字符； 变量名必须以字母打头，之后可以是 任意字母、数字或下划线，变量名中，不允许使用标点符号. matalab中Π默认为3.1416（应该） 数据显示默认为四位，但只是matlab对数据的显示方式，其实不管显示的有效位数是多少，都不影响实际的计算结果，也不会有多大的累计误差。有效位数是4或8位，其计算结果的误差是一样的。符号 分号 ; 表示分隔不想显示计算结果的各语句；矩阵行与行的分隔符 续行号 … 长命令行需分行时连接下行用 逗号 ， 表示分隔欲显示计算结果的各语句；变量分隔符；矩阵一行中各元素间的分隔符 matlab输入 函数： a=input(‘please input a number：’); b=input(‘请输入一个字符串:’,’s’); c=input(‘请输入一个矩阵:’); 赋值：a=3;A=4;(变量赋予数值) ` a=A;(变量赋予变量)` ` a=‘a’;(变量赋予字符串)` ` a=zeros(m,n);a=ones(m,n);(变量赋予矩阵)` matlab输出 不加分号：a=3 a=b a=‘a’ a=zeros(m,n) 函数1：fprintf() ` fprintf(fid,format,A)` fid：输出的位置，如果缺省，则输出在命令窗口 format：输出内容的类型（类型包括：%d:整数 %e:实数 %s:字符串 %f:浮点数） A：输入内容的变量名 屏幕输出简单的方法是直接写出欲输出的变量或数组名，后面不加分号。此外，可 以采用 disp 语句，其调用格式为 disp(x)。 函数二：disp() disp(‘A’); disp(‘numstr(12)’) ;%%numstr()是将其他类型的变量转化成字符串的形式 disp(zeros(m,n)); 12345678 clc,clear;result = 0;for i=3:2:101 result = result + i;enddisp(result) MATLAB的每条命令后，若为逗号或无标点符号， 则显示命令的结果；若命令后为分号，则禁止显示结果. “%” 后面所有文字为注释. “…”表示续行. mat文件 mat文件是matlab的数据存储的标准格式。mat文件是标准的二进制文件,还可以ASCII码形式保存和加载，在MATLAB中打开显示类似于单行EXCEL表格。 MATLAB是解释型语言，就是说MATLAB命令行中敲入的命令在当前MATLAB进程中被解释运行。但是，每次执行一个任务时敲入长长的命令序列是很烦人的。有两种方法可以使MATLAB的力量得到扩展——脚本和函数。这两种方法都用像emacs一样的文本编辑器中编写的m文件（因为扩展名是.m所以这样命名，m文件还称点m文件）。m文件的好处在于它可以保存命令，还可以轻易地修改命令而无需重新敲入整个命令行。 所谓mat文件，就是由matlab语言编写的可在matlab语言环境下运行的程序源代码文件。Matlab语言的m文件可分为命令式和函数式两种形式。M文件可在matlab程序编辑器里编写，也可在其他文本编辑器中编写，并以”.m”为拓展名保存。 循环for循环 for 循环允许一组命令以固定的和预定的次数重复。for 循环的一般形式是 1234for 循环控制变量=表达式 1:表达式 2:表达式 3 语句 end - 表达式 1 的值为循环控制变量的初值；表达式 2 的值为步长，每执行循环体一次，循 环控制变量的值将增加步长大小。步长可以为负值，当步长为 1 时，表达式 2 可省略；表 达式 3 为循环控制变量的终值，当循环控制变量的值大于终值时循环结束。在 for 循环中， 循环体内不能出现对循环控制变量的重新设置，否则将会出错；for 循环允许嵌套使用。 使用 for 循环语句值得注意的是 for循环不能用循环内重新给循环变量赋值来终止 12345678 x=0;for n=1:4 x =x+1 n=5;end - for 循环的循环变量= [表达式 1:表达式 2:表达式 3]，其实为一行向量，例如： `[1:2:10]=[ 0 2 4 6 8 10]`，它还可以是数组，其更一般的形式为 `for 循环控制变量 = 数组表达式 语句 end ` - 【例 6.5】 用 for 循环求行向量[-2,5,3,6,-2]各元素之和。 1234567891011121314151617181920 a=[-2,5,3,6,-2]; s=0;k=0;for n=a n %显示每一次循环变量的值 k=k+1; %记录循环次数 s=s+n; %计算行向量 a 各元素之和 end k,s %显示总的循环次数和计算结果运行结果为 n = -2 n = 5 n = 3 n = 6 n = -2 k = 5 s = 10 可以看出，总循环次数为 5，第 i 次循环时循环变量的值为 a(i)，计算结果为行向量 a 各元素之和。 - 当有一个等效的数组方法来解给定的问题时，应避免用 for 循环。 - 【例 6.9】 比较下面两段程序的执行情况。 1234567891011 (a) for n=1:10 x(n)=sin(n*pi/10); end x (b) n=1:10; x=sin(n*pi/10) 两段程序的运行结果相同，均为 x = 0.3090 0.5878 0.8090 0.9511 1.0000 0.9511 0.8090 0.5878 0.3090 0.0000 但后者执行更快，更直观、简便。 为了得到更快的速度，在 for 循环(while 循环)被执行之前，应预先分配数组。如例 6.9(a)，在 for 循环内每执行一次命令，变量 x 的大小增加 1，迫使 MATLAB 每进行一次循 环都要花费时间对 x 分配更多的内存。为了省去这个步骤，可以在例 6.9(a)程序的首行加入：x=zeros(1,10); %为 x 分配内存单元 while循环 其一般形式为 12345678910111213141516 while 关系表达式 语句 end ``` - 注意：for 循环的循环变量为 m1× m 2×…× m n 维数组，循环次数在一开始就由数组确定为 m2×…× m n，所以在循环体内并不能通过改变循环控制变量的值终止循环；而 while 循环是先执行循环体内的语句，再判断循环的条件是否成立，在循环体内可以通过 改变循环控制变量的值终止循环。# 判断- try 语句 - try 语句是 MATLAB 特有的语句，其一般结构是 try 语句 1 catch 语句 2 end 12345678910- elseif与else if不同，前者嵌套if语句时不用end，后者要与else if对应的end- elseif:不需要end结束- else if:需要end结束- if, elseif, else if expression statements elseif expression statements else statements end `]]></content>
      <categories>
        <category>matlab</category>
        <category>基本操作</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快排及其优化]]></title>
    <url>%2F2019%2F03%2F15%2F%E5%BF%AB%E6%8E%92%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[快排 写快排以 a[1] 为基准点太易被卡，可以用 a[(L+r)/2]. STL 的快排算法的实现其实加入了小数组时冒泡，可能慢的时候用堆排等等优化]]></content>
      <categories>
        <category>算法</category>
        <category>快排及其优化</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成随机数]]></title>
    <url>%2F2019%2F03%2F15%2F%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数学秘密]]></title>
    <url>%2F2019%2F03%2F15%2F%E6%95%B0%E5%AD%A6%E7%A7%98%E5%AF%86%2F</url>
    <content type="text"><![CDATA[最大公约数 在解有关最大公约数、最小公倍数的问题时，常用到以下结论 - （1）如果两个自然数是互质数，那么它们的最大公约数是1，最小公倍数是这两个数的乘积。 例如8和9，它们是互质数，所以（8，9）=1，[8，9]=72。 - （2）如果两个自然数中，较大数是较小数的倍数，那么较小数就是这两个数的最大公约数，较大数就是这两个数的最小公倍数。 例如18与3，18÷3=6，所以（18，3）=3，[18，3]=18。 - （3）两个整数分别除以它们的最大公约数，所得的商是互质数。 例如8和14分别除以它们的最大公约数2，所得的商分别为4和7，那么4和7是互质数。 - （4）两个自然数的最大公约数与它们的最小公倍数的乘积等于这两个数的乘积。 例如12和16，（12，16）=4，[12，16]=48，有4×48=12×16，即（12，16）× [12，16]=12×16。 - （5）GCD(a,b) is the smallest positive linear combination of a and b. a与b的最大公约数是最小的a与b的正线性组合,即对于方程xa+yb=c来说,若x,a,y,b都为整数,那么c的最小正根为gcd(a,b).]]></content>
      <categories>
        <category>数学基础知识</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数与最小公倍数]]></title>
    <url>%2F2019%2F03%2F14%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[merge函数]]></title>
    <url>%2F2019%2F03%2F13%2Fmerge%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[merge函数 merge函数的作用是：将两个有序的序列合并为一个有序的序列。 合并操作会合并两个有相同顺序的序列中的元素，可以是两个升序序列，也可以是两个降序序列。结果会产生一个包含来自这两个输入序列的元素副本的序列，并且排序方式和原始序列相同 merge() 算法会合并两个序列并将结果保存到第三个序列中，它使用 &lt; 运算符来比较元素。图 1 表明合并操作被运用到 these 和 those 容器的内容上，结果序列保存在 both 容器中。 merge() 算法需要 5 个参数。其中前两个指定第一个输入序列的迭代器，在这个示例中是 these，后面两个迭代器指定第二个输入序列，在这个示例中是 those，最后一个参数是一个指定合并元素存放位置的迭代器，即 both 容器。用来指定输入序列的迭代器只需要是最低层次的迭代器，用来保存合并结果的迭代器需要是一个输出迭代器。 当需要使用不同于 &lt; 运算符的其他比较运算时，可以提供一个函数对象用来作为第 6 个参数。 merge() 算法并没有关于被合并序列容器的信息，所以它们不能创建元素，只能用提供的作为第 5 个参数的迭代器来保存元素。因而在这个示例中，目的序列中的元素必须是已经存在的。在图 1 中，通过以两个输入容器元素个数之和为指定的元素个数创建一个 both 容器来保证此要求。创建的结果序列可以放在任何位置，甚至可以放在一个源序列容器中，但源序列和目的序列不能重叠；如果它们重叠了，结果是未定义的，但可以肯定的是效果肯定不好。当然，可以用一个插入迭代器来指定目的位置，元素会被自动创建。 返回值指向最后复制元素后一元素的迭代器。merge() 算法返回的迭代器指向合并序列末尾的后一个位置，所以可以通过这个函数调用使用的第 5 个参数加上这个函数返回的迭代器来确定合并序列的范围。 源码1.123456template&lt; class InputIt1, class InputIt2, class OutputIt, class Compare&gt;constexpr OutputIt merge( InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp ); 12345678910111213141516171819202122template&lt;class InputIt1, class InputIt2, class OutputIt&gt;OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first)&#123; for (; first1 != last1; ++d_first) &#123; if (first2 == last2) &#123; return std::copy(first1, last1, d_first); &#125; if (*first2 &lt; *first1) &#123; *d_first = *first2; ++first2; &#125; else &#123; *d_first = *first1; ++first1; &#125; &#125; return std::copy(first2, last2, d_first);&#125; 2. 12345678template&lt; class InputIt1, class InputIt2, class OutputIt &gt;constexpr OutputIt merge( InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first ); 1234567891011121314151617181920212223template&lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt;OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp)&#123; for (; first1 != last1; ++d_first) &#123; if (first2 == last2) &#123; return std::copy(first1, last1, d_first); &#125; if (comp(*first2, *first1)) &#123; *d_first = *first2; ++first2; &#125; else &#123; *d_first = *first1; ++first1; &#125; &#125; return std::copy(first2, last2, d_first);&#125; 归并二个已排序范围 [first1, last1) 和 [first2, last2) 到始于 d_first 的一个已排序范围中。 用 operator&lt; 比较元素。 用给定的二元比较函数 comp 比较元素。 first1, last1 要归并的元素的第一范围 first2, last2 要归并到元素的第二范围 d_first 目标范围的起始 类型要求-InputIt1, InputIt2 必须满足 LegacyInputIterator 的要求。-ForwardIt1, ForwardIt2, ForwardIt3 必须满足 LegacyForwardIterator 的要求。-OutputIt 必须满足 LegacyOutputIterator 的要求。 vector合并 merge第五个参数即用来存储的第三个vector大小必须预先确定，虽然用vec.begin();可以指向首地址，但是无存储空间 自己代码 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt; using namespace std;int main()&#123; vector&lt;int&gt; a, b; vector&lt;int&gt; c(100); int n, m, i = 0, j[100]; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; j[i], a.push_back(j[i]); i = 0; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++) cin &gt;&gt; j[i], b.push_back(j[i]); merge(a.begin(), a.end(), b.begin(), b.end(), c.begin()); for(i = 0; i &lt; a.size()+b.size(); i++) cout &lt;&lt; c[i] &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
        <category>merge</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++输入输出]]></title>
    <url>%2F2019%2F03%2F12%2Fc-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-1%2F</url>
    <content type="text"><![CDATA[getline函数C++中有两个getline函数 1.一个是在string头文件中，定义的是一个全局的函数,函数声明是 istream&amp; getline ( istream &amp;is , string &amp;str , char delim );istream&amp; getline ( istream&amp; is, string&amp; str); is 进行读入操作的输入流 str 存储读入的内容 delim 终结符 对于第一个函数delim是可以由用户自己定义的终结符；对于第二个函数delim默认为 ‘\n’（换行符）。 在遇到终结符delim后，delim会被丢弃，不存入str中。在下次读入操作时，将在delim的下个字符开始读入。 这个getline是个全局函数，而不是istream/iostream的成员函数getline。 2. 另一个则是istream的成员函数，函数声明是 istream&amp; getline (char* s, streamsize n ) istream&amp; getline (char* s, streamsize n, char delim ); 注意这个getline是将读取的字符串存储在char数组中而不可以将该参数声明为string类型，因为C++编译器无法执行此默认转换。！ 输入过程中达到n个数或者提前遇到delim，或者文件结束，输入结束 下面看看就行，待续 1、getline读取换行符 并且将换行符替换成’\0’，并且会丢弃换行符，对于getline函数，在函数遇到和结束定界符相等的字符时函数结束，同时函数抽出定界符，此种情况下该定界符既不被放回输入流，也不被放入要生成的字符串 2、cin会把换行符留在输入队列中 3、cin.getline读取换行符并替换成’\0’，并且不会主动丢弃换行符，会把它留在输入队列中]]></content>
      <categories>
        <category>输入输出</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dev的秘密]]></title>
    <url>%2F2019%2F03%2F11%2FDev%E7%9A%84%E7%A7%98%E5%AF%86%2F</url>
    <content type="text"><![CDATA[dev快捷键 按下Ctrl+Shift+A，会看到DEV帮你整理好了代码。 Ctrl + shift + 方向键上或下会选中光标当前所在的行，然后将这个行进行上移或下移，移动操作不会覆盖上下相邻的行，只是将位置进行对调。（eclipse则是在嵌套的方法之间做跳转，VS2013没有效果） debug时添加查看不用输入，只要左键选中变量，然后点击添加即可（偶然发现，惊喜不已）]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器]]></title>
    <url>%2F2019%2F03%2F11%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在STL定义的容器中，string，vector与deque提供了随机访问迭代器，list、set、multiset、map、multimap提供了双向迭代器。 能进行算术运算的迭代器只有随即访问迭代器，要求容器元素存储在连续内存空间里，vector，string，deque的迭代器是有加减法的，但是map，set，multimap,multiset的迭代器是没有加减法的，list也不可以,map等的迭代器不支持加减操作，仅有++itr，–itr这些操作来进行选择 Bidirectional迭代器：是在前向迭代器的基础上，多了单步向后遍历的能力。也就是–iter,iter–。 Random Access迭代器：在双向迭代器基础上，具有直接访问各数据元素的能力。随机迭代器增加了“迭代器算术运算”： 所有迭代器都应该实现自增算符：iter++,++iter STL 中的容器适配器有 stack、queue、priority_queue 三种。它们都是在顺序容器的基础上实现的，屏蔽了顺序容器的一部分功能，突出或增加了另外一些功能。容器适配器是没有迭代器的，因此 STL 中的各种排序、查找、变序等算法都不适用于容器适配器。]]></content>
      <categories>
        <category>stl</category>
        <category>迭代器</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string]]></title>
    <url>%2F2019%2F03%2F10%2Fstring%2F</url>
    <content type="text"><![CDATA[string123456789string a, b;.....a = a + b;//将a+b前后连接，对于string来说有些符号重载定义// ‘ + ’暂且理解为前后连接，所以前后不同，结果不同//string作为容器，可以和字符串、字符相加，也可以和string相加//具体原因不知道//待续 string 的末尾没有&#39;\0&#39;字符，所以length()返回的是字符串的真实长度，而不是长度 +1。 string 字符串的起始下标仍是从 0 开始。 有了 string 类，我们可以使用+或+=运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的 strcat()、strcpy()、malloc() 等函数来拼接字符串了，再也不用担心空间不够会溢出了。 用+来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个字符数组，或者是一个 string 字符串和一个单独的字符。]]></content>
      <categories>
        <category>stl</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度算法]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言:由于计算机运算是有模运算,数据范围的表示有一定限制,如整型int(C++中int 与long相同)表达范围是(-2^31~2^31-1),unsigned long(无符号整数)是(0~2^32-1),都约为几十亿.如果采用实数型,则能保存最大的double只能提供15~16位的有效数字,即只能精确表达数百万亿的数.因此,在计算位数超过十几位的数时,不能采用现有类型,只能自己编程计算. 由于数计算时可能要进位,因此为了方便,将数由低位到高位依次存在数组下标对应由低到高位置上,另外,我们申请数组大小时,一般考虑了最大的情况,在很多情况下,表示有富余,即高位有很多0,可能造成无效的运算和判断,因此,我们一般将数组的第0个下标对应位置来存储该数的位数.如数:3485(三千四百八十五)，表达在数组a[10]上情况是: 下标 0 1 2 3 4 5 6 7 8 9内容 4 5 8 4 3 0 0 0 0 0 说明：位数 个位 十位 百位 千位 倒序存储 面对高精度类型的题我们只需要像竖式一样从低位到高位计算，最后进行处理 注：高精度计算时一般用正数，对于负数，通过处理符号位的修正，在程序实现上用一个变量来存储符号位，用另一个数组存差的绝对值，置符号位：判断被减数是否大于减数：大则将符号位置为空；小则将符号位置为“- ”，交换减数与被减数； memset可用fill代替 在以后的学习中为了加快计算速度,也可用数组的一个元素表示数的多位数字(该内容可以进一步优化一个链接) 以下的方法的有明显的缺点： （1）浪费空间：一个整型变量（-32768~32767）只存放一位（0~9）； （2）浪费时间：一次加减只处理一位； 针对以上问题，如下优化：一个数组元素存放四位数；（integer的最大范围是32767，5位的话可能导致出界）将标准数组改为紧缩数组 高精度数的存储 １．如对数采用的字符串输入 123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=100;//最多100位int main()&#123; int a[N+1],i; string s1; cin&gt;&gt;s1;//数s1 memset(a,0,sizeof(a)); //数组清0 a[0]=s1.length(); //位数 for(i=1;i&lt;=a[0];i++) a[i]=s1[a[0]-i]-'0';//将字符转为数字并倒序存储． return 0;&#125; 2.直接读入 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int N=100;//最多100位int main()&#123; int a[N+1],i,s,key; cin&gt;&gt;key;//数key memset(a,0,sizeof(a)); //数组清0 i=0;//第0位 while(key) //当key大于0 &#123; a[++i]=key%10;//取第i位的数 key=key/10; &#125; a[0]=i; //共i位数 return 0;&#125; 3.直接初始化(用a[]存储) 初始化为0: memset(a,0,sizeof(a)); 初始化为1: memset(a,0,sizeof(a));a[0]=1;a[1]=1; 以下程序都只写函数，不写完整程序，所有高精度数存储都满足上述约定。(序号为1的) 高精度数的比较1.123456789101112131415161718int compare(int a[],int b[]) //比较a和b的大小关系，若a&gt;b则为1，a&lt;b则为-1,a=b则为0&#123; int i; if (a[0]&gt;b[0]) return 1;//a的位数大于b则a比b大 if (a[0]&lt;b[0]) return -1;//a的位数小于b则a比b小 for(i=a[0];i&gt;0;i--) //从高位到低位比较 &#123; if (a[i]&gt;b[i]) return 1; if (a[i]&lt;b[i]) return -1; &#125; return 0;//各位都相等则两数相等。&#125; 2.clear内联函数中if语句不可以删掉，如果2个输入都为0，在执行玩第一个语句后，全被删除，为空，所以if语句是输入全为0的情况！123456789101112131415161718 //清除前缀0，如果结果是空字符串则设为0 inline void clear(string&amp; a)&#123; while(a.length()&gt;0 &amp;&amp; a[0]=='0') a.erase(0, 1); if(a == "") a = "0";//如果a&gt;=b则返回真（如果包含前缀零会被消除） bool isBigger(string a, string b)&#123; clear(a); clear(b); if(a.length() &gt; b.length()) return true; if(a.length()==b.length() &amp;&amp; a&gt;=b) return true; return false; &#125; 高精度数的加法1.12345678910111213141516int plus(int a[],int b[]) //计算a=a+b&#123; int i,k; k=a[0]&gt;b[0]?a[0]:b[0]; //k是a和b中位数最大的一个的位数 for(i=1;i&lt;=k;i++) &#123; a[i+1]+=(a[i]+b[i])/10; //若有进位，则先进位 a[i]=(a[i]+b[i])%10; &#125; //计算当前位数字,注意：这条语句与上一条不能交换。 if(a[k+1]&gt;0) a[0]=k+1; //修正新的a的位数（a+b最多只能的一个进位） else a[0]=k; return 0;&#125; 2.注意一定要补0，否侧无法进位！！！1234567891011121314151617181920212223//两个高精度正整数加法 a+b string stringAddString(string a, string b)&#123; //1、对位，将两个数补零直到其具有相同长度 while(a.length() &lt; b.length()) a = '0' + a; while(a.length() &gt; b.length()) b = '0' + b; //2、补零，在开头再加一个0以便进位 a = '0' + a; b = '0' + b; //3、从低位开始相加，注意进位 for(int i=a.length()-1; i&gt;=0; i--)&#123; a[i] = a[i] + b[i] - '0'; if(a[i] &gt; '9')&#123; a[i] = a[i] - 10; a[i-1] += 1; &#125; &#125; clear(a); return a; &#125; 高精度数的减法1.12345678910111213141516171819202122232425262728293031323334353637383940414243int gminus(int a[],int b[]);//计算a=a-b，返加符号位0:正数 1:负数&#123; int flag,i flag=compare(a,b); //调用比较函数判断大小 if (falg==0)//相等 &#123; memset(a,0,sizeof(a)); return 0; &#125; //若a=b，则a=0,也可在return前加一句a[0]=1,表示是 1位数0 if(flag==1) //大于 &#123; for(i=1;i&lt;=a[0];i++) &#123; if(a[i]&lt;b[i]) &#123; a[i+1]--; a[i]+=10; &#125; //若不够减则向上借一位 a[i]=a[i]-b[i]; &#125; while(a[a[0]]==0) a[0]--; //修正a的位数 return 0; &#125; else if (flag==-1)//小于 则用a=b-a,返回-1 &#123; for(i=1;i&lt;=b[0];i++) &#123; if(b[i]&lt;a[i]) &#123; b[i+1]--; b[i]+=10; &#125; //若不够减则向上借一位 a[i]=b[i]-a[i]; &#125; a[0]=b[0]; while(a[a[0]]==0) a[0]--; //修正a的位数 return -1; &#125;&#125; 2.两个高精度正整数减法 a-b1234567891011121314151617181920212223242526272829303132333435 string stringSubString(string a, string b)&#123; bool aBigger = true; //1、对位，将两个数补零直到其具有相同长度 while(a.length() &lt; b.length()) a = '0' + a; while(a.length() &gt; b.length()) b = '0' + b; //2、推测结果正负值，调整为前大后小 if(a &lt; b) &#123; aBigger = false; string buf = b; b = a; a = buf; &#125; //3、从低位开始相减，注意借位,注意不用函数string是往后插入，然后从0开始，所以i=a.length()-1; for(int i=a.length()-1; i&gt;=0; i--)&#123; if(a[i] &gt;= b[i])&#123; a[i] = a[i] - (b[i] - '0'); &#125;else&#123; a[i] = a[i] + 10; a[i-1] -= 1; a[i] = a[i] - (b[i] - '0'); &#125; &#125;//4.字符就是int，字符型运算时是用ASCII码运算，//所以a[i] - b[i]为ASCII相减，此时不为数字字符，所以加上'0' //保证a[i]为数字字符（string)!!!!!!!!!!! clear(a); if(!aBigger) a = '-' + a;//string中因为'-'放在前面，所以输出时在前面，前后连接 return a; &#125; 高精度乘法1(高精度乘单精度数，单精度数是指通常的整型数)1.12345678910111213141516171819202122232425262728int multi1(int a[],long key) //a=a*key,key是单精度数 &#123; int i,k; if (key==0) &#123; memset(a,0,sizeof(a)); a[0]=1; return 0; &#125; //单独处理key=0 for(i=1;i&lt;=a[0];i++) a[i]=a[i]*key;//先每位乘起来 for(i=1;i&lt;=a[0];i++) &#123; a[i+1]+=a[i]/10; a[i]%=10; &#125; //进位 //注意上一语句退出时i=a[0]+1 while(a[i]&gt;0) &#123; a[i+1]=a[i]/10; a[i]=a[i]%10; i++; a[0]++; &#125; //继续处理超过原a[0]位数的进位,修正a的位数 return 0;&#125; 2. 待续 高精度除以低精度 算法：按照从高位到低位的顺序，逐位相除。在除到第j位时，该位在接受了来自第j+1位的余数后与除数相除，如果最高位为零，则商的长度减一 1.123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#define N 500main()&#123; int a[N] = &#123;0&#125;, c[N] = &#123;0&#125;; int i, k, d, b; char a1[N]; printf("Input 除数:"); scanf("%d", &amp;b); printf("Input 被除数:"); scanf("%s", a1); k = strlen(a1); for(i = 0; i &lt; k; i++) a[i] = a1[k - i - 1] - '0'; d = 0; for(i = k - 1; i &gt;= 0 ; i--) &#123; d = d * 10 + a[i]; c[i] = d / b; d = d % b; &#125; while(c[k - 1] == 0 &amp;&amp; k &gt; 1) k--; printf("商="); for(i = k - 1; i &gt;= 0; i--) printf("%d", c[i]); printf("\n余数=%d", d); &#125; 2. 待续 #]]></content>
      <categories>
        <category>算法</category>
        <category>高精度算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[char与string转换]]></title>
    <url>%2F2019%2F03%2F10%2Fchar%E4%B8%8Estring%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[#]]></content>
      <categories>
        <category>c++</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++find函数]]></title>
    <url>%2F2019%2F03%2F09%2Fc-find%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[find函数 find用在容器中更加普遍，而algorithm中其实find函数只是一种 C++find函数原型： 123456789101112template&lt;class InputIterator, class T&gt; InputIterator find (InputIterator first, InputIterator last, const T&amp; val)&#123; while (first!=last) &#123; if (*first==val) return first; ++first; &#125; return last;&#125;如果没找到对应的关键元素，会返回end(),最后一个元素的后一位。 其中，find()算法的前两个参数都是某个容器的迭代器，用于指定查找的起始位置和终止位置；第三个参数就是要查找的内容，它的数据类型跟容器中数据的类型相同。这里需要注意的是，find()算法会利用“==”操作符将这里的目标内容跟容器中的数据元素进行相等比较，以确定某个元素是否符合条件，所以，这里的数据类型必须支持“==”操作符进行相等比较。对于基本数据类型而言，它们已经天然支持无需我们操心，如果是自定义的数据类型，则需要重载“==”操作符以支持相等比较。 各个容器自己实现的成员函数 vector没有实现find函数，除此之外，常见容器都实现了自己的find函数，如set，map，string String是这一种顺序存储结构，其find函数返回的是下标索引。set,map,multiset,multimap都不是顺序索引的数据结构，所以返回的是迭代器。 为什么返回的不是索引下标？这是因为索引下标是在数组这种连续存储的数据结构里面常见的，是一种顺序索引；而很多数据结构的存储并非连续的，不能实现顺序索引，为了兼顾所有的数据结构，所以返回的仅仅是指针或是迭代器。如果元素不在 对于返回迭代器的查找，通过判断find（a.begin(),a.end(),value）==a.end()，来判断元素是否存在 对于string，通过a.find(val)==string::npos判断 std::map::find返回值指向键等于 key 的元素的迭代器。若找不到这种元素，则返回尾后（见 end() ）迭代器。]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog表格]]></title>
    <url>%2F2019%2F03%2F09%2Fblog%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[表格 a b c d |、-、:之间的多余空格会被忽略，不影响布局。默认标题栏居中对齐，内容居左对齐。 -:表示内容和标题栏居右对齐 :-表示内容和标题栏居左对齐 :-:表示内容和标题栏居中对齐。 内容和|之间的多余空格会被忽略，每行第一个|和最后一个|可以省略，-的数量至少有一个。]]></content>
      <categories>
        <category>blog</category>
        <category>表格</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector简介]]></title>
    <url>%2F2019%2F03%2F09%2Fvector%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[cpp vector vector的底层数据结构是动态数组内存分配 标准库的实现者使用了这样的内存分配策略：以最小的代价连续存储元素。为了使vector容器实现快速的内存分配，其实际分配的容量要比当前所需的空间多一些(预留空间)，vector容器预留了这些额外的存储区用于存放添加的新元素，于是不必为每个新元素进行一次内存分配。当继续向容器中加入元素导致备用空间被用光（超过了容量 capacity），此时再加入元素时vector的内存管理机制便会扩充容量至两倍，如果两倍容量仍不足，就扩张至足够大的容量。容量扩张必须经历“重新配置、元素移动、释放原空间”这个浩大的工程。 按照《STL源码剖析》中提供的vector源码，vector的内存配置原则为： 如果vector原大小为0，则配置1，也即一个元素的大小。 如果原大小不为0，则配置原大小的两倍。 当然，vector的每种实现都可以自由地选择自己的内存分配策略，分配多少内存取决于其实现方式，不同的库采用不同的分配策略。 迭代器失效问题 vector管理的是连续的内存空间，在容器中插入（或删除）元素时，插入（或删除）点后面的所有元素都需要向后（或向前）移动一个位置，指向发生移动的元素的迭代器都失效。 随着元素的插入，原来分配的连续内存空间已经不够且无法在原地拓展新的内存空间，整个容器会被copy到另外一块内存上，此时指向原来容器元素的所有迭代器通通失效。 删除元素后，指向被删除元素的迭代器失效，这是显而易见的。 访问 使用的vector下标必须小于vector.size();如果开始定义vector未指定大小，用数组下标输入不可以，因为vector中无相应元素，没相应内存空间 初始化大小 vector v(n,i)形式，v包含n 个值为 i 的元素 v(int n)将容器初始化为有 n 个元素 vector()无参构造函数，将容器初始化为空 如果想知道vector是否为空，可以使用empty（），空返回true，否则返回false。]]></content>
      <categories>
        <category>stl</category>
        <category>vector</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[list列表]]></title>
    <url>%2F2019%2F03%2F08%2Flist%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[cppreference list头文件 #include ＜list＞ 底层数据结构 list同样是一个模板类，它底层数据结构为双向循环链表。因此，它支持任意位置常数时间的插入/删除操作，不支持快速随机访问。 双向链表的每个元素中都有一个指针指向后一个元素，也有一个指针指向前一个元素 内存分配策略 list的空间配置策略，自然是像我们普通双向链表那样，有多少元素申请多少内存。它不像vactor那样需要预留空间供新元素的分配，也不会因找不到连续的空间而引起整个容器的内存迁移。 迭代器失效问题 list 有一个重要性质：插入操作（insert）与接合操作（splice）都不会造成原有的list迭代器失效。这在vector是不成立的，因为vactor的插入可能引起空间的重新配置，导致原来的迭代器全部失效。list的迭代器失效，只会出现在删除的时候，指向删除元素的那个迭代器在删除后失效。通常来说，forward_list在使用灵活度上比不上list，因为它只能单向迭代元素，且提供的接口没有list多。然而，在内存的使用上，它是比list占优势的。当对内存的要求占首要位置时，应该选择forward_list。 构造函数 list&lt;int&gt; c;空链表 list&lt;int&gt; c1(3); 建一个含三个默认值是0的元素的链表 list&lt;int&gt; c2(5,2); 建一个含五个元素的链表，值都是2 list&lt;int&gt; c4(c2); 建一个c2的copy链表 list&lt;int&gt; c5(c1.begin(),c1.end()); c5含c1一个区域的元素[_First, _Last)。 list 容器不支持根据下标随机存取元素 list 的成员函数 front() 和 back()，可以各自返回第一个和最后一个元素的引用。在空 list 中调用它们中的任意一个，结果是未知的，因此不要这样使用。可以通过迭代器的自增或自减来访问 list 的内部元素。 List常用操作函数list 的特点 (1) 不使用连续的内存空间这样可以随意地进行动态操作； (2) 可以在内部任何位置快速地插入或删除，当然也可以在两端进push 和pop 。 (3) 不能进行内部的随机访问，即不支持[ ] 操作符和vector.at() ； (4) 相对于verctor 占用更多的内存。 有自身的sort函数 STL 中的算法 sort 可以用来对 vector 和 deque ，string排序，它需要随机访问迭代器的支持。因为 list 不支持随机访问迭代器，所以不能用算法 sort 对 list 容器排序。因此，list 容器引入了 sort 成员函数以完成排序。 注意std::sort 要求随机访问迭代器且不能用于 list 。此函数与 std::sort 的区别在于，它不要求 list 的元素类型可交换，保留所有迭代器的值，并进行稳定排序。]]></content>
      <categories>
        <category>stl</category>
        <category>list</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reverse反转函数]]></title>
    <url>%2F2019%2F03%2F08%2Freverse%E5%8F%8D%E8%BD%AC%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[reverse函数 reverse函数可以反转一个容器中的内容，包含在&lt;algorithm&gt;库中。 参数：first、last first和last是双向迭代器类型，reverse函数反转的范围是[first,last)，所以包括first指向的元素，不包括last指向的元素。 reverse(v.begin(),v.end());反向排列从头到尾部的元素 reverse函数没有返回值。 复杂度 循环交换首尾元素。因此复杂度是线性的，并且循环半个数组长度。]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vector大小（size）和容量（capacity）]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%85%B3%E4%BA%8Evector%E5%A4%A7%E5%B0%8F%EF%BC%88size%EF%BC%89%E5%92%8C%E5%AE%B9%E9%87%8F%EF%BC%88capacity%EF%BC%89%2F</url>
    <content type="text"><![CDATA[vector 在Vector容器中有以下几个关于大小的函数 - size() 返回容器的大小，目前存在的元素数 - empty() 判断容器是否为空 - max_size() 返回容器最大的可以存储的元素 - capacity() 返回容器当前能够容纳的元素数量 capacity 一般大于size的原因是为了避免 每次增加数据时都要重新分配内存，所以一般会 生成一个较大的空间，以便随后的数据插入。 Vector的容量之所以重要，有以下两个原因：- 1. 容器的大小一旦超过capacity的大小，vector会重新配置内部的存储器，导致和vector元素相关的所有reference、pointers、iterator都会失效。 - 2.内存的重新配置会很耗时间。 size 是当前 vector 容器真实占用的大小，也就是容器当前拥有多少个容器。capacity 是指在发生 realloc 前能允许的最大元素数，即预分配的内存空间。 在 STL 中，拥有 capacity 属性的容器只有 vector 和 string。 避免内存重新配置的方法 方法一：Reserve()保留适当容量在创建容器后，第一时间为容器分配足够大的空间，避免重新分配内存。 vec.reverse(n); 方法二：利用构造函数创建出足够空间 该方法是创建容器时，利用构造函数初始化的出足够的空间， vector&lt;int&gt; v(n); 但是要注意，如果容器中reserve的容量太大，而实际中根本不需要那么多，或者元素插入完成后，以后就不会再进行插入操作了，那么多出来的这部分空间就是过剩空间，而对于过剩空间，我们可以通过“交换技术”成功缩小空间，交换技巧的变体可以用于清除容器和减少它的容量到你的实现提供的最小值。 Vector内存扩展方式 更多可去 stl介绍 vector内存成长方式可归结以下三步曲:（1）另觅更大空间；（2）将原数据复制过去；（3）释放原空间三部曲。 对于vector和string来说，当它们的需要更多空间时，就会自动增加空间，而每次增加空间的容量会导致很大的开销，首先必须分配新的内存块，它有容器目前容量的几倍（在大部分实现中，vector和string的容量每次变为2倍），然后把所有元素从容器的旧内存拷贝到它的新内存，接着销毁旧内存中的对象，最后回收旧内存。 每次重新分配空间，所有指向vector或string中的迭代器、指针和引用都会失效，这意味着简单地把一个元素插入vector或string的动作也可能需要更新其他使用了指向vector或string中的迭代器、指针或引用的数据结构而膨胀。]]></content>
      <categories>
        <category>stl</category>
        <category>vector</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头文件]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%A4%B4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[#include STL定义运算函数（代替运算符） #include&lt;bits/stdc++.h&gt; 编译器GCC 4.8支持的万能头文件，基本包含所有头文件]]></content>
      <categories>
        <category>头文件</category>
        <category>functioinal</category>
      </categories>
      <tags>
        <tag>头文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pair容器]]></title>
    <url>%2F2019%2F03%2F08%2Fpair%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[pair pair类型的使用相当的繁琐，如果定义多个相同的pair类型对象，可以使用typedef简化声明：typedef pair&lt;string,string&gt; Author; 除了构造函数，标准库还定义了一个make_pair函数，由传递给它的两个实参生成一个新的pair对象 123456789101112 pair&lt;string, string&gt; next_auth; string first,last; while(cin&gt;&gt;first&gt;&gt;last) &#123; next_auth=make_pair(first,last); ...&#125; 等价的更复杂的操作:next_auth=pair&lt;string,string&gt;(first,last);]]></content>
  </entry>
  <entry>
    <title><![CDATA[sort函数]]></title>
    <url>%2F2019%2F03%2F08%2Fsort%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言 排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。 STL容器的排序，支持随机访问的容器vector,deque,string没有sort成员，可调用std::sort排序；list排序调用自带的list::sort。 注意std::sort 要求随机访问迭代器且不能用于 list 。此函数与 std::sort 的区别在于，它不要求 list 的元素类型可交换，保留所有迭代器的值，并进行稳定排序。 sort函数有以下特征： 要求输入一个范围[first, last) 随机迭代器，能用此算法的容器是支持随机访问的容器：vector, deque, string。 对于list容器，list自带一个sort成员函数list::sort()。它和算法函数中的sort差不多，但是list::sort是基于指针的方式排序，也就是说，所有的数据移动和比较都是此用指针的方式实现，因此排序后的迭代器一直保持有效（vector中sort后的迭代器会失效)。 sort函数 默认的为升序 第三参数——比较函数。比较函数是一个自己定义的函数，返回值是bool型(一般)，它规定了什么样的关系 排序的数据类型不局限于整数，只要是定义了小于运算的类型都可以，比如字符串类string。 如果是没有定义小于运算的数据类型，或者想改变排序的顺序，就要用到第三参数——比较函数。 vector&lt;int&gt; v; sort(v.begin(), v.end(), greater&lt;int&gt;()); sort(a, a+n, cmp); 对数组进行排序,其头文件为algorithm.h，形式为sort（数组名，数组名+数组长度），默认为升序，复杂度为nlog（n）； 加#include&lt;functional&gt;因为用了greater&lt;int&gt;() sort(begin, end, less&lt;数据类型&gt;（）)，升序； sort(begin, end, greater&lt;数据类型&gt;（）)，降序； sort（数组名，数组名+数组长度，less&lt;数组数据类型&gt;()）,升序； sort(数组名，数组名+数组长度，greater&lt;数组数据类型&gt;（）)，降序。]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>常用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[计算机领域中，这个字典序就不仅仅用来比较英文单词了，而是比较任意字符串。对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。如strcmp函数的原理]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stl代码练习]]></title>
    <url>%2F2019%2F03%2F08%2Fstl%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[learn_stl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;map&gt;#define MAX_SIZE 10000using namespace std;int n;typedef struct node&#123; string name; //string暂时可以当成一种结构体变量,专门用来定义字符串,name的长度可以由name.length()获得 int grade;&#125;Student;vector&lt;int&gt; vec;list&lt;int&gt; link_list;deque&lt;int&gt; dq;stack&lt;int&gt; Stack;queue&lt;int&gt; que;priority_queue&lt;int&gt; q;set&lt;int&gt; s;map&lt;string,int&gt; stu;void fun_1(int a[]);void fun_2(int a[]);void fun_3(int a[]);void fun_4(int a[]);void fun_5(int a[]);void fun_6(int a[]);void fun_7(Student a[]);int main()&#123; int a[MAX_SIZE]; Student student[MAX_SIZE]; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; student[i].name &gt;&gt; student[i].grade;//只用于map /*1.用vector存入数组中所有的数据并升序排序,然后删去最大元素 */for(int i = 0; i &lt; n; i++) vec.push_back(a[i]);sort(vec.begin(), vec.end());vec.pop_back();for(int i = 0; i &lt; vec.size(); i++) cout &lt;&lt; vec[i] &lt;&lt; endl;/*2. 用list存入数组中所有的元素并升序排序。删除其中最小的节点并再插入一个最大的节点 */ for(int i = 0; i &lt; n; i++) link_list.push_back(a[i]);link_list.sort();link_list.erase(link_list.begin());link_list.insert(link_list.begin(), *(--link_list.end())); for(list&lt;int&gt;::iterator itt = link_list.begin(); itt != link_list.end(); itt++) cout &lt;&lt; *itt &lt;&lt; endl; /*3.用deque存入数组中所有的数据，在头尾端插入一个和队头队尾相同的元素。 将deque中的数据用另一个vector存储起来排序后再放回deque中 */ for(int i = 0; i &lt; n; i++) dq.push_back(a[i]);dq.push_back(a[n-1]), dq.push_front(a[0]);vector&lt;int&gt; haha;for(int i = 0; i &lt; n; i++) haha.push_back(a[i]);sort(haha.begin(), haha.end());dq.clear();deque&lt;int&gt; dq(haha.begin(), haha.end());for(deque&lt;int&gt;:: iterator ittt = dq.begin(); ittt != dq.end(); ittt++) cout &lt;&lt; *ittt &lt;&lt; endl;/*4.将数组中的元素依次存入stack中，然后依次存入queue中实现数组元素的reverse */ for(int i = 0; i &lt; n; i++) Stack.push(a[i]);for(int i = n-1; i &gt;= 0; i--)&#123; que.push(Stack.top()); Stack.pop(); &#125; for(int i = n - 1; i &gt;= 0; i--) cout &lt;&lt; que.front() &lt;&lt; endl; /*5.不借助其他的函数和变量，利用priority_queue实现数组的升序排序 */ priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q; for(int i = 0; i &lt; n; i++) q.push(a[i]);for(int i = 0; i &lt; n; i++) cout &lt;&lt; q.top() &lt;&lt; endl;/*6.将数组中的元素全部存入set中，并输入一个元素，在set中查找它，找到则删除它 */for(int i = 0; i &lt; n; i++) s.insert(a[i]);int j;scanf("%d", &amp;j);set&lt;int&gt;::iterator itt;itt = s.find(j);if(itt != s.end()) s.erase(itt);for(itt = s.begin(); itt != s.end(); itt++) cout &lt;&lt; *itt &lt;&lt; endl;/*7.将学生的姓名和成绩全部存入map中，并根据学生成绩降序排序。(不能修改给定map的两个参数的顺序) */ //第一种 int cmp(pair &lt;string, int&gt; a, pair&lt;string, int&gt; b);pair&lt;string, int&gt; pa;for(int i = 0; i &lt; n; i++) pa = make_pair(student[i].name, student[i].grade);for(int i = 0; i &lt; n; i++) stu.insert(pair&lt;string, int&gt;(student[i].name, student[i].grade));vector&lt;pair&lt;string, int&gt; &gt; baba(stu.begin(), stu.end() );sort(baba.begin(), baba.end(), cmp);for(int i = 0; i &lt; baba.size(); i++) cout &lt;&lt; baba[i].first &lt;&lt; " " &lt;&lt; baba[i].second &lt;&lt; endl;//第二种(就是直接用make_pair插入以及sort函数直接用greater逆序排列) for(int i = 0; i &lt; n; i++) stu.insert(make_pair(student[i].name, student[i].grade)); vector&lt;pair&lt;string, int&gt; &gt; yeye(stu.begin(), stu.end() );sort(yeye.begin(), yeye.end(), greater&lt;pair&lt;string, int&gt; &gt;());for(int i = 0; i &lt; n; i++) cout &lt;&lt; yeye[i].first &lt;&lt; " " &lt;&lt; yeye[i].second &lt;&lt; endl;//分割线 return 0;&#125; bool cmp(pair &lt;string, int&gt; a, pair&lt;string, int&gt; b) &#123; return a.second &gt; b.second; &#125;]]></content>
      <categories>
        <category>stl</category>
        <category>代码练习</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stl介绍]]></title>
    <url>%2F2019%2F03%2F08%2Fstl%2F</url>
    <content type="text"><![CDATA[注意，STL头文件没有扩展名.h STL中默认是采用小于号来排序的 stl很好的介绍（原链接） c++手册 1.容器概论 容器，置物之所也。像桶可装水，碗可盛汤，C++的容器，可以存储对象。容器有多种，用来处理不同的元素操作诉求。按照元素存储到容器中以及访问方式的差异，容器分为顺序容器与关联容器。 顺序容器也称为序列式容器。序列式容器按元素插入的顺序存储元素，这些元素可以进行排序，但未必是有序的。C++本身内置了一个序列式容器array（数组），STL另外提供了vector,list,forward_list,deque,stack,queue,priority-queue，string等等序列式容器。 所有的容器都是基于模板实现的，因为容器必须保证能装得下各种各样的类型。其中，stack，queue都是基于deque来实现的，priority-queue基于heap来实现，从技术上来说它们属于容器适配器（adapter）。其中array与forward_list是C++11添加的新容器类型。 2.序列式容器（顺序容器） 向量(vector) 连续存储的元素&lt;vector&gt; 列表(list) 由节点组成的双向链表，每个结点包含着一个元素&lt;list&gt; 双端队列(deque) 连续存储的指向不同元素的指针所组成的数组&lt;deque&gt; 3.适配器容器 栈(stack) 后进先出的值的排列 &lt;stack&gt; 队列(queue) 先进先出的值的排列&lt;queue&gt; 优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 &lt;queue&gt; 4.关联式容器 关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。 集合(set) 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序&lt;set&gt; 多重集合(multiset) 允许存在两个次序相等的元素的集合&lt;set&gt; 映射(map) 由{键，值}对组成的集合，以某种作用于键对上的谓词排列 &lt;map&gt; 多重映射(multimap) 允许键对有相等的次序的映射&lt;map&gt; 5.容器适配器 stack，也称为栈，是一种先进后出的数据结构。STL中的statck是一种容器适配器。所谓的容器适配器，是以某种容器作为底部容器，在底部容器之上修改接口，形成另一种风貌。stack默认以双端队列deque作为底部容器。stack没有提供迭代器，通过push/pop接口对栈顶元素进行操作。 queue，也称为队列，是一种先进先出的数据结构，它同样也是一种容器适配器。它的底部容器默认为deque。同样，queue也没有提供迭代器，通过push向队尾压入元素，pop从队首弹出元素。 priority-queue，优先队列，是一种拥有权值观念的队列，例如在以整数大小作为衡量的权值定义下，priority-queue总是弹出最大的数。priority-queue的底部数据结构默认是max-heap，大顶堆。 6.基础总结 注意： “尾部可高效插入/删除元素”，意味着在除了尾部之外的其他位置插入/删除元素是较低效的。 “顺序访问”意味着要访问某一个元素，必须遍历其他元素。 迭代器失效意味着指针、引用在同样的情况下也会失效。 所有容器都有以下两个成员函数： int size()：返回容器对象中元素的个数。 bool empty()：判断容器对象是否为空。 顺序容器和关联容器还有以下成员函数： begin()：返回指向容器中第一个元素的迭代器。 end()：返回指向容器中最后一个元素后面的位置的迭代器。 rbegin()：返回指向容器中最后一个元素的反向迭代器。 rend()：返回指向容器中第一个元素前面的位置的反向迭代器。 erase(…)：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。 clear()：从容器中删除所有元素。 如果一个容器是空的，则 begin() 和 end() 的返回值相等，rbegin() 和 rend() 的返回值也相等。 顺序容器还有以下常用成员函数： front()：返回容器中第一个元素的引用。 back()：返回容器中最后一个元素的引用。 push_back()：在容器末尾增加新元素。 pop_back()：删除容器末尾的元素。 insert(…)：插入一个或多个元素。该函数参数较复杂，此处省略。]]></content>
      <categories>
        <category>stl</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++map容器]]></title>
    <url>%2F2019%2F03%2F08%2Fc-map%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[STL是一个统一的整体，map的很多用法都和STL中其它的东西结合在一起 map中由于它内部有序，由红黑树保证，因此很多函数执行的时间复杂度都是log2N的，如果用map函数可以实现的功能，而STL Algorithm也可以完成该功能，建议用map自带函数，效率高一些。 sort算法有个限制，利用sort算法只能对序列容器进行排序，就是线性的（如vector，list，deque）。map是一个集合容器，它里面存储的元素是pair，但是它不是线性存储的（像红黑树），所以利用sort不能直接和map结合进行排序。 operator()重载必须是常成员函数，因为常对象只能调用常成员函数 STL中默认是采用小于号来排序的 键和值的数据类型是不相同的，这与set不同。set中的key和value是Key类型的，而map中的key和value是一个pair结构中的两个分量 stl-map greater &lt;int&gt; &gt;最右边的两个&gt;之间要有空格，否则 Dev C++ 会将它们当作右移运算符，导致编译出错对map的排序 key值排序 按照Key值自动进行了排序 上面的按key值排序有个缺点：即当插入的有多个相等的值时，由于key的唯一性，会只保留一个。 map的定义12345template &lt; class Key, class T, class Compare = less&lt;Key&gt;, class Allocator = allocator&lt;pair&lt;const Key,T&gt; &gt; &gt; class map; 它有四个参数，其中我们比较熟悉的有两个: Key 和 Value。第四个是 Allocator，用来定义存储分配模型的 现在重点看下第三个参数： class Compare = less&lt;Key&gt;这也是一个class类型的，而且提供了默认值 less&lt;Key&gt;。 less是stl里面的一个函数对象，那么什么是函数对象呢？所谓的函数对象：即调用操作符的类，其对象常称为函数对象（function object），它们是行为类似函数的对象。表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个 类，其实质是对operator()操作符的重载。 less的实现： 12345678template &lt;class T&gt; struct less : binary_function &lt;T,T,bool&gt; &#123; bool operator() (const T&amp; x, const T&amp; y) const &#123;return x&lt;y;&#125;&#125;; 是一个带模板的struct，里面仅仅对()运算符进行了重载，实现很简单，但用起来很方便，这就是函数对象的优点所在。stl中还为四则运算等常见运算定义了这样的函数对象，与less相对的还有greater map这里指定less作为其默认比较函数(对象)，所以我们通常如果不自己指定Compare，map中键值对就会按照Key的less顺序进行组织存储 可以在定义map的时候，指定它的第三个参数Compare，比如我们把默认的less指定为greater：要加#include &lt;functional&gt; map&lt;string, int, greater&lt;string&gt; &gt; name_score_map; 只要我们自己写一个函数对象，实现想要的逻辑，定义map的时候把Compare指定为我们自己编写的这个就ok啦。 1234567891011 struct CmpByKeyLength &#123; bool operator()(const string&amp; k1, const string&amp; k2) const &#123; return k1.length() &lt; k2.length(); &#125; &#125;; -`map&lt;string, int, CmpByKeyLength&gt; name_score_map;` 按照value排序 思路1：可以考虑将value作为key值进行自动排序。 思路2：可以把map中的key值和value值分别转存到一个pair类型的vector中，在对vector按照一定的规则排序即可。这样的方法对值一样的情况也能够使用。 12345678910111213 typedef pair&lt;string, int&gt; PAIR; map&lt;string, int&gt; name_score_map; name_score_map.insert(make_pair("Bing", 99)); name_score_map.insert(make_pair("Albert", 86));vector&lt;PAIR&gt; name_score_vec(name_score_map.begin(), name_score_map.end());sort(name_score_vec.begin(), name_score_vec.end(), cmp); map的构造 在 C++ 中通过 insert() 方法向集合中插入一个新的映射，参数是一个 pair 类型的结构。pair&lt;int,char&gt;(1,’a’)定义了一个整数 1 和字符 a 的 pair。我们向映射中加入新映射对的时候就是通过 pair 来实现的。如果插入的 key 之前已经有 value，不会用插入的新的 value 替代原来的 value，也就是插入无效，但并不会报错。 如果插入语句没有生效，那么这就涉及到我们怎么知道 insert 语句是否插入成功的问题了，可以通过 pair 来获得是否插入成功，程序如下： 1234pair&lt;map&lt;int, string&gt;::iterator, bool&gt; insert_pair;insert_pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, "student_one")); 我们通过 pair 的第二个变量来知道是否插入成功，它的第一个变量返回的是一个 map 迭代器，如果插入成功的话，insert_pair.second应该是 true，否则为 false。 用数组方式就不同了，它可以覆盖以前该关键字对应的值 是否已经有映射了。需要用到 count() 函数进行判断或者find std::map::count size_type count( const Key&amp; key ) const; template&lt; class K &gt; size_type count( const K&amp; x ) const; 返回拥有关键比较等价于指定参数的元素数，因为此容器不允许重复故为 1 或 0。 1) 返回拥有关键 key 的元素数。 2) 返回拥有关键比较等价于值 x 的元素数。此重载仅若有限定 id Compare::is_transparent合法且指代一个类型才参与重载决议。这允许调用此函数而不构造 Key 的实例。 参数 key 要计量元素数的关键值 x 要与关键比较的替用值 返回值拥有比较等价于 key 或 x 的关键的元素数，对于 (1) 为 1 或 0。 mapStudent.insert(pair&lt;int, string&gt;(2, &quot;student_two&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); mapStudent[1] = &quot;student_one&quot;; 总结： 对key 排序的话，直接使用greater&lt;string&gt;在map定义的时候就。而要对value排序，则是使用函数对象，先将map转换为vector，调用sort函数中传入一个函数对象，则可以实现对value 的排序。还有一点是pair 只重载了&amp;lt;，则stl 则不能使用 == 运算符。]]></content>
      <categories>
        <category>stl</category>
        <category>map</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bool类型]]></title>
    <url>%2F2019%2F03%2F08%2Fbool%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[千万不要让编译器决定你的默认值，永远初始化 变量未初始化的默认值要看变量的存储类型，也可能与编译器有关，跟其它因素 bool类型 c++中有bool类型 bool可用于定义函数类型为布尔型，函数里可以有 return TRUE; return FALSE 之类的语句。 初始化 为了安全起见， 最好初始化为false. bool值一定要初始化 在GCC编译器下各个类型的全局变量的默认值： 表示数字的变量类型默认值都为0 bool型默认值为false string型默认值为空字符串 char 型比较特殊。char类型默认值为’\0’， 即字符串结束标志，其整数值为0。如果用printf(“%d”)输出时值为 0， 但用printf(“%c”),或cout 输出时显示为”a”， char型数组默认值为空字符串，其中的每个元素与单个char类型相同，所以用puts() 和printf(“%s”)输出都是空字符串。]]></content>
      <categories>
        <category>c++</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换]]></title>
    <url>%2F2019%2F03%2F06%2F%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[类型转换 进行不同数据的强制转换其实就是数据占用字节扩充或者截断。 将数据由值域较宽类型强制转换到值域较窄类型时，有可能出现数据信息丢失。 char 型数据在机器里通过 ASCII 码存储，也就是用一个整数存储的。 当执行一个运算时（如这里的a&gt;b），如果它的一个运算数是有符号的而另一个数是无符号的，那么C语言会隐式地将有符号 参数强制类型为无符号数，并假设这两个数都是非负的，来执行这个运算]]></content>
      <categories>
        <category>数据类型</category>
        <category>类型转换</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码块高亮]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BB%A3%E7%A0%81%E5%9D%97%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[主题自带样式 代码块高亮 这里指的是1234```[language] [title] [url] [link-text]代码 [language] 是代码语言的名称，用来设置代码块颜色高亮，非必须； [title] 是顶部左边的说明，非必须； [url] 是顶部右边的超链接地址，非必须； [link text] 如它的字面意思，超链接的名称，非必须。 亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数筛选法]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数学原理 一个数 n 如果是合数，那么它的所有的因子不超过sqrt(n)–n的开方 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数 质数大于等于2 不能被它本身和1以外的数整除 素数筛选法 素数是数学中一个很重要的数，很多算法中都需要用到素数相关的性质，因此传统的暴力循环求素数的效率显得十分低效，这里我们有两种高效求1~n以内的素数的方法。需要大家掌握，特别是欧拉筛法里面用到一点数学性质，大家可自行百度欧拉筛法掌握具体的原理，以后的出现的算法中还会出现。 欧拉筛法-时间复杂度（n) 回顾经典的Eratosthenes筛法，它可能对同一个质数筛去多次。那么如果用某种方法使得每个合数只被筛去一次就变成是线性的了。不妨规定每个合数只用其最小的一个质因数去筛，这便是欧拉筛了。 最简单的素数筛法是这样的：10000000内的素数，用这个筛选法可以大大的降低时间复杂度 1.开一个大的bool型数组prime[]，大小就是n+1就可以了.先把所有的下标为奇数的标为true,下标为偶数的标为false. 2.然后：1234567for( i=3; i&lt;=sqrt(n); i+=2 )&#123; if(prime) for( j=i+i; j&lt;=n; j+=i ) prime[j]=false;&#125; 3.最后输出bool数组中的值为true的单元的下标，就是所求的n以内的素数了。 原理很简单，就是当i是质(素)数的时候，i的所有的倍数必然是合数。如果i已经被判断不是质数了，那么再找到i后面的质数来把这个质数的倍数筛掉。 原理 No.1使用 合数=最大因数(除1和本身外)最小质因数 的原理来筛，每个数只会被筛一次对于每个数i，令它是某数的最大因数，然后从小到大地找&lt;=i的素数j，则ij是合数直到找到某个j使得i%j == 0,因为再往后的话，j’&gt; i的某个因子，我们能交换j’和i的这个因子，所以i不是ij’的最大因数（或者说ij’的最小质因数是刚才的那个j），再往后做没有意义 No.2回顾经典的Eratosthenes筛法，它可能对同一个质数筛去多次。那么如果用某种方法使得每个合数只被筛去一次就变成是线性的了。不妨规定每个合数只用其最小的一个质因数去筛，这便是欧拉筛了。 No.3线性筛有两个地方与一般筛不同: 1.两层循环的顺序不同（一般筛是第一维prime[i] 第二维j，欧拉筛是第一维i 第二位prime[j]） 2.一行神奇的代码： if(i%prime[j]==0)break; prime[]数组中的素数是递增的,当i能整除prime[j]，那么iprime[j+1]这个合数肯定被prime[j]乘以某个数筛掉。 因为i中含有prime[j],prime[j]比prime[j+1]小，即 `i=kprime[j]，那么iprime[j+1]=(kprime[j])prime [j+1]=k’prime[j]，接下去的素数同理。所以不用筛下去了。因此，在满足i%prime[j]==0`这个条件之前以及第一次 满足改条件时,prime[j]必定是prime[j]*i的最小因子。 No.4 证明分两部分。首先证每个合数都会被筛到（正确性），其次证每个合数只会被筛到一次（复杂度）。每个合数都会被筛到设有一合数 （为质数）则一定会在 时被筛去（此时 ），因为对于小于 的质数，一定不会被 整除每个合数都只会被筛到一次与上面一样，还是设有一合数 （ 为质数）倘若存在一个质因子 也筛去了，那么此时 。o，此时在内层循环中已经早早地break掉了，因为 。o，此时还没加进质数表QwQ（顺便一提：这种情况只有可能在 时发生） 代码：12345678910111213void euler_sieve(int n) &#123; totPrimes = 0; memset(flag, 0, sizeof(flag)); for (int i = 2; i &lt;= n; i++) &#123; if (!flag[i]) primes[totPrimes++] = i; for (int j = 0; i * primes[j] &lt;= n; j++) &#123; flag[i*primes[j]] = true; if (i % primes[j] == 0) break; &#125; &#125; &#125; j &lt; totPrimes为何不加？ o当 为质数时，内层循环会在最后一个质数（也就是 自己）终止。o当 为合数时，内层循环会在它的第一个质因数终止。当然加了也没有问题 埃拉特斯特尼筛法，时间复杂度（nlogn）]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%88%86%E6%B2%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分治法 这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……可使用分治法求解的一些经典问题 （1）二分搜索（2）大整数乘法（3）Strassen矩阵乘法（4）棋盘覆盖（5）合并排序（6）快速排序（7）线性时间选择（8）最接近点对问题（9）循环赛日程表（10）汉诺塔 -]]></content>
      <categories>
        <category>算法</category>
        <category>分治法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出]]></title>
    <url>%2F2019%2F03%2F05%2Fc-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[续行符 宏定义只能在一行内完成 字符串多行书写有两种规则：在字符串换行处加一个反斜杠\，下一行前不能有空格或者Tab键；使用双引号。 代码中的“\”是 C 语言中的续行符语法，表示续行符的下一行与续行符所在的代码是同一行,因为宏定义关键字“#define”只是对当前行有效，所以使用续行符来连接 应用续行符的时候要注意，在“\”后面不能有任何字符(包括注释、空格)，只能直接回车。在要强制换行的地方输入反斜杠然后回车 c语言中还有一种拆分字符串的方法，那就是将其写个多个相邻的字符串。这些字符串之间用0个或者多个空白、制作符以及换行符隔开。 printf(&quot;Programming&quot; &quot; in c&quot; &quot; is fun&quot;\n);//Programing in c is fun 1234567printf( &quot; ********\n&quot; &quot; ************\n&quot; &quot; ####....#.\n&quot; &quot; #..###.....##....\n&quot; ); 输入输出 gets()函数并不读取换行符’\n’,它会吧换行符替换成空字符’\0’,作为c语言字符串结束的标志.此时换行符已经没了！！ gets在C99标准中，已经不再建议使用gets()函数，而在C11中更是直接抛弃了这个函数,gets函数没有限制读入的个数，这很可能会导致程序向未知的内存空间写入数据，而导致程序出错。 fgets函数中第二个参数限制了读取的个数，这也解决了gets函数存在的问题，但要注意fgets函数只会读取n-1个字符（如果遇到换行符会更少），并在最后添加字符串结束标志，而且，fgets也会将换行符读入。char *fgets(char *buf, int bufsize, FILE *stream)；注意一下第二个参数bufsize，这个参数就限制了读取的字符的个数，这就可以解决gets()函数的缺陷。我们知道fgets() 函数主要用于读取文件，如果要读取键盘，则stream参数应该为stdin，需要注意的是，如果bufsize设置为n，那么fgets()函数最多读取n-1个字符，之所以用“最多”这个词是因为，如果在之前遇到了换行符，fgets函数也会返回。还有一点就是，fgets()函数会读取换行符（这一点和gets函数不同），当读取结束后，fgets函数会为buf在末尾添加一个空字符作为字符串的结束. scanf函数要实现修改变量值的功能，传地址就相当于传指针（指向一个内存位置）！printf只是对变量值执行输出功能，不涉及改变！ 输入输出返回值 scanf为函数，printf为函数(输入与输出函数)：返回值：scanf 函数的返回值反映的是按照指定的格式符正确读入的数据的个数。如果输入数据与指定格式不符，则会产生输入错误。遇到输入错误，scanf函数会立即终止，返回已经成功读取的数据的个数。所以通过scanf函数的返回值和指定输入数据的个数（由格式符决定）的比较，可以判断数据输入是否成功。 scanf 函数是有返回值的，它的返回值可以分成三种情况 正整数，表示正确输入参数的个数。例如执行 scanf(“%d %d”, &amp;a, &amp;b); 如果用户输入&quot;3 4&quot;，可以正确输入，返回2（正确输入了两个变量）； 如果用户输入&quot;3,4&quot;，可以正确输入a，无法输入b，返回1（正确输入了一个变量）。 0，表示用户的输入不匹配，无法正确输入任何值。如上例，用户如果输入”,3 4”，返回0。 EOF，这是在stdio.h里面定义的常量（通常值为-1），表示输入流已经结束(scanf遇到格式不对返回EOF或结束时)(EOF == end of file) printf的返回值是输出的字符数，例如，printf(&quot;1234&quot;)的返回值是4，而printf(&quot;1234\n&quot;)的返回值是5。不知道有木有这样写的习惯while (~scanf(&quot;....&quot;))。这里出现了~这个符号，这个是位运算取反的意思。因为~(n)=-(n+1)。所以这里scanf的返回值为-1时~(-1)=0才退出循环。这就是这样写的意思。 c++输入输出 cout在输出很大的数时,会用科学计数法输出,若不想如此输出，可将原来输出数double类型与float类型改为int类型，或者如下. cout&lt;&lt;std::fixed&lt;&lt; a &lt;&lt;endl; printf(&quot;%.0lf&quot;, a); 当数字过大时可能数字有变化或丢失(自测) fixed后面还可以加格式控制符控制位数，setprecision(n)——设置输出浮点数的精度，配合fixed设定，指的是小数位数，设置setprecision(0)即指输出不带小数位的int值。 还有其它方法！！！ c++cout123456789cout &lt;&lt; "a - b = " &lt;&lt; stringSubString(a, b) &lt;&lt; endl &lt;&lt; "a * b = " &lt;&lt; stringMultString(a, b) &lt;&lt; endl &lt;&lt; "a / b = " &lt;&lt; stringDivString(a, b) &lt;&lt; endl &lt;&lt; "a % b = " &lt;&lt; stringModString(a, b) &lt;&lt; endl &lt;&lt; "gcd(a, b) = " &lt;&lt; stringGcd(a, b) &lt;&lt; endl &lt;&lt; "lcm(a, b) = " &lt;&lt; stringLcm(a, b) &lt;&lt; endl;]]></content>
      <categories>
        <category>输入输出</category>
      </categories>
      <tags>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2F2019%2F03%2F04%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分法(折半查找) 将所给关键词和指定有序集合中间数进行比较,如果比较相等则返回结果,如果不相等,则按照所给出的结果,将集合减半后继续查找 二分法是减治法的思想 二分法：(low+high)/2,如果故意卡数据即low与high很大的话,会越界.所以可以为(high - low)/2+low; 优化(先确定范围) 插值查找 这里的插值查找法,是对二分法的一种改进.此法和二分法一样对数据要求有序且尽量分布均匀 对于二分法有: mid = (low + high)/2;不难得到 mid = low + 1/2*(high-low);试想,对于在字典中进行查找时,对于’you’或’and’来说,我们通常的处理方法肯定不是从中间开始进行查找,而是根据所给出的值,大致确定范围后再来进行查找.这里的大致范围是通过,所查找的value值在所查集合中所大概处于的位置,定位到后进行比较故有如下公式:key = low + ((value - a[low])/(a[high]-a[low]))*（high-low); 伪代码: 12345678910111213141516171819int insertseek(int value,int map[]) int low,high,key; low = 0; high = n -1 ;while(low&lt;=high)key = low + ((value - low)/(high-low))*（high -low);if(key = value) return key;else if(key &lt; value) low = key;else high = key;]]></content>
      <categories>
        <category>算法</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c与c++常用函数]]></title>
    <url>%2F2019%2F03%2F04%2Fc%E4%B8%8Ec-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[常用函数 max, min, fill, memset, sort, swap 字符串函数 字符串比较函数strcmp因为原理是两个字符串一个个比较，所以可以比较字符是否相同！！！！！ 如果把序号按字符串存储，则会可以通过strcmp比较序号是否相同。(有用) Strlen函数如果没有遇到’\0’，会一直计算下去，字符串二维数组不可以用strlen，因为二维数组每一行相当于一个字符串一维数组，每一行都有’\0’！ c++标准库里字符串相关函数的声明，凡是不修改内容的地方一律声明为const char *, strlen(const char *),strcmp(const char *, const char *),strcpy(char *, const char *)第一个参数会被修改 strcpy函数 原型声明：char *strcpy(char* dest, const char *src); 功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间 说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。 返回指向dest的指针。对于出现异常的情况ANSI-C99标准并未定义，故由实现者决定返回值，通常为NULL。 tolower函数 定义函数：int tolower(int c); 函数说明：若参数 c 为大写字母则将该对应的小写字母返回。 返回值：返回转换后的小写字母，若不须转换则将参数c 值返回。tolower(s[i]); #include &lt;cctype&gt; fill函数 在头文件&lt;algorithm&gt;里面 按照单元赋值，将一个区间的元素都赋同一个值fill(arr, arr + n, 要填入的内容);vector也可以：fill(v.begin(), v.end(), 要填入的内容); fill 和fill_n函数是C++ Primer第十二章泛型算法部分内容，并把它们称为生成和变异算法，也就是说这两个函数只能对输入范围内已存在的元素进行操作。如果试图对空容器进行fill_n操作，会导致严重的运行错误，所以在对元素进行写入操作时要检查目标的大小是否足以存储要写入的元素。 fill的内部实现就是一个for循环 12345678910template&lt; class ForwardIt, class T &gt;void fill(ForwardIt first, ForwardIt last, const T&amp; value)&#123; for (; first != last; ++first) &#123; *first = value; &#125;&#125; 对二维数组 动态分配二维数组是指的new或者malloc申请内存memset函数 1.memeset函数只能对连续的内存空间初始化。两次用malloc函数或new在堆上分的内存可能会不连续，因此错误。 2.如果是直接声明的多维数组如a[5][5]，其内存肯定是连续的，此时统一memset没问题(动态声明的二维数组不一定内存连续) memset函数的初始化只能对一维数组或者直接定义的而巍峨数组，对于动态分配的二维数组，对于每一行，是连续分配的； 然而对于各行之间，却不一定是连续分配的，容易出错 fill函数 123456789101112131415161718int mp[20][20];fill(mp[0],mp[0]+20*20,5);for(int i=0;i&lt;20;i++)&#123;for(int j=0;j&lt;20;j++)cout&lt;&lt;mp[i][j]&lt;&lt;" "; cout&lt;&lt;endl; &#125; 与memset()函数的区别： memset的初始化速度比循环要快很多 fill和for循环事件是一样的 fill的源码就是for循环实现的 两者都可以用来对数组填充，memset是对按照字节来填充的，所以一般用来填充char型数组，也经常用于填充int型的全0或全-1操作。 fill是按照单元来填充的，所以可以填充一个区间的任意值。 fill_n函数 在头文件&lt;algorithm&gt;里。 fill_n(vec.begin, cnt, val);从当前起始点开始，将之后的cnt个元素赋值为val。 注意：不能在没有元素的空容器上调用fill_n()函数 memset函数 在头文件&lt;cstring&gt;里面 Memset函数:可以本身就是为字符数组设计的源代码：unsigned int 有一个特性就是如果将其赋值或者当作字节来使用的话，编译器将会截取低八位作为一个字节使用。 1234567891011void *(memset)(void *s, int c, size_t n) &#123;const unsigned char uc = c;unsigned char *su;for (su = s; 0 &lt; n; ++su, --n) *su = uc;return (s);&#125; 源码说明对于数组参数是按照字符数组的形式进行赋值的。也就是c的值每次赋值给一个字节，而不是4个字节，c的类型是int类型，4个字节，但只会赋值最低位的一个字节的内容。 对于非单字节数据类型只能初始化为0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值0的结果都是0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果。 对于变量：当结构体类型中包含指针时，在使用memset初始化时需要小心。struct sample_strcut stTest;用memset就非常方便：memset(&amp;stTest,0,sizeof(struct sample_struct));原因是memset初始化的时候是按字节一个一个填充的，int有四个字节，于是填充成0000 0001 0000 0001 0000 00001 0000 0001，这样得出数组中的每个元素的值就是16843009了。赋值时0与\0效果一样。 可以用于清空数组内元素与赋,memset函数一般用来填充char型数组,也经常用于填充int型的全0或全-1.不可用其它值，除非高低字节相同. -123456 #define INF 0x3f3f3f3f int num[N]; memset(num, INF, sizeof(num)); 这样得到的数组里面的每一个元素数值都是INF看一下INF的二进制表示：00111111001111110011111100111111可以看出低8位是00111111，也就是实际赋值时是用00111111来填充一个int类型，结果正好也是00111111001111110011111100111111于是就成功用memset进行了赋值。 INF小知识 0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。 最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。所以在通常的场合下，const int INF = 0x3f3f3f3f;真的是一个非常棒的选择。 因为在某些编译器分配空间时,内存中默认值并不为0,所以先用memset函数赋初值0. 转换函数atoi()函数 用来将字符串转换成整数(int)：int atoi (const char * str); 【返回值】返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。 atoi() 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;\0&#39;)才结束转换，并将结果返回。 Enter a number: 233cyuyan The value entered is 233. atol函数 定义函数：long atol(const char *nptr); 函数说明： atol()会扫描参数nptr字符串，跳过前面的空格字符(就是忽略掉字符串左空格的意思)，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回。 返回值：返回转换后的长整型数。如果传入的字符串为空，或者字符串包含的内容非阿拉伯数字序列，则函数返回默认值0。 atof函数 定义函数 double atof(const char *nptr); 函数说明 atof()会扫描参数nptr字符串，跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;\0&#39;)才结束转换，并将结果返回。参数nptr字符串可包含正负号、小数点或E(e)来表示指数部分，如123.456或123e-2。 返回值 返回转换后的浮点型数。 范例： 1234567891011#include&lt;stdlib.h&gt;int main()&#123; char*a="-100.23"; char*b="200e-2"; doublec; c=atof(a)+atof(b); printf(“c=%.2lf\n”,c); return 0;&#125;]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法核心思想：倍增]]></title>
    <url>%2F2019%2F03%2F03%2F%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E5%80%8D%E5%A2%9E%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据类型问题]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数据 二进制不能表示所有的小数，他只是选一个离需表示值的最近的一个数进行储存而已。 输出有e时,可能是输出变量类型float,double的问题，可改为int其它类型试试 int类型不会出现浮点数,不要用int型存计算结果的浮点数]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作4]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C4%2F</url>
    <content type="text"><![CDATA[图片插入 将markdown需要用的图片放到git仓库中，发布到github上 访问图片,点 download 按钮，页面打开后,在地址栏可以复制图片地址，或者在Download按钮上直接右键 “复制链接地址” TOC数字块👇1. 左边为效果2. 左边为效果]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作3]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C3%2F</url>
    <content type="text"><![CDATA[反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 文字增加背景色块 在你需要编辑的文章地方。放置如下代码： 站点配置文件 主题配置文件 站点配置文件 主题配置文件 主题自带样式FontAwesome(以下图标必须在网页上方点击全部显示才能显示即受保护的内容) fa-lg fa-2x fa-3x fa-4x fa-5x note标签 在主题配置文件_config.yml里有一个关于这个的配置,需要提前设置. default primary success info warning danger danger no-icon]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[崴脚恢复]]></title>
    <url>%2F2019%2F03%2F01%2F%E5%B4%B4%E8%84%9A%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[崴脚恢复 脚踝的灵活性、稳定性、力量都难以通过养伤养好，你还需要进行康复训练。被动休息治疗结合主动康复训练才能最大程度恢复受损的功能。 脚踝康复应当按照恢复活动度—恢复力量—恢复平衡能力—恢复爆发力的顺序进行]]></content>
      <categories>
        <category>身体健康</category>
        <category>崴脚</category>
      </categories>
      <tags>
        <tag>身体健康</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作2]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C2%2F</url>
    <content type="text"><![CDATA[Front-matter description是文章的描述,在每篇文章标题下方显示 有date,tags,categories,comments,password(要配置),keywords,updated layout页面布局，默认为post,有draft(草稿)和page 符号 : 为英文符号,格式很重要,不管是主题配置文件还是站点配置文件中空格,不空格都有要求 permalink若站点配置文件下的 permalink 配置了 title 则可以替换文章 URL 里面的 title（文章标题） 还有photos,link,image,sticky(后面2个要配置) 若创建文章时标题错误,可在编辑md文件时通过titile修改,文件重命名没用 格式一定要正确,有时可能没识别出来,要重新输入]]></content>
      <categories>
        <category>blog</category>
        <category>文章模板</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作]]></title>
    <url>%2F2019%2F02%2F28%2Fblog%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[hexo博客写作 若layout为draft,那么静态页面不会渲染生成。 符号-、1.和文本之间要保留一个字符的空格. 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。如果不空格,标题无法显示。 引用符号&gt; 和文本之间要保留一个字符的空格 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。例如：一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 Markdwon 文档写完一段回车后务必再回车一次空一行！ 需要引用代码时，如果引用的语句只有一段，不分行，可以用符号` 将语句包起来。 如果引用的语句为多行，可以将`置于这段代码的首行和末行， markdown快速键入 mdi + tab键：插入图片mdl + tab键: 插入链接mdc + tab键：插入代码mdh1 + tab键：插入一级标题，2就是二级标题…… 引用 在引用内再次引用的话，只需要敲下回车然后加两个大于号「&gt;&gt;」就好了，如果想要在引用内的引用继续引用的话（喘口气先）那就加三个大于号「&gt;&gt;&gt;」。例如： 有一天小美睡不着，她就缠着小最给她讲故事，于是小最就给她讲了一个故事： 很久以前有只小美睡不着，要小最给她讲故事，小最就给她讲了下面这个故事： 很久以前有只小美睡不着，要小最给她讲故事，小最就给她讲了下面这个故事： ……]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颈椎养护手册]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%A2%88%E6%A4%8E%E5%85%BB%E6%8A%A4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[日常不良习惯 当你的距离不能够清楚的看清屏幕是你就会头向前伸，此时颈椎压力变大；而当你的距离不能够把胳膊自然下垂放在桌上或者椅子上的时候，手肘就会悬空，此时肩膀压力变大去承担手臂的重量！ 使用过高或者过低的枕头，而和高枕头一样不好的就是不睡枕头，让脖子悬空。这两种情况都会让颈部肌肉紧张，无法放松，还会导致颈椎排列结构的改变 养护1.习惯侧睡的可以选择高一点的枕头，喜欢平躺仰卧的可以选择低一点，睡觉建议选择记忆棉枕头。不要窝着睡觉！！！脖子底下一定要有枕头！！！侧睡的枕头大概1.5倍拳头的高，仰睡的枕头大概一个拳头那么高！！！ 2.睡前如果身体僵硬难受，千万别直接入睡，一定要冲个热水澡或者扭动身体让身体放松，否则第二天早上起来容易落枕或者有其他疼痛。 3.必须要严格制定运动计划，并且保持至少一个小时就起来溜达溜达，伸腰踢腿. 4.我们眼睛看的屏幕一定要跟眼睛在同一水平线上，同时远近合适，这样可以避免低头和往前探后。 5.拉伸组合：上、右转、右上、右下、右歪、左歪、左下、左上、左、回正，记住，速度要慢，每次停留至少10秒]]></content>
      <categories>
        <category>身体健康</category>
        <category>颈椎</category>
      </categories>
      <tags>
        <tag>身体健康</tag>
      </tags>
  </entry>
</search>
