<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bool类型]]></title>
    <url>%2F2019%2F03%2F08%2Fbool%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[千万不要让编译器决定你的默认值，永远初始化 变量未初始化的默认值要看变量的存储类型，也可能与编译器有关，跟其它因素 bool类型 c++中有bool类型 bool可用于定义函数类型为布尔型，函数里可以有 return TRUE; return FALSE 之类的语句。 初始化 为了安全起见， 最好初始化为false. bool值一定要初始化 在GCC编译器下各个类型的全局变量的默认值： 表示数字的变量类型默认值都为0 bool型默认值为false string型默认值为空字符串 char 型比较特殊。char类型默认值为’\0’， 即字符串结束标志，其整数值为0。如果用printf(“%d”)输出时值为 0， 但用printf(“%c”),或cout 输出时显示为”a”， char型数组默认值为空字符串，其中的每个元素与单个char类型相同，所以用puts() 和printf(“%s”)输出都是空字符串。]]></content>
      <categories>
        <category>c++</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换]]></title>
    <url>%2F2019%2F03%2F06%2F%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[类型转换 进行不同数据的强制转换其实就是数据占用字节扩充或者截断。 将数据由值域较宽类型强制转换到值域较窄类型时，有可能出现数据信息丢失。 char 型数据在机器里通过 ASCII 码存储，也就是用一个整数存储的。 当执行一个运算时（如这里的a&gt;b），如果它的一个运算数是有符号的而另一个数是无符号的，那么C语言会隐式地将有符号 参数强制类型为无符号数，并假设这两个数都是非负的，来执行这个运算]]></content>
      <categories>
        <category>数据类型</category>
        <category>类型转换</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码块高亮]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BB%A3%E7%A0%81%E5%9D%97%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[主题自带样式 代码块高亮 这里指的是1234```[language] [title] [url] [link-text]代码 [language] 是代码语言的名称，用来设置代码块颜色高亮，非必须； [title] 是顶部左边的说明，非必须； [url] 是顶部右边的超链接地址，非必须； [link text] 如它的字面意思，超链接的名称，非必须。 亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数筛选法]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数学原理 一个数 n 如果是合数，那么它的所有的因子不超过sqrt(n)–n的开方 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数 质数大于等于2 不能被它本身和1以外的数整除 素数筛选法 素数是数学中一个很重要的数，很多算法中都需要用到素数相关的性质，因此传统的暴力循环求素数的效率显得十分低效，这里我们有两种高效求1~n以内的素数的方法。需要大家掌握，特别是欧拉筛法里面用到一点数学性质，大家可自行百度欧拉筛法掌握具体的原理，以后的出现的算法中还会出现。 欧拉筛法-时间复杂度（n) 最简单的素数筛法是这样的：10000000内的素数，用这个筛选法可以大大的降低时间复杂度 1.开一个大的bool型数组prime[]，大小就是n+1就可以了.先把所有的下标为奇数的标为true,下标为偶数的标为false. 2.然后：1234567for( i=3; i&lt;=sqrt(n); i+=2 )&#123; if(prime) for( j=i+i; j&lt;=n; j+=i ) prime[j]=false;&#125; 3.最后输出bool数组中的值为true的单元的下标，就是所求的n以内的素数了。 原理很简单，就是当i是质(素)数的时候，i的所有的倍数必然是合数。如果i已经被判断不是质数了，那么再找到i后面的质数来把这个质数的倍数筛掉。 原理 No.1使用 合数=最大因数(除1和本身外)最小质因数 的原理来筛，每个数只会被筛一次对于每个数i，令它是某数的最大因数，然后从小到大地找&lt;=i的素数j，则ij是合数直到找到某个j使得i%j == 0,因为再往后的话，j’&gt; i的某个因子，我们能交换j’和i的这个因子，所以i不是ij’的最大因数（或者说ij’的最小质因数是刚才的那个j），再往后做没有意义 No.2回顾经典的Eratosthenes筛法，它可能对同一个质数筛去多次。那么如果用某种方法使得每个合数只被筛去一次就变成是线性的了。不妨规定每个合数只用其最小的一个质因数去筛，这便是欧拉筛了。 No.3线性筛有两个地方与一般筛不同: 1.两层循环的顺序不同（一般筛是第一维prime[i] 第二维j，欧拉筛是第一维i 第二位prime[j]） 2.一行神奇的代码： if(i%prime[j]==0)break; prime[]数组中的素数是递增的,当i能整除prime[j]，那么iprime[j+1]这个合数肯定被prime[j]乘以某个数筛掉。 因为i中含有prime[j],prime[j]比prime[j+1]小，即 `i=kprime[j]，那么iprime[j+1]=(kprime[j])prime [j+1]=k’prime[j]，接下去的素数同理。所以不用筛下去了。因此，在满足i%prime[j]==0`这个条件之前以及第一次 满足改条件时,prime[j]必定是prime[j]*i的最小因子。 No.4 证明分两部分。首先证每个合数都会被筛到（正确性），其次证每个合数只会被筛到一次（复杂度）。每个合数都会被筛到设有一合数 （为质数）则一定会在 时被筛去（此时 ），因为对于小于 的质数，一定不会被 整除每个合数都只会被筛到一次与上面一样，还是设有一合数 （ 为质数）倘若存在一个质因子 也筛去了，那么此时 。o，此时在内层循环中已经早早地break掉了，因为 。o，此时还没加进质数表QwQ（顺便一提：这种情况只有可能在 时发生） 代码：12345678910111213void euler_sieve(int n) &#123; totPrimes = 0; memset(flag, 0, sizeof(flag)); for (int i = 2; i &lt;= n; i++) &#123; if (!flag[i]) primes[totPrimes++] = i; for (int j = 0; i * primes[j] &lt;= n; j++) &#123; flag[i*primes[j]] = true; if (i % primes[j] == 0) break; &#125; &#125; &#125; j &lt; totPrimes为何不加？ o当 为质数时，内层循环会在最后一个质数（也就是 自己）终止。o当 为合数时，内层循环会在它的第一个质因数终止。当然加了也没有问题 埃拉特斯特尼筛法，时间复杂度（nlogn）]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%88%86%E6%B2%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分治法可使用分治法求解的一些经典问题 （1）二分搜索（2）大整数乘法（3）Strassen矩阵乘法（4）棋盘覆盖（5）合并排序（6）快速排序（7）线性时间选择（8）最接近点对问题（9）循环赛日程表（10）汉诺塔 -]]></content>
      <categories>
        <category>算法</category>
        <category>分治法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出]]></title>
    <url>%2F2019%2F03%2F05%2Fc-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[续行符 宏定义只能在一行内完成 字符串多行书写有两种规则：在字符串换行处加一个反斜杠\，下一行前不能有空格或者Tab键；使用双引号。 代码中的“\”是 C 语言中的续行符语法，表示续行符的下一行与续行符所在的代码是同一行,因为宏定义关键字“#define”只是对当前行有效，所以使用续行符来连接 应用续行符的时候要注意，在“\”后面不能有任何字符(包括注释、空格)，只能直接回车。在要强制换行的地方输入反斜杠然后回车 c语言中还有一种拆分字符串的方法，那就是将其写个多个相邻的字符串。这些字符串之间用0个或者多个空白、制作符以及换行符隔开。 printf(&quot;Programming&quot; &quot; in c&quot; &quot; is fun&quot;\n);//Programing in c is fun 1234567printf( &quot; ********\n&quot; &quot; ************\n&quot; &quot; ####....#.\n&quot; &quot; #..###.....##....\n&quot; ); 输入输出 gets()函数并不读取换行符’\n’,它会吧换行符替换成空字符’\0’,作为c语言字符串结束的标志.此时换行符已经没了！！ gets在C99标准中，已经不再建议使用gets()函数，而在C11中更是直接抛弃了这个函数,gets函数没有限制读入的个数，这很可能会导致程序向未知的内存空间写入数据，而导致程序出错。 fgets函数中第二个参数限制了读取的个数，这也解决了gets函数存在的问题，但要注意fgets函数只会读取n-1个字符（如果遇到换行符会更少），并在最后添加字符串结束标志，而且，fgets也会将换行符读入。char *fgets(char *buf, int bufsize, FILE *stream)；注意一下第二个参数bufsize，这个参数就限制了读取的字符的个数，这就可以解决gets()函数的缺陷。我们知道fgets() 函数主要用于读取文件，如果要读取键盘，则stream参数应该为stdin，需要注意的是，如果bufsize设置为n，那么fgets()函数最多读取n-1个字符，之所以用“最多”这个词是因为，如果在之前遇到了换行符，fgets函数也会返回。还有一点就是，fgets()函数会读取换行符（这一点和gets函数不同），当读取结束后，fgets函数会为buf在末尾添加一个空字符作为字符串的结束. scanf函数要实现修改变量值的功能，传地址就相当于传指针（指向一个内存位置）！printf只是对变量值执行输出功能，不涉及改变！ 输入输出返回值 scanf为函数，printf为函数(输入与输出函数)：返回值：scanf 函数的返回值反映的是按照指定的格式符正确读入的数据的个数。如果输入数据与指定格式不符，则会产生输入错误。遇到输入错误，scanf函数会立即终止，返回已经成功读取的数据的个数。所以通过scanf函数的返回值和指定输入数据的个数（由格式符决定）的比较，可以判断数据输入是否成功。 scanf 函数是有返回值的，它的返回值可以分成三种情况 正整数，表示正确输入参数的个数。例如执行 scanf(“%d %d”, &amp;a, &amp;b); 如果用户输入&quot;3 4&quot;，可以正确输入，返回2（正确输入了两个变量）； 如果用户输入&quot;3,4&quot;，可以正确输入a，无法输入b，返回1（正确输入了一个变量）。 0，表示用户的输入不匹配，无法正确输入任何值。如上例，用户如果输入”,3 4”，返回0。 EOF，这是在stdio.h里面定义的常量（通常值为-1），表示输入流已经结束(scanf遇到格式不对返回EOF或结束时)(EOF == end of file) printf的返回值是输出的字符数，例如，printf(&quot;1234&quot;)的返回值是4，而printf(&quot;1234\n&quot;)的返回值是5。不知道有木有这样写的习惯while (~scanf(&quot;....&quot;))。这里出现了~这个符号，这个是位运算取反的意思。因为~(n)=-(n+1)。所以这里scanf的返回值为-1时~(-1)=0才退出循环。这就是这样写的意思。 c++输入输出 cout在输出很大的数时,会用科学计数法输出,若不想如此输出，可将原来输出数double类型与float类型改为int类型，或者如下. cout&lt;&lt;std::fixed&lt;&lt; a &lt;&lt;endl; printf(&quot;%.0lf&quot;, a); 当数字过大时可能数字有变化或丢失(自测) fixed后面还可以加格式控制符控制位数，setprecision(n)——设置输出浮点数的精度，配合fixed设定，指的是小数位数，设置setprecision(0)即指输出不带小数位的int值。 还有其它方法！！！]]></content>
      <tags>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2F2019%2F03%2F04%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分法(折半查找) 将所给关键词和指定有序集合中间数进行比较,如果比较相等则返回结果,如果不相等,则按照所给出的结果,将集合减半后继续查找 二分法是减治法的思想 二分法：(low+high)/2,如果故意卡数据即low与high很大的话,会越界.所以可以为(high - low)/2+low; 优化(先确定范围) 插值查找 这里的插值查找法,是对二分法的一种改进.此法和二分法一样对数据要求有序且尽量分布均匀 对于二分法有: mid = (low + high)/2;不难得到 mid = low + 1/2*(high-low);试想,对于在字典中进行查找时,对于’you’或’and’来说,我们通常的处理方法肯定不是从中间开始进行查找,而是根据所给出的值,大致确定范围后再来进行查找.这里的大致范围是通过,所查找的value值在所查集合中所大概处于的位置,定位到后进行比较故有如下公式:key = low + ((value - a[low])/(a[high]-a[low]))*（high-low); 伪代码: 12345678910111213141516171819int insertseek(int value,int map[]) int low,high,key; low = 0; high = n -1 ;while(low&lt;=high)key = low + ((value - low)/(high-low))*（high -low);if(key = value) return key;else if(key &lt; value) low = key;else high = key;]]></content>
      <categories>
        <category>算法</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c与c++常用函数]]></title>
    <url>%2F2019%2F03%2F04%2Fc%E4%B8%8Ec-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[常用函数 max, min, fill, memset, sort, swap 字符串函数 字符串比较函数strcmp因为原理是两个字符串一个个比较，所以可以比较字符是否相同！！！！！如果把序号按字符串存储，则会可以通过strcmp比较序号是否相同。(有用) Strlen函数如果没有遇到’\0’，会一直计算下去，字符串二维数组不可以用strlen，因为二维数组每一行相当于一个字符串一维数组，每一行都有’\0’！ tolower函数 定义函数：int tolower(int c); 函数说明：若参数 c 为大写字母则将该对应的小写字母返回。 返回值：返回转换后的小写字母，若不须转换则将参数c 值返回。tolower(s[i]); #include &lt;cctype&gt; fill函数 在头文件&lt;algorithm&gt;里面 按照单元赋值，将一个区间的元素都赋同一个值fill(arr, arr + n, 要填入的内容);vector也可以：fill(v.begin(), v.end(), 要填入的内容); fill 和fill_n函数是C++ Primer第十二章泛型算法部分内容，并把它们称为生成和变异算法，也就是说这两个函数只能对输入范围内已存在的元素进行操作。如果试图对空容器进行fill_n操作，会导致严重的运行错误，所以在对元素进行写入操作时要检查目标的大小是否足以存储要写入的元素。 与memset()函数的区别： 两者都可以用来对数组填充，memset是对按照字节来填充的，所以一般用来填充char型数组，也经常用于填充int型的全0或全-1操作。 fill是按照单元来填充的，所以可以填充一个区间的任意值。 fill_n函数 在头文件&lt;algorithm&gt;里。 fill_n(vec.begin, cnt, val);从当前起始点开始，将之后的cnt个元素赋值为val。 注意：不能在没有元素的空容器上调用fill_n()函数 memset函数 在头文件&lt;cstring&gt;里面 Memset函数:可以本身就是为字符数组设计的源代码：unsigned int 有一个特性就是如果将其赋值或者当作字节来使用的话，编译器将会截取低八位作为一个字节使用。 1234567891011void *(memset)(void *s, int c, size_t n) &#123;const unsigned char uc = c;unsigned char *su;for (su = s; 0 &lt; n; ++su, --n) *su = uc;return (s);&#125; 源码说明对于数组参数是按照字符数组的形式进行赋值的。也就是c的值每次赋值给一个字节，而不是4个字节，c的类型是int类型，4个字节，但只会赋值最低位的一个字节的内容。 对于非单字节数据类型只能初始化为0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值0的结果都是0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果。 对于变量：当结构体类型中包含指针时，在使用memset初始化时需要小心。struct sample_strcut stTest;用memset就非常方便：memset(&amp;stTest,0,sizeof(struct sample_struct));原因是memset初始化的时候是按字节一个一个填充的，int有四个字节，于是填充成0000 0001 0000 0001 0000 00001 0000 0001，这样得出数组中的每个元素的值就是16843009了。赋值时0与’\0’效果一样。 可以用于清空数组内元素与赋,memset函数一般用来填充char型数组,也经常用于填充int型的全0或全-1.不可用其它值，除非高低字节相同. - ` #define INF 0x3f3f3f3f int num[N]; memset(num, INF, sizeof(num)); 这样得到的数组里面的每一个元素数值都是INF看一下INF的二进制表示：00111111001111110011111100111111可以看出低8位是00111111，也就是实际赋值时是用00111111来填充一个int类型，结果正好也是00111111001111110011111100111111于是就成功用memset进行了赋值。 INF小知识 0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。 最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。所以在通常的场合下，const int INF = 0x3f3f3f3f;真的是一个非常棒的选择。 因为在某些编译器分配空间时,内存中默认值并不为0,所以先用memset函数赋初值0. 转换函数atoi()函数 用来将字符串转换成整数(int)：int atoi (const char * str); 【返回值】返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。 atoi() 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回。 Enter a number: 233cyuyan The value entered is 233.]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法核心思想：倍增]]></title>
    <url>%2F2019%2F03%2F03%2F%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E5%80%8D%E5%A2%9E%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据类型问题]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数据 二进制不能表示所有的小数，他只是选一个离需表示值的最近的一个数进行储存而已。 输出有e时,可能是输出变量类型float,double的问题，可改为int其它类型试试 int类型不会出现浮点数,不要用int型存计算结果的浮点数]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作4]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C4%2F</url>
    <content type="text"><![CDATA[图片插入 将markdown需要用的图片放到git仓库中，发布到github上 访问图片,点 download 按钮，页面打开后,在地址栏可以复制图片地址，或者在Download按钮上直接右键 “复制链接地址” TOC数字块👇1. 左边为效果2. 左边为效果]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作3]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C3%2F</url>
    <content type="text"><![CDATA[反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 文字增加背景色块 在你需要编辑的文章地方。放置如下代码： 站点配置文件 主题配置文件 站点配置文件 主题配置文件 主题自带样式FontAwesome(以下图标必须在网页上方点击全部显示才能显示即受保护的内容) fa-lg fa-2x fa-3x fa-4x fa-5x note标签 在主题配置文件_config.yml里有一个关于这个的配置,需要提前设置. default primary success info warning danger danger no-icon]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[崴脚恢复]]></title>
    <url>%2F2019%2F03%2F01%2F%E5%B4%B4%E8%84%9A%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[崴脚恢复 脚踝的灵活性、稳定性、力量都难以通过养伤养好，你还需要进行康复训练。被动休息治疗结合主动康复训练才能最大程度恢复受损的功能。 脚踝康复应当按照恢复活动度—恢复力量—恢复平衡能力—恢复爆发力的顺序进行]]></content>
      <categories>
        <category>身体健康</category>
        <category>崴脚</category>
      </categories>
      <tags>
        <tag>身体健康</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作2]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C2%2F</url>
    <content type="text"><![CDATA[Front-matter description是文章的描述,在每篇文章标题下方显示 有date,tags,categories,comments,password(要配置),keywords,updated layout页面布局，默认为post,有draft(草稿)和page 符号 : 为英文符号,格式很重要,不管是主题配置文件还是站点配置文件中空格,不空格都有要求 permalink若站点配置文件下的 permalink 配置了 title 则可以替换文章 URL 里面的 title（文章标题） 还有photos,link,image,sticky(后面2个要配置) 若创建文章时标题错误,可在编辑md文件时通过titile修改,文件重命名没用 格式一定要正确,有时可能没识别出来,要重新输入]]></content>
      <categories>
        <category>blog</category>
        <category>文章模板</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作]]></title>
    <url>%2F2019%2F02%2F28%2Fblog%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[hexo博客写作 若layout为draft,那么静态页面不会渲染生成。 符号-、1.和文本之间要保留一个字符的空格. 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。如果不空格,标题无法显示。 引用符号&gt; 和文本之间要保留一个字符的空格 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。例如：一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 Markdwon 文档写完一段回车后务必再回车一次空一行！ 需要引用代码时，如果引用的语句只有一段，不分行，可以用符号` 将语句包起来。 如果引用的语句为多行，可以将`置于这段代码的首行和末行， markdown快速键入 mdi + tab键：插入图片mdl + tab键: 插入链接mdc + tab键：插入代码mdh1 + tab键：插入一级标题，2就是二级标题……]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颈椎养护手册]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%A2%88%E6%A4%8E%E5%85%BB%E6%8A%A4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[日常不良习惯 当你的距离不能够清楚的看清屏幕是你就会头向前伸，此时颈椎压力变大；而当你的距离不能够把胳膊自然下垂放在桌上或者椅子上的时候，手肘就会悬空，此时肩膀压力变大去承担手臂的重量！ 使用过高或者过低的枕头，而和高枕头一样不好的就是不睡枕头，让脖子悬空。这两种情况都会让颈部肌肉紧张，无法放松，还会导致颈椎排列结构的改变 养护1.习惯侧睡的可以选择高一点的枕头，喜欢平躺仰卧的可以选择低一点，睡觉建议选择记忆棉枕头。不要窝着睡觉！！！脖子底下一定要有枕头！！！侧睡的枕头大概1.5倍拳头的高，仰睡的枕头大概一个拳头那么高！！！ 2.睡前如果身体僵硬难受，千万别直接入睡，一定要冲个热水澡或者扭动身体让身体放松，否则第二天早上起来容易落枕或者有其他疼痛。 3.必须要严格制定运动计划，并且保持至少一个小时就起来溜达溜达，伸腰踢腿. 4.我们眼睛看的屏幕一定要跟眼睛在同一水平线上，同时远近合适，这样可以避免低头和往前探后。 5.拉伸组合：上、右转、右上、右下、右歪、左歪、左下、左上、左、回正，记住，速度要慢，每次停留至少10秒]]></content>
      <categories>
        <category>身体健康</category>
        <category>颈椎</category>
      </categories>
      <tags>
        <tag>身体健康</tag>
      </tags>
  </entry>
</search>
