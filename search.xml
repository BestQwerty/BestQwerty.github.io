<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[代码块高亮]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BB%A3%E7%A0%81%E5%9D%97%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[主题自带样式 代码块高亮 这里指的是1234```[language] [title] [url] [link-text]代码 [language] 是代码语言的名称，用来设置代码块颜色高亮，非必须； [title] 是顶部左边的说明，非必须； [url] 是顶部右边的超链接地址，非必须； [link text] 如它的字面意思，超链接的名称，非必须。 亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数筛选法]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数学原理 一个数 n 如果是合数，那么它的所有的因子不超过sqrt(n)–n的开方 素数筛选法 素数是数学中一个很重要的数，很多算法中都需要用到素数相关的性质，因此传统的暴力循环求素数的效率显得十分低效，这里我们有两种高效求1~n以内的素数的方法。需要大家掌握，特别是欧拉筛法里面用到一点数学性质，大家可自行百度欧拉筛法掌握具体的原理，以后的出现的算法中还会出现。 欧拉筛法-时间复杂度（n) 最简单的素数筛法是这样的：10000000内的素数，用这个筛选法可以大大的降低时间复杂度 1.开一个大的bool型数组prime[]，大小就是n+1就可以了.先把所有的下标为奇数的标为true,下标为偶数的标为false. 2.然后：1234567for( i=3; i&lt;=sqrt(n); i+=2 )&#123; if(prime) for( j=i+i; j&lt;=n; j+=i ) prime[j]=false;&#125; 3.最后输出bool数组中的值为true的单元的下标，就是所求的n以内的素数了。 原理很简单，就是当i是质(素)数的时候，i的所有的倍数必然是合数。如果i已经被判断不是质数了，那么再找到i后面的质数来把这个质数的倍数筛掉。 原理 No.1使用 合数=最大因数(除1和本身外)最小质因数 的原理来筛，每个数只会被筛一次对于每个数i，令它是某数的最大因数，然后从小到大地找&lt;=i的素数j，则ij是合数直到找到某个j使得i%j == 0,因为再往后的话，j’&gt; i的某个因子，我们能交换j’和i的这个因子，所以i不是ij’的最大因数（或者说ij’的最小质因数是刚才的那个j），再往后做没有意义 No.2回顾经典的Eratosthenes筛法，它可能对同一个质数筛去多次。那么如果用某种方法使得每个合数只被筛去一次就变成是线性的了。不妨规定每个合数只用其最小的一个质因数去筛，这便是欧拉筛了。 No.3线性筛有两个地方与一般筛不同: 1.两层循环的顺序不同（一般筛是第一维prime[i] 第二维j，欧拉筛是第一维i 第二位prime[j]） 2.一行神奇的代码： if(i%prime[j]==0)break; prime[]数组中的素数是递增的,当i能整除prime[j]，那么iprime[j+1]这个合数肯定被prime[j]乘以某个数筛掉。 因为i中含有prime[j],prime[j]比prime[j+1]小，即 `i=kprime[j]，那么iprime[j+1]=(kprime[j])prime [j+1]=k’prime[j]，接下去的素数同理。所以不用筛下去了。因此，在满足i%prime[j]==0`这个条件之前以及第一次 满足改条件时,prime[j]必定是prime[j]*i的最小因子。 No.4 证明分两部分。首先证每个合数都会被筛到（正确性），其次证每个合数只会被筛到一次（复杂度）。每个合数都会被筛到设有一合数 （为质数）则一定会在 时被筛去（此时 ），因为对于小于 的质数，一定不会被 整除每个合数都只会被筛到一次与上面一样，还是设有一合数 （ 为质数）倘若存在一个质因子 也筛去了，那么此时 。o，此时在内层循环中已经早早地break掉了，因为 。o，此时还没加进质数表QwQ（顺便一提：这种情况只有可能在 时发生） 代码：12345678910111213void euler_sieve(int n) &#123; totPrimes = 0; memset(flag, 0, sizeof(flag)); for (int i = 2; i &lt;= n; i++) &#123; if (!flag[i]) primes[totPrimes++] = i; for (int j = 0; i * primes[j] &lt;= n; j++) &#123; flag[i*primes[j]] = true; if (i % primes[j] == 0) break; &#125; &#125; &#125; j &lt; totPrimes为何不加？ o当 为质数时，内层循环会在最后一个质数（也就是 自己）终止。o当 为合数时，内层循环会在它的第一个质因数终止。当然加了也没有问题]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%88%86%E6%B2%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分治法可使用分治法求解的一些经典问题 （1）二分搜索（2）大整数乘法（3）Strassen矩阵乘法（4）棋盘覆盖（5）合并排序（6）快速排序（7）线性时间选择（8）最接近点对问题（9）循环赛日程表（10）汉诺塔 -]]></content>
      <categories>
        <category>算法</category>
        <category>分治法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入输出]]></title>
    <url>%2F2019%2F03%2F05%2Fc-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[输入输出 gets()函数并不读取换行符’\n’,它会吧换行符替换成空字符’\0’,作为c语言字符串结束的标志.此时换行符已经没了！！ gets在C99标准中，已经不再建议使用gets()函数，而在C11中更是直接抛弃了这个函数,gets函数没有限制读入的个数，这很可能会导致程序向未知的内存空间写入数据，而导致程序出错。 fgets函数中第二个参数限制了读取的个数，这也解决了gets函数存在的问题，但要注意fgets函数只会读取n-1个字符（如果遇到换行符会更少），并在最后添加字符串结束标志，而且，fgets也会将换行符读入。char *fgets(char *buf, int bufsize, FILE *stream)；注意一下第二个参数bufsize，这个参数就限制了读取的字符的个数，这就可以解决gets()函数的缺陷。我们知道fgets() 函数主要用于读取文件，如果要读取键盘，则stream参数应该为stdin，需要注意的是，如果bufsize设置为n，那么fgets()函数最多读取n-1个字符，之所以用“最多”这个词是因为，如果在之前遇到了换行符，fgets函数也会返回。还有一点就是，fgets()函数会读取换行符（这一点和gets函数不同），当读取结束后，fgets函数会为buf在末尾添加一个空字符作为字符串的结束. scanf函数要实现修改变量值的功能，传地址就相当于传指针（指向一个内存位置）！printf只是对变量值执行输出功能，不涉及改变！ 输入输出返回值 scanf为函数，printf为函数(输入与输出函数)：返回值：scanf 函数的返回值反映的是按照指定的格式符正确读入的数据的个数。如果输入数据与指定格式不符，则会产生输入错误。遇到输入错误，scanf函数会立即终止，返回已经成功读取的数据的个数。所以通过scanf函数的返回值和指定输入数据的个数（由格式符决定）的比较，可以判断数据输入是否成功。 scanf 函数是有返回值的，它的返回值可以分成三种情况 正整数，表示正确输入参数的个数。例如执行 scanf(“%d %d”, &amp;a, &amp;b); 如果用户输入&quot;3 4&quot;，可以正确输入，返回2（正确输入了两个变量）； 如果用户输入&quot;3,4&quot;，可以正确输入a，无法输入b，返回1（正确输入了一个变量）。 0，表示用户的输入不匹配，无法正确输入任何值。如上例，用户如果输入”,3 4”，返回0。 EOF，这是在stdio.h里面定义的常量（通常值为-1），表示输入流已经结束(scanf遇到格式不对返回EOF或结束时)(EOF == end of file) printf的返回值是输出的字符数，例如，printf(&quot;1234&quot;)的返回值是4，而printf(&quot;1234\n&quot;)的返回值是5。不知道有木有这样写的习惯while (~scanf(&quot;....&quot;))。这里出现了~这个符号，这个是位运算取反的意思。因为~(n)=-(n+1)。所以这里scanf的返回值为-1时~(-1)=0才退出循环。这就是这样写的意思。]]></content>
      <tags>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2F2019%2F03%2F04%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分法(折半查找) 将所给关键词和指定有序集合中间数进行比较,如果比较相等则返回结果,如果不相等,则按照所给出的结果,将集合减半后继续查找 二分法是减治法的思想 二分法：(low+high)/2,如果故意卡数据即low与high很大的话,会越界.所以可以为(high - low)/2+low; 优化(先确定范围) 插值查找 这里的插值查找法,是对二分法的一种改进.此法和二分法一样对数据要求有序且尽量分布均匀 对于二分法有: mid = (low + high)/2;不难得到 mid = low + 1/2*(high-low);试想,对于在字典中进行查找时,对于’you’或’and’来说,我们通常的处理方法肯定不是从中间开始进行查找,而是根据所给出的值,大致确定范围后再来进行查找.这里的大致范围是通过,所查找的value值在所查集合中所大概处于的位置,定位到后进行比较故有如下公式:key = low + ((value - a[low])/(a[high]-a[low]))*（high-low); 伪代码: 12345678910111213141516171819int insertseek(int value,int map[]) int low,high,key; low = 0; high = n -1 ;while(low&lt;=high)key = low + ((value - low)/(high-low))*（high -low);if(key = value) return key;else if(key &lt; value) low = key;else high = key;]]></content>
      <categories>
        <category>算法</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c与c++常用函数]]></title>
    <url>%2F2019%2F03%2F04%2Fc%E4%B8%8Ec-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[常用函数 max, min, fill, memset, sort, swap 字符串函数 字符串比较函数strcmp因为原理是两个字符串一个个比较，所以可以比较字符是否相同！！！！！如果把序号按字符串存储，则会可以通过strcmp比较序号是否相同。(有用) Strlen函数如果没有遇到’\0’，会一直计算下去，字符串二维数组不可以用strlen，因为二维数组每一行相当于一个字符串一维数组，每一行都有’\0’！ memset函数 Memset函数:可以本身就是为字符数组设计的源代码：unsigned int 有一个特性就是如果将其赋值或者当作字节来使用的话，编译器将会截取低八位作为一个字节使用。 1234567891011void *(memset)(void *s, int c, size_t n) &#123;const unsigned char uc = c;unsigned char *su;for (su = s; 0 &lt; n; ++su, --n) *su = uc;return (s);&#125; 源码说明对于数组参数是按照字符数组的形式进行赋值的。也就是c的值每次赋值给一个字节，而不是4个字节，c的类型是int类型，4个字节，但只会赋值最低位的一个字节的内容。 对于非单字节数据类型只能初始化为0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值0的结果都是0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果。 对于变量：当结构体类型中包含指针时，在使用memset初始化时需要小心。struct sample_strcut stTest;用memset就非常方便：memset(&amp;stTest,0,sizeof(struct sample_struct));原因是memset初始化的时候是按字节一个一个填充的，int有四个字节，于是填充成0000 0001 0000 0001 0000 00001 0000 0001，这样得出数组中的每个元素的值就是16843009了。赋值时0与’\0’效果一样。 可以用于清空数组内元素与赋,memset函数一般用来填充char型数组,也经常用于填充int型的全0或全-1.不可用其它值，除非高低字节相同. - ` #define INF 0x3f3f3f3f int num[N]; memset(num, INF, sizeof(num)); 这样得到的数组里面的每一个元素数值都是INF看一下INF的二进制表示：00111111001111110011111100111111可以看出低8位是00111111，也就是实际赋值时是用00111111来填充一个int类型，结果正好也是00111111001111110011111100111111于是就成功用memset进行了赋值。 INF小知识 0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。 最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。所以在通常的场合下，const int INF = 0x3f3f3f3f;真的是一个非常棒的选择。 因为在某些编译器分配空间时,内存中默认值并不为0,所以先用memset函数赋初值0.]]></content>
      <categories>
        <category>c++</category>
        <category>常用函数</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法核心思想：倍增]]></title>
    <url>%2F2019%2F03%2F03%2F%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E5%80%8D%E5%A2%9E%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据类型问题]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数据 二进制不能表示所有的小数，他只是选一个离需表示值的最近的一个数进行储存而已。 输出有e时,可能是输出变量类型float,double的问题，可改为int其它类型试试 int类型不会出现浮点数,不要用int型存计算结果的浮点数]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作4]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C4%2F</url>
    <content type="text"><![CDATA[图片插入 将markdown需要用的图片放到git仓库中，发布到github上 访问图片,点 download 按钮，页面打开后,在地址栏可以复制图片地址，或者在Download按钮上直接右键 “复制链接地址”]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作3]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C3%2F</url>
    <content type="text"><![CDATA[反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 文字增加背景色块 在你需要编辑的文章地方。放置如下代码： 站点配置文件 主题配置文件 站点配置文件 主题配置文件 主题自带样式FontAwesome(以下图标必须在网页上方点击全部显示才能显示即受保护的内容) fa-lg fa-2x fa-3x fa-4x fa-5x note标签 在主题配置文件_config.yml里有一个关于这个的配置,需要提前设置. default primary success info warning danger danger no-icon]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[崴脚恢复]]></title>
    <url>%2F2019%2F03%2F01%2F%E5%B4%B4%E8%84%9A%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[崴脚恢复 脚踝的灵活性、稳定性、力量都难以通过养伤养好，你还需要进行康复训练。被动休息治疗结合主动康复训练才能最大程度恢复受损的功能。 脚踝康复应当按照恢复活动度—恢复力量—恢复平衡能力—恢复爆发力的顺序进行]]></content>
      <categories>
        <category>身体健康</category>
        <category>崴脚</category>
      </categories>
      <tags>
        <tag>身体健康</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作2]]></title>
    <url>%2F2019%2F03%2F01%2Fblog%E5%86%99%E4%BD%9C2%2F</url>
    <content type="text"><![CDATA[Front-matter description是文章的描述,在每篇文章标题下方显示 有date,tags,categories,comments,password(要配置),keywords,updated layout页面布局，默认为post,有draft(草稿)和page 符号 : 为英文符号,格式很重要,不管是主题配置文件还是站点配置文件中空格,不空格都有要求 permalink若站点配置文件下的 permalink 配置了 title 则可以替换文章 URL 里面的 title（文章标题） 还有photos,link,image,sticky(后面2个要配置) 若创建文章时标题错误,可在编辑md文件时通过titile修改,文件重命名没用 格式一定要正确,有时可能没识别出来,要重新输入]]></content>
      <categories>
        <category>blog</category>
        <category>文章模板</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog写作]]></title>
    <url>%2F2019%2F02%2F28%2Fblog%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[hexo博客写作 若layout为draft,那么静态页面不会渲染生成。 符号-、1.和文本之间要保留一个字符的空格. 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。如果不空格,标题无法显示。 引用符号&gt; 和文本之间要保留一个字符的空格 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。例如：一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 Markdwon 文档写完一段回车后务必再回车一次空一行！ 需要引用代码时，如果引用的语句只有一段，不分行，可以用符号` 将语句包起来。 如果引用的语句为多行，可以将`置于这段代码的首行和末行， markdown快速键入 mdi + tab键：插入图片mdl + tab键: 插入链接mdc + tab键：插入代码mdh1 + tab键：插入一级标题，2就是二级标题……]]></content>
      <categories>
        <category>blog</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颈椎养护手册]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%A2%88%E6%A4%8E%E5%85%BB%E6%8A%A4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[日常不良习惯 当你的距离不能够清楚的看清屏幕是你就会头向前伸，此时颈椎压力变大；而当你的距离不能够把胳膊自然下垂放在桌上或者椅子上的时候，手肘就会悬空，此时肩膀压力变大去承担手臂的重量！ 使用过高或者过低的枕头，而和高枕头一样不好的就是不睡枕头，让脖子悬空。这两种情况都会让颈部肌肉紧张，无法放松，还会导致颈椎排列结构的改变 养护1.习惯侧睡的可以选择高一点的枕头，喜欢平躺仰卧的可以选择低一点，睡觉建议选择记忆棉枕头。不要窝着睡觉！！！脖子底下一定要有枕头！！！侧睡的枕头大概1.5倍拳头的高，仰睡的枕头大概一个拳头那么高！！！ 2.睡前如果身体僵硬难受，千万别直接入睡，一定要冲个热水澡或者扭动身体让身体放松，否则第二天早上起来容易落枕或者有其他疼痛。 3.必须要严格制定运动计划，并且保持至少一个小时就起来溜达溜达，伸腰踢腿. 4.我们眼睛看的屏幕一定要跟眼睛在同一水平线上，同时远近合适，这样可以避免低头和往前探后。 5.拉伸组合：上、右转、右上、右下、右歪、左歪、左下、左上、左、回正，记住，速度要慢，每次停留至少10秒]]></content>
      <categories>
        <category>身体健康</category>
        <category>颈椎</category>
      </categories>
      <tags>
        <tag>身体健康</tag>
      </tags>
  </entry>
</search>
